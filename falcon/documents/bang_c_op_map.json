{
    "move": "void __bang_move(void *dst, const void *src, unsigned int size, unsigned int dst_stride0, unsigned int dst_segnum1, unsigned int dst_stride1, unsigned int dst_segnum2, unsigned int src_stride0, unsigned int src_segnum1, unsigned int src_stride1, unsigned int src_segnum2)   Copies data from <src> to <dst> in 3 dimensions. As shown in Figure 3D Memory Copy Function with Stride , the cells with blue background indicate <size> of data to be copied in each segment. In this case, there are 3 segments in the first dimension. In each segment, <src\\_stride0> of data are copied to destination area <src\\_segnum1> times. There are 2 segments in the second dimension. In each segment, <src\\_stride1> of data are copied to destination area <src\\_segnum2> times. Then, copy the data into corresponding segments and dimensions of <dst>. Please note that <src\\_segnum1>, <dst\\_segnum1>, <src\\_segnum2> and <dst\\_segnum2> are the real segment number minus one. Parameters* [out] dst: The address of destination area.\n* [in] src: The address of source area.\n* [in] size: The number of bytes of one segment.\n* [in] dst\\_stride0: The destination address stride(bytes) in the first dimension.\n* [in] dst\\_segnum1: The destination segment number in the first dimension.\n* [in] dst\\_stride1: The destination address stride(bytes) in the second dimension.\n* [in] dst\\_segnum2: The destination segment number in the second dimension.\n* [in] src\\_stride0: The source address stride(bytes) in the first dimension.\n* [in] src\\_segnum1: The source segment number in the first dimension.\n* [in] src\\_stride1: The source address stride(bytes) in the second dimension.\n* [in] src\\_segnum2: The source segment number in the second dimension. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero;\n* <dst\\_stride0> and <dst\\_stride1> must be greater than or equal to <size>;\n* <src\\_stride0> and <src\\_stride1> must be greater than or equal to 0;\n* The total number of iterations at the source must be equal to the total number of iterations at the destination, i.e., (<dst\\_segnum1> + 1) * (<dst\\_segnum2> + 1) = (<src\\_segnum1> + 1) * (<src\\_segnum2> + 1);\n* When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372. Example\n```",
    "memcpy": "void __memcpy(void *dst, const void *src, unsigned int size, mluMemcpyDirection_t dir, int dst_stride0, unsigned int dst_segnum1, int dst_stride1, unsigned int dst_segnum2, int src_stride0, unsigned int src_segnum1, int src_stride1, unsigned int src_segnum2, unsigned int id_dst_cluster)   void __memcpy(void *dst, const void *src, unsigned int size, mluMemcpyDirection_t dir, int dst_stride0, unsigned int dst_segnum1, int dst_stride1, unsigned int dst_segnum2, int src_stride0, unsigned int src_segnum1, int src_stride1, unsigned int src_segnum2)   Copies data from the <src> address space to the <dst> address space in three dimensions. As shown in Figure 3D Memory Copy Function with Stride , the cells with blue background indicate <size> of data to be copied in each segment. In this case, there are 3 segments in the first dimension. <src\\_stride0> of data in each segment are copied to destination area <src\\_segnum1> +1 times. There are 2 segments in the second dimension. <src\\_stride1> of data in each segment are copied to destination area <src\\_segnum2> +1 times. Then, copy the data into corresponding segments and dimensions of <dst>.  Fig. 3.3 3D Memory Copy Function with Stride Parameters* [out] dst: The address of destination area.\n* [in] src: The address of source area.\n* [in] size: The number of bytes of one segment.\n* [in] dir: Copy direction.\n* [in] dst\\_stride0: The destination stride(bytes) in the first dimension.\n* [in] dst\\_segnum1: The destination segment number minus one in the first dimension.\n* [in] dst\\_stride1: The destination stride(bytes) in the second dimension.\n* [in] dst\\_segnum2: The destination segment number minus one in the second dimension.\n* [in] src\\_stride0: The source stride(bytes) in the first dimension.\n* [in] src\\_segnum1: The source segment number minus one in the first dimension.\n* [in] src\\_stride1: The source stride(bytes) in the second dimension.\n* [in] src\\_segnum2: The source segment number minus one in the second dimension.\n* [in] id\\_dst\\_cluster: Destination cluster ID. Return* void. Remark* When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;\n* The total number of iterations at the source must be equal to the total number of iterations at the destination. That is, the segment numbers need to satisfy: (<dst\\_segnum1> + 1) * (<dst\\_segnum2> + 1) = (<src\\_segnum1> + 1) * (<src\\_segnum2> + 1);\n* The <size> must be greater than zero, and the absolute value of <dst\\_stride0> must be greater than or equal to <size> unless the value of <dst\\_stride0> and <dst\\_segnum1> are equal to zero. The absolute value of <dst\\_stride1> must be greater than or equal to <size> unless the value of <dst\\_stride1> and <dst\\_segnum2> are equal to zero;\n* <id\\_dst\\_cluster> is necessarily used when <dir> is SRAM2SRAM and data is copied across different clusters on mtp\\_2xx and mtp\\_3xx;\n* When <dir> is SRAM2SRAM, copy data across different clusters is not supported on (m)tp\\_5xx or higher;\n* When <dir> is SRAM2SRAM, and there is no <id\\_dst\\_cluster>, it means copy data within cluster;\n* This function supports transferring data within NRAM, WRAM, SRAM, LDRAM and GDRAM except for WRAM2WRAM;\n* When <dst> address space is WRAM, <dst\\_stride0> and <dst\\_stride1> must be divisible by 8;\n* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on tp\\_322 and (m)tp\\_372, and is 0 on other targets;\n* When <dir> is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM, LDRAM2SRAM, SRAM2NRAM, NRAM2SRAM, SRAM2WRAM or WRAM2SRAM, it is not supported on tp\\_322 and tp\\_520. Instruction Pipeline* If either <src> or <dst> is off-chip address, execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;\n* If <dir> is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example\n```",
    "memcpy_async": "void __memcpy_async(void *dst, const void *src, unsigned int size, mluMemcpyDirection_t dir, int dst_stride0, unsigned int dst_segnum1, int dst_stride1, unsigned int dst_segnum2, int src_stride0, unsigned int src_segnum1, int src_stride1, unsigned int src_segnum2, unsigned int id_dst_cluster)   void __memcpy_async(void *dst, const void *src, unsigned int size, mluMemcpyDirection_t dir, int dst_stride0, unsigned int dst_segnum1, int dst_stride1, unsigned int dst_segnum2, int src_stride0, unsigned int src_segnum1, int src_stride1, unsigned int src_segnum2)   Copies data from the <src> address space to the <dst> address space in three dimensions asynchronously. Data operation in the source space is: take the <size> of the data, operate the <src\\_segnum1> times through the <src\\_stride0>, and then take the <src\\_stride1> size to iterate the number of <src\\_segnum2>. Data operation in the destination space is: take the <size> of the data, operate the <dst\\_segnum1> times through the <dst\\_stride0>, and then take the <dst\\_stride1> size to iterate the number of <dst\\_segnum2>. Parameters* [out] dst: The address of destination area.\n* [in] src: The address of source area.\n* [in] size: The number of bytes of one segment.\n* [in] dir: Copy direction.\n* [in] dst\\_stride0: The destination stride(bytes) in the first dimension.\n* [in] dst\\_segnum1: The destination segment number minus one in the first dimension.\n* [in] dst\\_stride1: The destination stride(bytes) in the second dimension.\n* [in] dst\\_segnum2: The destination segment number minus one in the second dimension.\n* [in] src\\_stride0: The source stride(bytes) in the first dimension.\n* [in] src\\_segnum1: The source segment number minus one in the first dimension.\n* [in] src\\_stride1: The source stride(bytes) in the second dimension.\n* [in] src\\_segnum2: The source segment number minus one in the second dimension.\n* [in] id\\_dst\\_cluster: Destination cluster ID. Return* void. Remark* When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;\n* The total number of iterations at the source must be equal to the total number of iterations at the destination. That is, the segment numbers need to satisfy: (<dst\\_segnum1> + 1) * (<dst\\_segnum2> + 1) = (<src\\_segnum1> + 1) * (<src\\_segnum2> + 1);\n* The <size> must be greater than zero, and the absolute value of <dst\\_stride0> must be greater than or equal to <size> unless the value of <dst\\_stride0> and <dst\\_segnum1> are equal to zero. The absolute value of <dst\\_stride1> must be greater than or equal to <size> unless the value of <dst\\_stride1> and <dst\\_segnum2> are equal to zero;\n* <id\\_dst\\_cluster> is necessarily used when <dir> is SRAM2SRAM and data is copied across different clusters on mtp\\_2xx, mtp\\_3xx;\n* When <dir> is SRAM2SRAM, copy data across different clusters is not supported on (m)tp\\_5xx or higher;\n* When <dir> is SRAM2SRAM, and there is no <id\\_dst\\_cluster>, it means copy data within cluster;\n* This function supports transferring data within NRAM, WRAM, SRAM, LDRAM and GDRAM except for WRAM2WRAM;\n* When <dst> address space is WRAM, <dst\\_stride0> and <dst\\_stride1> must be divisible by 8;\n* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on tp\\_322 and (m)tp\\_372, and is 0 on other targets.\n* \\_\\_memcpy\\_async with <id\\_dst\\_cluster> is not supported on (m)tp\\_5xx or higher;\n* When <dir> is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM, LDRAM2SRAM, SRAM2NRAM, NRAM2SRAM, SRAM2WRAM or WRAM2SRAM, it is not supported on tp\\_322 and tp\\_520. Instruction Pipeline* If either <src> or <dst> is off-chip address, execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;\n* If <dir> is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.2.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example\n```",
    "write_value": "void __bang_write_value(void *dst, unsigned int elem_count, char value, unsigned int stride0, unsigned int segnum1, unsigned int stride1, unsigned int segnum2)   void __bang_write_value(void *dst, unsigned int elem_count, half value, unsigned int stride0, unsigned int segnum1, unsigned int stride1, unsigned int segnum2)   void __bang_write_value(void *dst, unsigned int elem_count, bfloat16_t value, unsigned int stride0, unsigned int segnum1, unsigned int stride1, unsigned int segnum2)   void __bang_write_value(void *dst, unsigned int elem_count, short value, unsigned int stride0, unsigned int segnum1, unsigned int stride1, unsigned int segnum2)   void __bang_write_value(void *dst, unsigned int elem_count, float value, unsigned int stride0, unsigned int segnum1, unsigned int stride1, unsigned int segnum2)   void __bang_write_value(void *dst, unsigned int elem_count, int value, unsigned int stride0, unsigned int segnum1, unsigned int stride1, unsigned int segnum2)   Sets a three-dimensional block in the \\_\\_nram\\_\\_ address space pointed by <dst> to the specified <value>. The way of setting <value> is that takes the <elem\\_count> of the data, operates the <segnum1> + 1 times through the <stride0>, and then take the <stride1> size to iterate the number of <segnum2> + 1. Parameters* [out] dst: The address of destination vector.\n* [in] elem\\_count: The number of elements of one segment.\n* [in] value: The value to be set to <dst>.\n* [in] stride0: The destination address stride(bytes) in the first dimension.\n* [in] segnum1: The destination segment number in the first dimension.\n* [in] stride1: The destination address stride(bytes) in the second dimension.\n* [in] segnum2: The destination segment number in the second dimension. Return* void. Remark* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be greater than zero;\n* <stride0> must be greater than or equal to <elem\\_count> \\* sizeof(type), and <stride1> must be greater than or equal to <stride0> \\* (<segnum1> + 1);\n* When the value of <segnum1> and <segnum2> is 0, it represents 1, and when the value is 1, it represents 2, and so on;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.2.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example* None.",
    "write_zero": "void __bang_write_zero(bfloat16_t *dst, unsigned int elem_count)   void __bang_write_zero(signed char *dst, unsigned int elem_count)   void __bang_write_zero(unsigned char *dst, unsigned int elem_count)   void __bang_write_zero(short *dst, unsigned int elem_count)   void __bang_write_zero(unsigned short *dst, unsigned int elem_count)   void __bang_write_zero(int *dst, unsigned int elem_count)   void __bang_write_zero(unsigned int *dst, unsigned int elem_count)   void __bang_write_zero(half *dst, unsigned int elem_count)   void __bang_write_zero(float *dst, unsigned int elem_count)   Sets a vector in \\_\\_nram\\_\\_ address space pointed by <dst> to zero. Parameters* [out] dst: The address of destination vector.\n* [in] elem\\_count: The number of elements in destination vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be greater than zero;\n* The address of <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "atomic_add": "void __bang_atomic_add(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_add(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_add(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_add(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_add(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_add(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_add(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_add(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_add(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_add(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_add(int *dst, int *src1, const int *src2, unsigned int size)   void __bang_atomic_add(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_add(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_add(float *dst, float *src1, const float *src2, unsigned int size)   Copies <src1> to <dst>, adds <src2> to <src1> element-wisely. That is: <dst> = <src1>; <src1> = <src1> + <src2>. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* The address of <src1> must be sizeof(type) aligned;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector;\n* <size> must be greater than zero;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example\n```",
    "atomic_add_async": "void __bang_atomic_add_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_add_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_add_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_add_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_add_async(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_add_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_add_async(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_add_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_add_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_add_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_add_async(int *dst, int *src1, const int *src2, unsigned int size)   void __bang_atomic_add_async(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_add_async(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_add_async(float *dst, float *src1, const float *src2, unsigned int size)   Copies <src1> to <dst>, adds <src2> to <src1> element-wisely. That is: <dst> = <src1>; <src1> = <src1> + <src2>. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* The address of <src1> must be sizeof(type) aligned;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector;\n* <size> must be greater than zero;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example\n```",
    "atomic_and": "void __bang_atomic_and(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_and(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_and(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_and(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_and(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_and(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_and(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_and(int *dst, int *src1, const int *src2, unsigned int size)   Applies bitwise AND operation to the vector <src1> and <src2>, stores the result in <src1>, and stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = <src1> & <src2>. All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_and_async": "void __bang_atomic_and_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_and_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_and_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_and_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_and_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_and_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_and_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_and_async(int *dst, int *src1, const int *src2, unsigned int size)   Applies bitwise AND operation to the vector <src1> and <src2>, stores the result in <src1>, and stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = <src1> & <src2>. All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_dec": "void __bang_atomic_dec(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_dec(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_dec(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_dec(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_dec(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_dec(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_dec(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_dec(int *dst, int *src1, const int *src2, unsigned int size)   Compares vector <src1> and <src2> element-wisely. If <src1> is larger than <src2>, or the value of <src1> is 0, stores the int value <src2> in <src1>; otherwise, subtracts <src1> by 1. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> == 0 || <src1> > <src2>) ? <src2> : (<src1> - 1). All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* <size> must be greater than zero;\n* The address of <src1> must be sizeof(type) aligned;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_dec_async": "void __bang_atomic_dec_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_dec_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_dec_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_dec_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_dec_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_dec_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_dec_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_dec_async(int *dst, int *src1, const int *src2, unsigned int size)   Compares vector <src1> and <src2> element-wisely. If <src1> is larger than <src2>, or the value of <src1> is 0, stores the int value <src2> in <src1>; otherwise, subtracts <src1> by 1. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> == 0 || <src1> > <src2>) ? <src2> : (<src1> - 1). All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* <size> must be greater than zero;\n* The address of <src1> must be sizeof(type) aligned;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_exch": "void __bang_atomic_exch(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_exch(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_exch(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_exch(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_exch(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_exch(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_exch(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_exch(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_exch(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_exch(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_exch(int *dst, int *src1, const int *src2, unsigned int size)   void __bang_atomic_exch(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_exch(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_exch(float *dst, float *src1, const float *src2, unsigned int size)   Stores vector <src1> in <dst>. Stores <src2> in <src1>. That is: <dst> = <src1>; <src1> = <src2>. All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <size> must be greater than zero;\n* The address of <src1> must be sizeof(type) aligned;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_exch_async": "void __bang_atomic_exch_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_exch_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_exch_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_exch_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_exch_async(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_exch_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_exch_async(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_exch_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_exch_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_exch_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_exch_async(int *dst, int *src1, const int *src2, unsigned int size)   void __bang_atomic_exch_async(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_exch_async(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_exch_async(float *dst, float *src1, const float *src2, unsigned int size)   Stores vector <src1> in <dst>. Stores <src2> in <src1>. That is: <dst> = <src1>; <src1> = <src2>. All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <size> must be greater than zero;\n* The address of <src1> must be sizeof(type) aligned;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_inc": "void __bang_atomic_inc(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_inc(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_inc(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_inc(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_inc(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_inc(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_inc(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_inc(int *dst, int *src1, const int *src2, unsigned int size)   Compares vector <src1> and <src2> element-wisely. If <src1> is smaller than <src2>, increases <src1> by 1; otherwise, sets <src1> to 0. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> >= <src2>) ? 0 : (<src1> + 1). All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_inc_async": "void __bang_atomic_inc_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_inc_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_inc_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_inc_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_inc_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_inc_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_inc_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_inc_async(int *dst, int *src1, const int *src2, unsigned int size)   Compares vector <src1> and <src2> element-wisely. If <src1> is smaller than <src2>, increases <src1> by 1; otherwise, sets <src1> to 0. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> >= <src2>) ? 0 : (<src1> + 1). All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_max": "void __bang_atomic_max(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_max(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_max(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_max(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_max(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_max(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_max(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_max(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_max(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_max(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_max(int *dst, int *src1, const int *src2, unsigned int size)   void __bang_atomic_max(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_max(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_max(float *dst, float *src1, const float *src2, unsigned int size)   element-wisely stores the larger value of vector <src1> and <src2> in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> > <src2>) ? <src1> : <src2>. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_max_async": "void __bang_atomic_max_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_max_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_max_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_max_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_max_async(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_max_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_max_async(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_max_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_max_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_max_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_max_async(int *dst, int *src1, const int *src2, unsigned int size)   void __bang_atomic_max_async(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_max_async(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_max_async(float *dst, float *src1, const float *src2, unsigned int size)   element-wisely stores the larger value of vector <src1> and <src2> in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> > <src2>) ? <src1> : <src2>. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_min": "void __bang_atomic_min(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_min(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_min(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_min(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_min(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_min(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_min(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_min(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_min(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_min(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_min(int *dst, int *src1, const int *src2, unsigned int size)   void __bang_atomic_min(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_min(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_min(float *dst, float *src1, const float *src2, unsigned int size)   Takes the smaller value from two vector values <src1> and <src2>, and stores it in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> < <src2>) ? <src1> : <src2>. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_min_async": "void __bang_atomic_min_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_min_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_min_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_min_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_min_async(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_min_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_min_async(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_min_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_min_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_min_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_min_async(int *dst, int *src1, const int *src2, unsigned int size)   void __bang_atomic_min_async(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_min_async(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_min_async(float *dst, float *src1, const float *src2, unsigned int size)   Takes the smaller value from two vector values <src1> and <src2>, and stores it in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> < <src2>) ? <src1> : <src2>. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_nan_max": "void __bang_atomic_nan_max(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_nan_max(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_nan_max(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_nan_max(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_nan_max(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_nan_max(float *dst, float *src1, const float *src2, unsigned int size)   element-wisely stores the larger value of vector <src1> and <src2> in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> > <src2>) ? <src1> : <src2>. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_nan_max_async": "void __bang_atomic_nan_max_async(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_nan_max_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_nan_max_async(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_nan_max_async(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_nan_max_async(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_nan_max_async(float *dst, float *src1, const float *src2, unsigned int size)   element-wisely stores the larger value of vector <src1> and <src2> in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> > <src2>) ? <src1> : <src2>. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_nan_min": "void __bang_atomic_nan_min(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_nan_min(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_nan_min(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_nan_min(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_nan_min(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_nan_min(float *dst, float *src1, const float *src2, unsigned int size)   Takes the smaller value from two vector values <src1> and <src2>, and stores it in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> < <src2>) ? <src1> : <src2>. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_nan_min_async": "void __bang_atomic_nan_min_async(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_nan_min_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_nan_min_async(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_nan_min_async(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_nan_min_async(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_nan_min_async(float *dst, float *src1, const float *src2, unsigned int size)   Takes the smaller value from two vector values <src1> and <src2>, and stores it in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> < <src2>) ? <src1> : <src2>. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_number_max": "void __bang_atomic_number_max(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_number_max(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_number_max(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_number_max(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_number_max(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_number_max(float *dst, float *src1, const float *src2, unsigned int size)   element-wisely stores the larger value of vector <src1> and <src2> in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> > <src2>) ? <src1> : <src2>. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_number_max_async": "void __bang_atomic_number_max_async(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_number_max_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_number_max_async(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_number_max_async(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_number_max_async(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_number_max_async(float *dst, float *src1, const float *src2, unsigned int size)   element-wisely stores the larger value of vector <src1> and <src2> in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> > <src2>) ? <src1> : <src2>. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_number_min": "void __bang_atomic_number_min(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_number_min(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_number_min(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_number_min(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_number_min(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_number_min(float *dst, float *src1, const float *src2, unsigned int size)   Takes the smaller value from two vector values <src1> and <src2>, and stores it in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> < <src2>) ? <src1> : <src2>. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_number_min_async": "void __bang_atomic_number_min_async(half *dst, half *src1, half src2, unsigned int size = 1)   void __bang_atomic_number_min_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, unsigned int size = 1)   void __bang_atomic_number_min_async(float *dst, float *src1, float src2, unsigned int size = 1)   void __bang_atomic_number_min_async(half *dst, half *src1, const half *src2, unsigned int size)   void __bang_atomic_number_min_async(bfloat16_t *dst, bfloat16_t *src1, const bfloat16_t *src2, unsigned int size)   void __bang_atomic_number_min_async(float *dst, float *src1, const float *src2, unsigned int size)   Takes the smaller value from two vector values <src1> and <src2>, and stores it in <src1>. Stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = (<src1> < <src2>) ? <src1> : <src2>. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <size> must be greater than zero;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_or": "void __bang_atomic_or(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_or(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_or(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_or(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_or(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_or(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_or(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_or(int *dst, int *src1, const int *src2, unsigned int size)   Applies bitwise OR operation to vector <src1> and <src2>, stores the result in <src1>, and stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = <src1> | <src2>. All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_or_async": "void __bang_atomic_or_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_or_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_or_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_or_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_or_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_or_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_or_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_or_async(int *dst, int *src1, const int *src2, unsigned int size)   Applies bitwise OR operation to vector <src1> and <src2>, stores the result in <src1>, and stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = <src1> | <src2>. All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_xor": "void __bang_atomic_xor(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_xor(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_xor(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_xor(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_xor(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_xor(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_xor(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_xor(int *dst, int *src1, const int *src2, unsigned int size)   Applies bitwise XOR operation to vector <src1> and <src2>, stores the result in <src1>, and stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = <src1> ^ <src2>. All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_xor_async": "void __bang_atomic_xor_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned int size = 1)   void __bang_atomic_xor_async(short *dst, short *src1, short src2, unsigned int size = 1)   void __bang_atomic_xor_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int size = 1)   void __bang_atomic_xor_async(int *dst, int *src1, int src2, unsigned int size = 1)   void __bang_atomic_xor_async(unsigned short *dst, unsigned short *src1, const unsigned short *src2, unsigned int size)   void __bang_atomic_xor_async(short *dst, short *src1, const short *src2, unsigned int size)   void __bang_atomic_xor_async(unsigned int *dst, unsigned int *src1, const unsigned int *src2, unsigned int size)   void __bang_atomic_xor_async(int *dst, int *src1, const int *src2, unsigned int size)   Applies bitwise XOR operation to vector <src1> and <src2>, stores the result in <src1>, and stores the original value of <src1> in <dst>. That is: <dst> = <src1>; <src1> = <src1> ^ <src2>. All steps are inseparable. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The address of first source vector.\n* [in] src2: The second source scalar or the address of second source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src2> must point to \\_\\_nram\\_\\_ address space if <src2> is a vector;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* <dst> can be overlapped with <src2> if <src2> is a vector;\n* The address of <src1> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example* None.",
    "atomic_nan_reduce_max": "void __bang_atomic_nan_reduce_max(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_max(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_max(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_max(half *dst, const half *src1, unsigned int size)   void __bang_atomic_nan_reduce_max(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_nan_reduce_max(float *dst, const float *src1, unsigned int size)   Takes the larger value from vector <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> > <src1>) ? <dst> : <src1>. If one of the elements being compared is a NaN, then NaN is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_nan_reduce_max_async": "void __bang_atomic_nan_reduce_max_async(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_max_async(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_max_async(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_max_async(half *dst, const half *src1, unsigned int size)   void __bang_atomic_nan_reduce_max_async(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_nan_reduce_max_async(float *dst, const float *src1, unsigned int size)   Takes the larger value from vector <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> > <src1>) ? <dst> : <src1>. If one of the elements being compared is a NaN, then NaN is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_nan_reduce_min": "void __bang_atomic_nan_reduce_min(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_min(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_min(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_min(half *dst, const half *src1, unsigned int size)   void __bang_atomic_nan_reduce_min(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_nan_reduce_min(float *dst, const float *src1, unsigned int size)   Takes the smaller value from two vector values <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> < <src1>) ? <dst> : <src1>. If one of the elements being compared is a NaN, then NaN is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_nan_reduce_min_async": "void __bang_atomic_nan_reduce_min_async(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_min_async(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_min_async(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_nan_reduce_min_async(half *dst, const half *src1, unsigned int size)   void __bang_atomic_nan_reduce_min_async(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_nan_reduce_min_async(float *dst, const float *src1, unsigned int size)   Takes the smaller value from two vector values <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> < <src1>) ? <dst> : <src1>. If one of the elements being compared is a NaN, then NaN is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_number_reduce_max": "void __bang_atomic_number_reduce_max(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_number_reduce_max(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_number_reduce_max(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_number_reduce_max(half *dst, const half *src1, unsigned int size)   void __bang_atomic_number_reduce_max(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_number_reduce_max(float *dst, const float *src1, unsigned int size)   Takes the larger value from vector <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> > <src1>) ? <dst> : <src1>. If one of the elements being compared is a NaN, then the non-NaN element is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_number_reduce_max_async": "void __bang_atomic_number_reduce_max_async(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_number_reduce_max_async(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_number_reduce_max_async(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_number_reduce_max_async(half *dst, const half *src1, unsigned int size)   void __bang_atomic_number_reduce_max_async(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_number_reduce_max_async(float *dst, const float *src1, unsigned int size)   Takes the larger value from vector <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> > <src1>) ? <dst> : <src1>. If one of the elements being compared is a NaN, then the non-NaN element is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_number_reduce_min": "void __bang_atomic_number_reduce_min(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_number_reduce_min(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_number_reduce_min(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_number_reduce_min(half *dst, const half *src1, unsigned int size)   void __bang_atomic_number_reduce_min(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_number_reduce_min(float *dst, const float *src1, unsigned int size)   Takes the smaller value from two vector values <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> < <src1>) ? <dst> : <src1>. If one of the elements being compared is a NaN, then the non-NaN element is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_number_reduce_min_async": "void __bang_atomic_number_reduce_min_async(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_number_reduce_min_async(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_number_reduce_min_async(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_number_reduce_min_async(half *dst, const half *src1, unsigned int size)   void __bang_atomic_number_reduce_min_async(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_number_reduce_min_async(float *dst, const float *src1, unsigned int size)   Takes the smaller value from two vector values <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> < <src1>) ? <dst> : <src1>. If one of the elements being compared is a NaN, then the non-NaN element is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_add": "void __bang_atomic_reduce_add(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_add(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_add(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_reduce_add(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_reduce_add(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_reduce_add(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_add(int *dst, const int *src1, unsigned int size)   void __bang_atomic_reduce_add(half *dst, const half *src1, unsigned int size)   void __bang_atomic_reduce_add(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_reduce_add(float *dst, const float *src1, unsigned int size)   Increases <dst> by <src1> element-wisely. That is: <dst> = <dst> + <src1>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example\n```",
    "atomic_reduce_add_async": "void __bang_atomic_reduce_add_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_add_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_add_async(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_reduce_add_async(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_reduce_add_async(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_reduce_add_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_add_async(int *dst, const int *src1, unsigned int size)   void __bang_atomic_reduce_add_async(half *dst, const half *src1, unsigned int size)   void __bang_atomic_reduce_add_async(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_reduce_add_async(float *dst, const float *src1, unsigned int size)   Increases <dst> by <src1> element-wisely. That is: <dst> = <dst> + <src1>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example\n```",
    "atomic_reduce_and": "void __bang_atomic_reduce_and(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_and(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_and(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_and(int *dst, const int *src1, unsigned int size)   Applies bitwise AND operation to the vector <dst> and <src1>, and stores the result in <dst>. That is: <dst> = <dst> & <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_and_async": "void __bang_atomic_reduce_and_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_and_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_and_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_and_async(int *dst, const int *src1, unsigned int size)   Applies bitwise AND operation to the vector <dst> and <src1>, and stores the result in <dst>. That is: <dst> = <dst> & <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_dec": "void __bang_atomic_reduce_dec(unsigned short *dst, unsigned short src1, unsigned int size = 1)   void __bang_atomic_reduce_dec(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_dec(unsigned int *dst, unsigned int src1, unsigned int size = 1)   void __bang_atomic_reduce_dec(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_dec(unsigned short *dst, const unsigned short *src1, unsigned int size)   void __bang_atomic_reduce_dec(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_dec(unsigned int *dst, const unsigned int *src1, unsigned int size)   void __bang_atomic_reduce_dec(int *dst, const int *src1, unsigned int size)   Compares vector <dst> and <src1>. If <dst> is larger than <src1>, or the value of <dst> is 0, stores the int value <src1> in <dst>; otherwise, reduces <dst> by 1. That is: <dst> = (<dst> == 0 || <dst> > <src1>) ? <src1> : (<dst> - 1). Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_dec_async": "void __bang_atomic_reduce_dec_async(unsigned short *dst, unsigned short src1, unsigned int size = 1)   void __bang_atomic_reduce_dec_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_dec_async(unsigned int *dst, unsigned int src1, unsigned int size = 1)   void __bang_atomic_reduce_dec_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_dec_async(unsigned short *dst, const unsigned short *src1, unsigned int size)   void __bang_atomic_reduce_dec_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_dec_async(unsigned int *dst, const unsigned int *src1, unsigned int size)   void __bang_atomic_reduce_dec_async(int *dst, const int *src1, unsigned int size)   Compares vector <dst> and <src1>. If <dst> is larger than <src1>, or the value of <dst> is 0, stores the int value <src1> in <dst>; otherwise, reduces <dst> by 1. That is: <dst> = (<dst> == 0 || <dst> > <src1>) ? <src1> : (<dst> - 1). Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_exch": "void __bang_atomic_reduce_exch(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_exch(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_exch(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_reduce_exch(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_reduce_exch(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_reduce_exch(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_exch(int *dst, const int *src1, unsigned int size)   void __bang_atomic_reduce_exch(half *dst, const half *src1, unsigned int size)   void __bang_atomic_reduce_exch(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_reduce_exch(float *dst, const float *src1, unsigned int size)   Stores <src1> in <dst>. That is: <dst> = <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_exch_async": "void __bang_atomic_reduce_exch_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_exch_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_exch_async(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_reduce_exch_async(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_reduce_exch_async(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_reduce_exch_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_exch_async(int *dst, const int *src1, unsigned int size)   void __bang_atomic_reduce_exch_async(half *dst, const half *src1, unsigned int size)   void __bang_atomic_reduce_exch_async(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_reduce_exch_async(float *dst, const float *src1, unsigned int size)   Stores <src1> in <dst>. That is: <dst> = <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_inc": "void __bang_atomic_reduce_inc(unsigned short *dst, unsigned short src1, unsigned int size = 1)   void __bang_atomic_reduce_inc(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_inc(unsigned int *dst, unsigned int src1, unsigned int size = 1)   void __bang_atomic_reduce_inc(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_inc(unsigned short *dst, const unsigned short *src1, unsigned int size)   void __bang_atomic_reduce_inc(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_inc(unsigned int *dst, const unsigned int *src1, unsigned int size)   void __bang_atomic_reduce_inc(int *dst, const int *src1, unsigned int size)   Compares vector <dst> and <src1>. If <dst> is smaller than <src1>, increases <dst> by 1; otherwise, sets <dst> to 0. That is: <dst> = (<dst> >= <src1>) ? 0 : (<dst> + 1). Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_inc_async": "void __bang_atomic_reduce_inc_async(unsigned short *dst, unsigned short src1, unsigned int size = 1)   void __bang_atomic_reduce_inc_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_inc_async(unsigned int *dst, unsigned int src1, unsigned int size = 1)   void __bang_atomic_reduce_inc_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_inc_async(unsigned short *dst, const unsigned short *src1, unsigned int size)   void __bang_atomic_reduce_inc_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_inc_async(unsigned int *dst, const unsigned int *src1, unsigned int size)   void __bang_atomic_reduce_inc_async(int *dst, const int *src1, unsigned int size)   Compares vector <dst> and <src1>. If <dst> is smaller than <src1>, increases <dst> by 1; otherwise, sets <dst> to 0. That is: <dst> = (<dst> >= <src1>) ? 0 : (<dst> + 1). Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_max": "void __bang_atomic_reduce_max(unsigned short *dst, unsigned short src1, unsigned int size = 1)   void __bang_atomic_reduce_max(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_max(unsigned int *dst, unsigned int src1, unsigned int size = 1)   void __bang_atomic_reduce_max(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_max(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_reduce_max(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_reduce_max(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_reduce_max(unsigned short *dst, const unsigned short *src1, unsigned int size)   void __bang_atomic_reduce_max(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_max(unsigned int *dst, const unsigned int *src1, unsigned int size)   void __bang_atomic_reduce_max(int *dst, const int *src1, unsigned int size)   void __bang_atomic_reduce_max(half *dst, const half *src1, unsigned int size)   void __bang_atomic_reduce_max(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_reduce_max(float *dst, const float *src1, unsigned int size)   Takes the larger value from vector <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> > <src1>) ? <dst> : <src1>. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_max_async": "void __bang_atomic_reduce_max_async(unsigned short *dst, unsigned short src1, unsigned int size = 1)   void __bang_atomic_reduce_max_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_max_async(unsigned int *dst, unsigned int src1, unsigned int size = 1)   void __bang_atomic_reduce_max_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_max_async(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_reduce_max_async(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_reduce_max_async(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_reduce_max_async(unsigned short *dst, const unsigned short *src1, unsigned int size)   void __bang_atomic_reduce_max_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_max_async(unsigned int *dst, const unsigned int *src1, unsigned int size)   void __bang_atomic_reduce_max_async(int *dst, const int *src1, unsigned int size)   void __bang_atomic_reduce_max_async(half *dst, const half *src1, unsigned int size)   void __bang_atomic_reduce_max_async(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_reduce_max_async(float *dst, const float *src1, unsigned int size)   Takes the larger value from vector <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> > <src1>) ? <dst> : <src1>. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_min": "void __bang_atomic_reduce_min(unsigned short *dst, unsigned short src1, unsigned int size = 1)   void __bang_atomic_reduce_min(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_min(unsigned int *dst, unsigned int src1, unsigned int size = 1)   void __bang_atomic_reduce_min(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_min(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_reduce_min(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_reduce_min(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_reduce_min(unsigned short *dst, const unsigned short *src1, unsigned int size)   void __bang_atomic_reduce_min(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_min(unsigned int *dst, const unsigned int *src1, unsigned int size)   void __bang_atomic_reduce_min(int *dst, const int *src1, unsigned int size)   void __bang_atomic_reduce_min(half *dst, const half *src1, unsigned int size)   void __bang_atomic_reduce_min(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_reduce_min(float *dst, const float *src1, unsigned int size)   Takes the smaller value from two vector values <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> < <src1>) ? <dst> : <src1>. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_min_async": "void __bang_atomic_reduce_min_async(unsigned short *dst, unsigned short src1, unsigned int size = 1)   void __bang_atomic_reduce_min_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_min_async(unsigned int *dst, unsigned int src1, unsigned int size = 1)   void __bang_atomic_reduce_min_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_min_async(half *dst, half src1, unsigned int size = 1)   void __bang_atomic_reduce_min_async(bfloat16_t *dst, bfloat16_t src1, unsigned int size = 1)   void __bang_atomic_reduce_min_async(float *dst, float src1, unsigned int size = 1)   void __bang_atomic_reduce_min_async(unsigned short *dst, const unsigned short *src1, unsigned int size)   void __bang_atomic_reduce_min_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_min_async(unsigned int *dst, const unsigned int *src1, unsigned int size)   void __bang_atomic_reduce_min_async(int *dst, const int *src1, unsigned int size)   void __bang_atomic_reduce_min_async(half *dst, const half *src1, unsigned int size)   void __bang_atomic_reduce_min_async(bfloat16_t *dst, const bfloat16_t *src1, unsigned int size)   void __bang_atomic_reduce_min_async(float *dst, const float *src1, unsigned int size)   Takes the smaller value from two vector values <dst> and <src1>, and stores it in <dst>. That is: <dst> = (<dst> < <src1>) ? <dst> : <src1>. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1> must be sizeof(type) aligned;\n* <size> must be greater than zero;\n* bfloat16\\_t is supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_or": "void __bang_atomic_reduce_or(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_or(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_or(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_or(int *dst, const int *src1, unsigned int size)   Applies bitwise OR operation to vector <dst> and <src1>, and stores the result in <dst>. That is: <dst> = <dst> | <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_or_async": "void __bang_atomic_reduce_or_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_or_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_or_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_or_async(int *dst, const int *src1, unsigned int size)   Applies bitwise OR operation to vector <dst> and <src1>, and stores the result in <dst>. That is: <dst> = <dst> | <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_xor": "void __bang_atomic_reduce_xor(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_xor(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_xor(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_xor(int *dst, const int *src1, unsigned int size)   Applies bitwise XOR operation to vector <dst> and <src1>, and stores the result in <dst>. That is: <dst> = <dst> ^ <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "atomic_reduce_xor_async": "void __bang_atomic_reduce_xor_async(short *dst, short src1, unsigned int size = 1)   void __bang_atomic_reduce_xor_async(int *dst, int src1, unsigned int size = 1)   void __bang_atomic_reduce_xor_async(short *dst, const short *src1, unsigned int size)   void __bang_atomic_reduce_xor_async(int *dst, const int *src1, unsigned int size)   Applies bitwise XOR operation to vector <dst> and <src1>, and stores the result in <dst>. That is: <dst> = <dst> ^ <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src1: The first source scalar or the address of first source vector.\n* [in] size: The elements number of source vector. Return* void. Remark* <src1> must point to \\_\\_nram\\_\\_ address space if <src1> is a vector;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <size> must be greater than zero;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example* None.",
    "bexpand": "void __bang_bexpand(char *dst, const void *src, unsigned int dst_dim_n, unsigned int dst_dim_h, unsigned int dst_dim_w, unsigned int dst_dim_c)   void __bang_bexpand(short *dst, const void *src, unsigned int dst_dim_n, unsigned int dst_dim_h, unsigned int dst_dim_w, unsigned int dst_dim_c)   void __bang_bexpand(int *dst, const void *src, unsigned int dst_dim_n, unsigned int dst_dim_h, unsigned int dst_dim_w, unsigned int dst_dim_c)   This function converts each binary bit in <src> to value of specified data type and saves the result in <dst> . The bit 1 and 0 will be converted to value 1 and 0 of corresponding data type. For example, if the data type of <dst> is char and <src> is 0b11001101 , the <dst> will be 0b 00000001 00000001 00000000 00000000 00000001 00000001 00000000 00000001 . Parameters* [out] dst: The address of destination tensor.\n* [in] src: The address of source binary vector.\n* [in] dst\\_dim\\_n: The dimension N of destination tensor.\n* [in] dst\\_dim\\_h: The dimension H of destination tensor.\n* [in] dst\\_dim\\_w: The dimension W of destination tensor.\n* [in] dst\\_dim\\_c: The dimension C of destination tensor. Return* void. * Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <dst\\_dim\\_c> must be divisible by 8;\n* <dst\\_dim\\_n>, <dst\\_dim\\_h>, <dst\\_dim\\_w> and <dst\\_dim\\_c> must be greater than 0 and less than 65536. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592 . Example\n```",
    "breduce": "void __bang_breduce(void *dst, const char *src, unsigned int src_dim_n, unsigned int src_dim_h, unsigned int src_dim_w, unsigned int src_dim_c)   void __bang_breduce(void *dst, const short *src, unsigned int src_dim_n, unsigned int src_dim_h, unsigned int src_dim_w, unsigned int src_dim_c)   void __bang_breduce(char *dst, const int *src, unsigned int src_dim_n, unsigned int src_dim_h, unsigned int src_dim_w, unsigned int src_dim_c)   This function converts each value in <src> to binary bit and saves the result in <dst> . Value 0 will be converted to bit 0 and other value will be converted to bit 1. For example, if the data type of <src> is char and <src> is 0b 00000001 10000001 00000000 00000000 11111111 01000000 00000000 11000000 , the <dst> will be 0b11001101 . Parameters* [out] dst: The address of destination binary vector.\n* [in] src: The address of source tensor.\n* [in] src\\_dim\\_n: The dimension N of source tensor.\n* [in] src\\_dim\\_h: The dimension H of source tensor.\n* [in] src\\_dim\\_w: The dimension W of source tensor.\n* [in] src\\_dim\\_c: The dimension C of source tensor. Return* void. * Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <src\\_dim\\_c> must be divisible by 8;\n* <src\\_dim\\_n>, <src\\_dim\\_h>, <src\\_dim\\_w> and <src\\_dim\\_c> must be greater than zero and less than 65536. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592 . Example\n```",
    "conv": "void __bang_conv(int16_t *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(int16_t *dst, const int16_t *src, const int8_t *kernel, const int16_t *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(int16_t *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(int16_t *dst, const int16_t *src, const int16_t *kernel, const int16_t *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int16_t *src, const int16_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(int16_t *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(int16_t *dst, const int8_t *src, const int8_t *kernel, const int16_t *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int16_t *src, const int8_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int16_t *src, const int8_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int8_t *src, const int8_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int16_t *src, const int16_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(int16_t *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(int16_t *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(int16_t *dst, const int16_t *src, const int16_t *kernel, const int16_t *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int8_t *src, const int8_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int8_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int8_t *src, const int16_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int8_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int8_t *src, const int16_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int8_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int8_t *src, const int16_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int8_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int dilation_width, unsigned int dilation_height)   void __bang_conv(float *dst, const int8_t *src, const int16_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int dilation_width, unsigned int dilation_height)   void __bang_conv(half *dst, const int8_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int out_dilation_width, unsigned int out_dilation_height)   void __bang_conv(float *dst, const int8_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int dilation_width, unsigned int dilation_height, unsigned int out_dilation_width, unsigned int out_dilation_height)   void __bang_conv(int16_t *dst, const int8_t *src, const int8_t *kernel, const int16_t *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(int16_t *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(int16_t *dst, const int16_t *src, const int8_t *kernel, const int16_t *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int16_t *src, const int8_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int16_t *src, const int16_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int16_t *src, const int8_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int8_t *src, const int8_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int8_t *src, const int8_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int16_t *src, const int16_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const float *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv(float *dst, const half *src, const half *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv(float *dst, const float *src, const half *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv(float *dst, const half *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv(float *dst, const bfloat16_t *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv(float *dst, const float *src, const bfloat16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv(float *dst, const bfloat16_t *src, const bfloat16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv(float *dst, const float *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const half *src, const half *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const half *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const float *src, const half *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const float *src, const bfloat16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const bfloat16_t *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int4x2_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int4x2_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int4x2_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int4x2_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int4x2_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int8_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int8_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int16_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int16_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int4x2_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int8_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int8_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int16_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int16_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, int fix_position, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(half *dst, const int8_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const int8_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(half *dst, const int16_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(float *dst, const int16_t *src, const int4x2_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int4x2_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int4x2_t *src, const int4x2_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int4x2_t *src, const int8_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int4x2_t *src, const int8_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int4x2_t *src, const int16_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int4x2_t *src, const int16_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int8_t *src, const int4x2_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int8_t *src, const int4x2_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int16_t *src, const int4x2_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(float *dst, const int16_t *src, const int4x2_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv(half *dst, const int4x2_t *src, const int4x2_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int4x2_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int8_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int8_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int4x2_t *src, const int16_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int4x2_t *src, const int16_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int8_t *src, const int4x2_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int8_t *src, const int4x2_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(half *dst, const int16_t *src, const int4x2_t *kernel, const half *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const int16_t *src, const int4x2_t *kernel, const float *bias, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv(float *dst, const bfloat16_t *src, const bfloat16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   In \\_\\_nram\\_\\_ address space, uses the four-dimensional convolution kernel <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>] to perform a convolution operation on the three-dimensional tensor <src>[<height>, <width>, <channel\\_input>] with an interactive step size of [<stride\\_width>, <stride\\_height>], and stores the result in the three-dimensional tensor <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>]. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination tensor which has (NH_oW_oC_o) data layout.\n* [in] src: The address of source tensor which has (NH_iW_iC_i) data layout.\n* [in] kernel: The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n* [in] bias: The address of bias tensor which has ([C_o]) shape.\n* [in] channel\\_input: Number of input channels.\n* [in] height: The height of source tensor.\n* [in] width: The width of source tensor.\n* [in] kernel\\_height: The height of filter tensor.\n* [in] kernel\\_width: The width of filter tensor.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] channel\\_output: Number of output channels.\n* [in] fix\\_position: Sum of the scale factor of <src> and <kernel>.\n* [in] indilation\\_width: Input dilation in W direction.\n* [in] indilation\\_height: Input dilation in H direction.\n* [in] outdilation\\_width: Output dilation in W direction.\n* [in] outdilation\\_height: Output dilation in H direction. Return* void. Remark* <src>, <dst> and <bias> must point to \\_\\_nram\\_\\_ address space;\n* <kernel> must point to \\_\\_wram\\_\\_ address space;\n* <fix\\_position> is the sum of the scale factor of <src> and <kernel>;\n* <fix\\_position> must be in the range [-127, 127];\n* The address of <dst>, <src> and <bias> must be 64-byte aligned on (m)tp\\_2xx;\n* The address of <kernel> must be 32-byte aligned;\n* <channel\\_input> \\* sizeof(typeof<src>) must be 64-byte aligned on (m)tp\\_2xx;\n* <channel\\_output> must be divisible by 64 on (m)tp\\_2xx;\n* <channel\\_output> \\* sizeof(typeof<dst>) must be 64-byte aligned on (m)tp\\_2xx;\n* The byte size of <kernel> must be 64-byte aligned; otherwise, the non-aligned part of <kernel> will be random numbers on mtp\\_372 and tp\\_322, and zero on other architecture; On (m)tp\\_3xx and higher, there is no alignment constraint for parameter <channel\\_input>, but when allocating memory, the ci dimension of the memory space of <kernel> must satisfy the following alignment constraints: If the types of <src> and <kernel> are both floating point: Otherwise, (C_i) * sizeof(typeof<kernel>) must be 64-byte aligned; If --wram-align 64 or #pragma bang walign(64), see the table Conv w64 Alignment for more information about alignment constraints; On (m)tp\\_3xx and higher, there is no alignment constraint for parameter <channel\\_output>, but when allocating memory, the co dimension of memory space of <kernel> must be 64 aligned; Compatibility between Various Architectures Table 3.15 Conv Data Types Supported on (m)tp\\_2xx | Src Type | Kernel Type | Dst Type | Bias Type |\n| --- | --- | --- | --- |\n| int4 | int4 | half | none |\n| int4 | int4 | float | none |\n| int8_t | int4 | half | none |\n| int8_t | int4 | float | none |\n| int8_t | int8_t | half | none |\n| int8_t | int8_t | float | none |\n| int8_t | int8_t | int16_t | none |\n| int16_t | int4 | half | none |\n| int16_t | int4 | float | none |\n| int16_t | int8_t | half | none |\n| int16_t | int8_t | float | none |\n| int16_t | int8_t | int16_t | none |\n| int16_t | int16_t | half | none |\n| int16_t | int16_t | float | none |\n| int16_t | int16_t | int16_t | none |\n| int4 | int4 | half | half |\n| int4 | int4 | float | float |\n| int8_t | int4 | half | half |\n| int8_t | int4 | float | float |\n| int8_t | int8_t | half | half |\n| int8_t | int8_t | float | float |\n| int8_t | int8_t | int16_t | int16_t |\n| int16_t | int4 | half | half |\n| int16_t | int4 | float | float |\n| int16_t | int8_t | half | half |\n| int16_t | int8_t | float | float |\n| int16_t | int8_t | int16_t | int16_t |\n| int16_t | int16_t | half | half |\n| int16_t | int16_t | float | float |\n| int16_t | int16_t | int16_t | int16_t | Table 3.16 Conv Data Types Supported on mtp\\_372 | Src Type | Kernel Type | Dst Type | Bias Type |\n| --- | --- | --- | --- |\n| int8_t | int16_t | half | none |\n| int8_t | int16_t | float | none |\n| int8_t | int8_t | half | none |\n| int8_t | int8_t | float | none |\n| int8_t | int8_t | int16_t | none |\n| int16_t | int8_t | half | none |\n| int16_t | int8_t | float | none |\n| int16_t | int8_t | int16_t | none |\n| int16_t | int16_t | half | none |\n| int16_t | int16_t | float | none |\n| int16_t | int16_t | int16_t | none |\n| int8_t | int16_t | half | half |\n| int8_t | int16_t | float | float |\n| int8_t | int8_t | half | half |\n| int8_t | int8_t | float | float |\n| int8_t | int8_t | int16_t | int16_t |\n| int16_t | int8_t | half | half |\n| int16_t | int8_t | float | float |\n| int16_t | int8_t | int16_t | int16_t |\n| int16_t | int16_t | half | half |\n| int16_t | int16_t | float | float |\n| int16_t | int16_t | int16_t | int16_t |\n| float | float | float | none |\n| half | half | float | none |\n| float | half | float | none |\n| half | float | float | none |\n| bfloat16_t | bfloat16_t | float | none |\n| float | bfloat16_t | float | none |\n| bfloat16_t | float | float | none |\n| int4 | int4 | float | none |\n| int4 | int8_t | float | none |\n| int4 | int16_t | float | none |\n| int8_t | int4 | float | none |\n| int16_t | int4 | float | none |\n| int4 | int4 | half | none |\n| int4 | int8_t | half | none |\n| int4 | int16_t | half | none |\n| int8_t | int4 | half | none |\n| int16_t | int4 | half | none |\n| int4 | int4 | float | float |\n| int4 | int8_t | float | float |\n| int4 | int16_t | float | float |\n| int8_t | int4 | float | float |\n| int16_t | int4 | float | float |\n| int4 | int4 | half | half |\n| int4 | int8_t | half | half |\n| int4 | int16_t | half | half |\n| int8_t | int4 | half | half |\n| int16_t | int4 | half | half | Table 3.17 Conv Data Types Supported on mtp\\_592 | Src Type | Kernel Type | Dst Type | Bias Type |\n| --- | --- | --- | --- |\n| int8_t | int16_t | half | none |\n| int8_t | int16_t | float | none |\n| int8_t | int8_t | half | none |\n| int8_t | int8_t | float | none |\n| int8_t | int8_t | int16_t | none |\n| int16_t | int8_t | half | none |\n| int16_t | int8_t | float | none |\n| int16_t | int8_t | int16_t | none |\n| int16_t | int16_t | half | none |\n| int16_t | int16_t | float | none |\n| int16_t | int16_t | int16_t | none |\n| int8_t | int16_t | half | half |\n| int8_t | int16_t | float | float |\n| int8_t | int8_t | half | half |\n| int8_t | int8_t | float | float |\n| int8_t | int8_t | int16_t | int16_t |\n| int16_t | int8_t | half | half |\n| int16_t | int8_t | float | float |\n| int16_t | int8_t | int16_t | int16_t |\n| int16_t | int16_t | half | half |\n| int16_t | int16_t | float | float |\n| int16_t | int16_t | int16_t | int16_t |\n| float | float | float | none |\n| half | half | float | none |\n| bfloat16_t | bfloat16_t | float | none |\n| int4 | int4 | float | none |\n| int4 | int8_t | float | none |\n| int4 | int16_t | float | none |\n| int8_t | int4 | float | none |\n| int16_t | int4 | float | none |\n| int4 | int4 | half | none |\n| int4 | int8_t | half | none |\n| int4 | int16_t | half | none |\n| int8_t | int4 | half | none |\n| int16_t | int4 | half | none |\n| int4 | int4 | float | float |\n| int4 | int8_t | float | float |\n| int4 | int16_t | float | float |\n| int8_t | int4 | float | float |\n| int16_t | int4 | float | float |\n| int4 | int4 | half | half |\n| int4 | int8_t | half | half |\n| int4 | int16_t | half | half |\n| int8_t | int4 | half | half |\n| int16_t | int4 | half | half | Table 3.18 Conv Data Types Supported on tp\\_322 and tp\\_520 | Src Type | Kernel Type | Dst Type | Bias Type |\n| --- | --- | --- | --- |\n| int8_t | int16_t | half | none |\n| int8_t | int16_t | float | none |\n| int8_t | int8_t | half | none |\n| int8_t | int8_t | float | none |\n| int8_t | int8_t | int16_t | none |\n| int16_t | int8_t | half | none |\n| int16_t | int8_t | float | none |\n| int16_t | int8_t | int16_t | none |\n| int16_t | int16_t | half | none |\n| int16_t | int16_t | float | none |\n| int16_t | int16_t | int16_t | none |\n| int8_t | int16_t | half | half |\n| int8_t | int16_t | float | float |\n| int8_t | int8_t | half | half |\n| int8_t | int8_t | float | float |\n| int8_t | int8_t | int16_t | int16_t |\n| int16_t | int8_t | half | half |\n| int16_t | int8_t | float | float |\n| int16_t | int8_t | int16_t | int16_t |\n| int16_t | int16_t | half | half |\n| int16_t | int16_t | float | float |\n| int16_t | int16_t | int16_t | int16_t |\n| int4 | int4 | float | none |\n| int4 | int8_t | float | none |\n| int4 | int16_t | float | none |\n| int8_t | int4 | float | none |\n| int16_t | int4 | float | none |\n| int4 | int4 | half | none |\n| int4 | int8_t | half | none |\n| int4 | int16_t | half | none |\n| int8_t | int4 | half | none |\n| int16_t | int4 | half | none |\n| int4 | int4 | float | float |\n| int4 | int8_t | float | float |\n| int4 | int16_t | float | float |\n| int8_t | int4 | float | float |\n| int16_t | int4 | float | float |\n| int4 | int4 | half | half |\n| int4 | int8_t | half | half |\n| int4 | int16_t | half | half |\n| int8_t | int4 | half | half |\n| int16_t | int4 | half | half | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_conv_partial for more details.",
    "conv_partial": "void __bang_conv_partial(half *dst, const int8_t *src, const int8_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int16_t *src, const int8_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int16_t *src, const int16_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int8_t *src, const int8_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int8_t *src, const int16_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int8_t *src, const int16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int16_t *src, const int8_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int16_t *src, const int16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int8_t *src, const int16_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int in_dilation_width, unsigned int in_dilation_height)   void __bang_conv_partial(float *dst, const int8_t *src, const int16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int in_dilation_width, unsigned int in_dilation_height)   void __bang_conv_partial(half *dst, const int8_t *src, const int8_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(half *dst, const int16_t *src, const int8_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(half *dst, const int16_t *src, const int16_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const int8_t *src, const int8_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const int16_t *src, const int8_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const int16_t *src, const int16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const half *src, const half *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_partial(float *dst, const half *src, const float *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_partial(float *dst, const float *src, const half *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_partial(float *dst, const float *src, const float *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_partial(float *dst, const bfloat16_t *src, const bfloat16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_partial(float *dst, const bfloat16_t *src, const float *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_partial(float *dst, const float *src, const bfloat16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_partial(half *dst, const int8_t *src, const int16_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int in_dilation_width, unsigned int in_dilation_height, unsigned int out_dilation_width, unsigned int out_dilation_height)   void __bang_conv_partial(float *dst, const int8_t *src, const int16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int in_dilation_width, unsigned int in_dilation_height, unsigned int out_dilation_width, unsigned int out_dilation_height)   void __bang_conv_partial(float *dst, const half *src, const half *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const float *src, const float *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const float *src, const half *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const half *src, const float *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const float *src, const bfloat16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const bfloat16_t *src, const bfloat16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int8_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int8_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int16_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int8_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int8_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int16_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(float *dst, const int16_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int8_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int8_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int16_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(half *dst, const int8_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const int8_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(half *dst, const int16_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(float *dst, const int16_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int8_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int8_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(half *dst, const int4x2_t *src, const int16_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const int4x2_t *src, const int16_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(half *dst, const int8_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const int8_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(half *dst, const int16_t *src, const int4x2_t *kernel, const half *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const int16_t *src, const int4x2_t *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   void __bang_conv_partial(float *dst, const bfloat16_t *src, const float *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   In \\_\\_nram\\_\\_ address space, uses the four-dimensional convolution kernel <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>] to perform a partial convolution operation on the three-dimensional tensor <src>[<height>, <width>, <channel\\_input>] with an interactive step size of [<stride\\_width>, <stride\\_height>], then adds the three-dimensional tensor <partial>[<dst\\_height>, <dst\\_width>, <channel\\_output>], and stores the result in the three-dimensional tensor <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>]. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination tensor which has (NH_oW_oC_o) data layout.\n* [in] src: The address of source tensor which has (NH_iW_iC_i) data layout.\n* [in] kernel: The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n* [in] partial: The address of partial_sum tensor which has (NH_oW_oC_o) data layout.\n* [in] channel\\_input: Number of input channels.\n* [in] height: The height of source tensor.\n* [in] width: The width of source tensor.\n* [in] kernel\\_height: The height of filter tensor.\n* [in] kernel\\_width: The width of filter tensor.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] channel\\_output: Number of output channels.\n* [in] fix\\_position: Scale Sum of the scale of <src> and <kernel>.\n* [in] indilation\\_width: Input dilation in W direction.\n* [in] indilation\\_height: Input dilation in H direction.\n* [in] outdilation\\_width: Output dilation in W direction.\n* [in] outdilation\\_height: Output dilation in H direction. Return* void Remark* <src>, <dst> and <partial> must point to \\_\\_nram\\_\\_ address space;\n* <kernel> must point to \\_\\_wram\\_\\_ address space;\n* <fix\\_position> is the sum of the scale factor of <src> and <kernel>;\n* <fix\\_position> must be in the range [-127, 127];\n* The address of <dst>, <src> or <partial> must be 64-byte aligned on (m)tp\\_2xx;\n* The address of <kernel> must be 32-byte aligned;\n* <channel\\_input> \\* sizeof(typeof<src>) must be 64-byte aligned on (m)tp\\_2xx;\n* <channel\\_output> must be divisible by 64 on (m)tp\\_2xx;\n* <channel\\_output> \\* sizeof(typeof<dst>) must be 64-byte aligned on (m)tp\\_2xx;\n* The byte size of <kernel> must be 64-byte aligned; otherwise, the non-aligned part of <kernel> will be random numbers on mtp\\_372 and tp\\_322, and zero on other architecture; On (m)tp\\_3xx and higher, there is no alignment constraint for parameter <channel\\_input>, but when allocating memory, the ci dimension of the memory space of <kernel> must satisfy the following alignment constraints: If the types of <src> and <kernel> are both floating point: Otherwise, (C_i) * sizeof(typeof<kernel>) must be 64-byte aligned; If --wram-align 64 or #pragma bang walign(64), see the table Conv w64 Alignment for more information about alignment constraints; On (m)tp\\_3xx and higher, there is no alignment constraint for parameter <channel\\_output>, but when allocating memory, the co dimension of memory space of <kernel> must be 64 aligned; Compatibility between Various Architectures Table 3.19 Conv Partial Data Types Supported on (m)tp\\_2xx | Src Type | Kernel Type | Dst Type | Partial Type |\n| --- | --- | --- | --- |\n| int16_t | int8_t | float | float |\n| int8_t | int8_t | float | float |\n| int16_t | int16_t | float | float |\n| int4 | int4 | float | float |\n| int8_t | int4 | float | float |\n| int16_t | int4 | float | float |\n| int16_t | int16_t | half | half |\n| int16_t | int8_t | half | half |\n| int8_t | int8_t | half | half |\n| int4 | int4 | half | half |\n| int8_t | int4 | half | half |\n| int16_t | int4 | half | half | Table 3.20 Conv Partial Data Types Supported on mtp\\_372 | Src Type | Kernel Type | Dst Type | Partial Type |\n| --- | --- | --- | --- |\n| int16_t | int8_t | float | float |\n| int8_t | int8_t | float | float |\n| int8_t | int16_t | float | float |\n| int16_t | int16_t | float | float |\n| int16_t | int16_t | half | half |\n| int16_t | int8_t | half | half |\n| int8_t | int8_t | half | half |\n| int8_t | int16_t | half | half |\n| float | float | float | float |\n| float | half | float | float |\n| half | float | float | float |\n| half | half | float | float |\n| float | bfloat16_t | float | float |\n| bfloat16_t | float | float | float |\n| bfloat16_t | bfloat16_t | float | float |\n| int4 | int4 | float | float |\n| int4 | int8_t | float | float |\n| int4 | int16_t | float | float |\n| int8_t | int4 | float | float |\n| int16_t | int4 | float | float |\n| int4 | int4 | half | half |\n| int4 | int8_t | half | half |\n| int4 | int16_t | half | half |\n| int8_t | int4 | half | half |\n| int16_t | int4 | half | half | Table 3.21 Conv Partial Data Types Supported on mtp\\_592 | Src Type | Kernel Type | Dst Type | Partial Type |\n| --- | --- | --- | --- |\n| int16_t | int8_t | float | float |\n| int8_t | int8_t | float | float |\n| int8_t | int16_t | float | float |\n| int16_t | int16_t | float | float |\n| int16_t | int16_t | half | half |\n| int16_t | int8_t | half | half |\n| int8_t | int8_t | half | half |\n| int8_t | int16_t | half | half |\n| float | float | float | float |\n| half | half | float | float |\n| bfloat16_t | bfloat16_t | float | float |\n| int4 | int4 | float | float |\n| int4 | int8_t | float | float |\n| int4 | int16_t | float | float |\n| int8_t | int4 | float | float |\n| int16_t | int4 | float | float |\n| int4 | int4 | half | half |\n| int4 | int8_t | half | half |\n| int4 | int16_t | half | half |\n| int8_t | int4 | half | half |\n| int16_t | int4 | half | half | Table 3.22 Conv Partial Data Types Supported on tp\\_322 and tp\\_520 | Src Type | Kernel Type | Dst Type | Partial Type |\n| --- | --- | --- | --- |\n| int16_t | int8_t | float | float |\n| int8_t | int8_t | float | float |\n| int8_t | int16_t | float | float |\n| int16_t | int16_t | float | float |\n| int16_t | int16_t | half | half |\n| int16_t | int8_t | half | half |\n| int8_t | int8_t | half | half |\n| int8_t | int16_t | half | half |\n| int4 | int4 | float | float |\n| int4 | int8_t | float | float |\n| int4 | int16_t | float | float |\n| int8_t | int4 | float | float |\n| int16_t | int4 | float | float |\n| int4 | int4 | half | half |\n| int4 | int8_t | half | half |\n| int4 | int16_t | half | half |\n| int8_t | int4 | half | half |\n| int16_t | int4 | half | half | Table 3.23 Conv w64 Alignment | Src Type | Kernel Type | ci align(B) | ci \\* <kernel\\_width> align(B) | ci \\* <kernel\\_width> \\* <kernel\\_height> align(B) |\n| --- | --- | --- | --- | --- |\n| int4 | int4 | 32 | 32 | 64 |\n| int4 | int8_t | 64 | 64 | 64 |\n| int4 | int16_t | 64 | 64 | 64 |\n| int8_t | int4 | 32 | 32 | 64 |\n| int8_t | int8_t | 64 | 64 | 64 |\n| int8_t | int16_t | 64 | 64 | 64 |\n| int16_t | int4 | 16 | 16 | 64 |\n| int16_t | int8_t | 32 | 32 | 64 |\n| int16_t | int16_t | 64 | 64 | 64 | Table 3.24 Conv w16 Alignment | Src Type | Kernel Type | ci align(B) | ci \\* <kernel\\_width> align(B) | ci \\* <kernel\\_width> \\* <kernel\\_height> align(B) |\n| --- | --- | --- | --- | --- |\n| int4 | int4 | 32 | 32 | 32 |\n| int4 | int8_t | 64 | 64 | 64 |\n| int4 | int16_t | 64 | 64 | 64 |\n| int8_t | int4 | 32 | 32 | 32 |\n| int8_t | int8_t | 64 | 64 | 64 |\n| int8_t | int16_t | 64 | 64 | 64 |\n| int16_t | int4 | 16 | 16 | 32 |\n| int16_t | int8_t | 32 | 32 | 32 |\n| int16_t | int16_t | 64 | 64 | 64 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= tp\\_2xx. Example\n```",
    "conv_partial_tf32": "void __bang_conv_partial_tf32(float *dst, const float *src, const float *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_partial_tf32(float *dst, const float *src, const float *kernel, const float *partial, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   In \\_\\_nram\\_\\_ address space, uses the four-dimensional convolution kernel <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>] to perform a partial convolution operation on the three-dimensional tensor <src>[<height>, <width>, <channel\\_input>] with an interactive step size of [<stride\\_width>, <stride\\_height>], then adds the three-dimensional tensor <partial>[<dst\\_height>, <dst\\_width>, <channel\\_output>], and stores the result in the three-dimensional tensor <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>]. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination tensor which has (NH_oW_oC_o) data layout.\n* [in] src: The address of source tensor which has (NH_iW_iC_i) data layout.\n* [in] kernel: The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n* [in] partial: The address of partial_sum tensor which has (NH_oW_oC_o) data layout.\n* [in] channel\\_input: Number of input channels.\n* [in] height: The height of source tensor.\n* [in] width: The width of source tensor.\n* [in] kernel\\_height: The height of filter tensor.\n* [in] kernel\\_width: The width of filter tensor.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] channel\\_output: Number of output channels.\n* [in] indilation\\_width: Input dilation in W direction.\n* [in] indilation\\_height: Input dilation in H direction.\n* [in] outdilation\\_width: Output dilation in W direction.\n* [in] outdilation\\_height: Output dilation in H direction. Return* void Remark* <src>, <dst> and <partial> must point to \\_\\_nram\\_\\_ address space;\n* <kernel> must point to \\_\\_wram\\_\\_ address space;\n* The address of <kernel> must be 32-byte aligned;\n* The byte size of <kernel> must be 64-byte aligned; otherwise, the non-aligned part will be set to zero;\n* There is no alignment constraint for parameter <channel\\_input>, but when allocating memory, (C_i) * sizeof(typeof<kernel>) must be 64-byte aligned;\n* There is no alignment constraint for parameter <channel\\_output>, but when allocating memory, the co dimension of memory space of <kernel> must be 64 aligned;\n* <kernel\\_height>, <kernel\\_width>, <channel\\_input> and <channel\\_output> must be greater than 0;\n* <stride\\_width> and <stride\\_height> must be in range [1, 1023];\n* <indilation\\_width>, <indilation\\_height>, <outdilation\\_width> and <outdilation\\_height> must be in range [1, 1023], and 1 means no dilation;\n* If <indilation\\_height> is used, (<height> - ((<kernel\\_height> - 1) \\* <indilation\\_height> + 1)) / <stride\\_height> + 1 must be greater than 0; otherwise, (<height> - <kernel\\_height>) / <stride\\_height> + 1 must be greater than 0;\n* If <indilation\\_width> is used, (<width> - ((<kernel\\_width> - 1) \\* <indilation\\_width> + 1)) / <stride\\_width> + 1 must be greater than 0; otherwise, (<width> - <kernel\\_width>) / <stride\\_width> + 1 must be greater than 0;\n* <dst> cannot be overlapped with <src>;\n* <dst> can be overlapped with <partial>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example\n```",
    "conv_sparse": "void __bang_conv_sparse(float *dst, const float *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_sparse(float *dst, const half *src, const half *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_sparse(float *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(float *dst, const int8_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(float *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(float *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(half *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(half *dst, const int8_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(half *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(half *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(int16_t *dst, const int8_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(int16_t *dst, const int16_t *src, const int8_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   void __bang_conv_sparse(int16_t *dst, const int16_t *src, const int16_t *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, int fix_position)   In \\_\\_nram\\_\\_ address space, uses the four-dimensional convolution kernel <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>] to perform a convolution operation on the three-dimensional tensor <src>[<height>, <width>, <channel\\_input>] in sparse mode with an interactive step size of [<stride\\_width>, <stride\\_height>], and stores the result in the three-dimensional tensor <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>]. Parameters* [out] dst: The address of destination tensor which has (NH_oW_oC_o) data layout.\n* [in] src: The address of source tensor which has (NH_iW_iC_i) data layout.\n* [in] kernel: The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n* [in] channel\\_input: Number of input channels.\n* [in] height: The height of source tensor.\n* [in] width: The width of source tensor.\n* [in] kernel\\_height: The height of filter tensor.\n* [in] kernel\\_width: The width of filter tensor.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] channel\\_output: Number of output channels.\n* [in] fix\\_position: Sum of scale factor of <src> and <kernel>. Return* void Remark* In sparse mode, <kernel> is in form of 96-byte structure with 64-byte data and 32-byte index. <kernel> can either be generated online by __bang_ssparse_filter_union related function or be prepared offline by programmers. If programmers want to offline prepare <kernel>, please refer to description of the output of __bang_ssparse_filter_union function for details on data structure and alignment requirements;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <kernel> must point to \\_\\_wram\\_\\_ address space;\n* <fix\\_position> is the sum of the scale factor of <src> and <kernel>, and must be in the range [-127, 127];\n* The address of <kernel> must be 32-byte aligned;\n* The byte size of <kernel> must be 64-byte aligned; otherwise, the non-aligned part of <kernel> will be zero; There is no alignment constraint for parameter <channel\\_input>, but when allocating memory, the ci dimension of the memory space of <kernel> must satisfy the following alignment constraints: If the types of <src> and <kernel> are both floating point: Otherwise, (C_i) * sizeof(typeof<kernel>) must be 64-byte aligned; If --wram-align 64 or #pragma bang walign(64), see the table Conv w64 Alignment for more information about alignment constraints; There is no alignment constraint for parameter <channel\\_output>, but when allocating memory, the co dimension of memory space of <kernel> must be 64 aligned; Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example\n```",
    "conv_tf32": "void __bang_conv_tf32(float *dst, const float *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output)   void __bang_conv_tf32(float *dst, const float *src, const float *kernel, unsigned int channel_input, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int channel_output, unsigned int indilation_width, unsigned int indilation_height, unsigned int outdilation_width, unsigned int outdilation_height)   In \\_\\_nram\\_\\_ address space, uses the four-dimensional convolution kernel <kernel>[<channel\\_output>, <kernel\\_height>, <kernel\\_width>, <channel\\_input>] to perform a convolution operation on the three-dimensional tensor <src>[<height>, <width>, <channel\\_input>] with an interactive step size of [<stride\\_width>, <stride\\_height>], and stores the result in the three-dimensional tensor <dst>[<dst\\_height>, <dst\\_width>, <channel\\_output>]. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination tensor which has (NH_oW_oC_o) data layout.\n* [in] src: The address of source tensor which has (NH_iW_iC_i) data layout.\n* [in] kernel: The address of filter tensor which has (C_oH_kW_kC_i) data layout.\n* [in] channel\\_input: Number of input channels.\n* [in] height: The height of source tensor.\n* [in] width: The width of source tensor.\n* [in] kernel\\_height: The height of filter tensor.\n* [in] kernel\\_width: The width of filter tensor.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] channel\\_output: Number of output channels.\n* [in] indilation\\_width: Input dilation in W direction.\n* [in] indilation\\_height: Input dilation in H direction.\n* [in] outdilation\\_width: Output dilation in W direction.\n* [in] outdilation\\_height: Output dilation in H direction. Return* void. Remark* <src>, <dst> must point to \\_\\_nram\\_\\_ address space;\n* <kernel> must point to \\_\\_wram\\_\\_ address space;\n* The address of <kernel> must be 32-byte aligned;\n* The byte size of <kernel> must be 64-byte aligned; otherwise, the non-aligned part will be set to zero;\n* There is no alignment constraint for parameter <channel\\_input>, but when allocating memory, (C_i) * sizeof(typeof<kernel>) must be 64-byte aligned;\n* There is no alignment constraint for parameter <channel\\_output>, but when allocating memory, the co dimension of memory space of <kernel> must be 64 aligned;\n* <kernel\\_height>, <kernel\\_width>, <channel\\_input> and <channel\\_output> must be greater than 0;\n* <stride\\_width> and <stride\\_height> must be in range [1, 1023];\n* <indilation\\_width>, <indilation\\_height>, <outdilation\\_width> and <outdilation\\_height> must be in range [1, 1023], and 1 means no dilation;\n* If <indilation\\_height> is used, (<height> - ((<kernel\\_height> - 1) \\* <indilation\\_height> + 1)) / <stride\\_height> + 1 must be greater than 0; otherwise, (<height> - <kernel\\_height>) / <stride\\_height> + 1 must be greater than 0;\n* If <indilation\\_width> is used, (<width> - ((<kernel\\_width> - 1) \\* <indilation\\_width> + 1)) / <stride\\_width> + 1 must be greater than 0; otherwise, (<width> - <kernel\\_width>) / <stride\\_width> + 1 must be greater than 0;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* See the example of __bang_conv_partial_tf32 for more detail.",
    "maxpool": "void __bang_maxpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   Applies maxpooling forward operation on <src> [<height>, <width>, <channel>], a three-dimensional tensor with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the maximum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple maximum values, the result is the first maximum value. Parameters* [out] dst: The address of destination tensor. And the tensor data layout is HWC.\n* [in] src: The address of source tensor. And the tensor data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of sliding window.\n* [in] kernel\\_width: The width of sliding window.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The function with dilation is supported on (m)tp\\_3xx or higher;\n* <dst> cannot be overlapped with <src>;\n* In the function without stride, <stride\\_width> equals <kernel\\_width> and <stride\\_height> equals <kernel\\_height>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* <stride\\_height> and <stride\\_width> must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation.\n* This function was deprecated from CNCC v4.5.0. Use __bang_sumpool and __bang_cycle_mul instead on (m)tp_2xx or use __bang_sumpool and __bang_mul_scalar instead on (m)tp_3xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "maxpool_bp": "void __bang_maxpool_bp(half *dst, const half *src, short *mask, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   void __bang_maxpool_bp(bfloat16_t *dst, const bfloat16_t *src, unsigned short *mask, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   void __bang_maxpool_bp(float *dst, const float *src, int *mask, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   Applies maxpooling backward propagation operation on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the index with the maximum value. <overlap> indicates the type of overlap options. <overlap> is assigned to an enumerated type called mluPoolBPOverlap that contains 2 enumerators listed in the table below. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. Table 3.25 Semantics of mluPoolBPOverlap | mluPoolBPOverlap Type | Semantic |\n| --- | --- |\n| OVERLAP\\_ACC | Accumulates the overlap parts of the output. |\n| OVERLAP\\_COVER | Covers the overlap parts of the output. | Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] mask: The index of the maximum value inside a kernel, and the tensor data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of output feature map.\n* [in] width: The width of output feature map.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] overlap: The type of overlap options. Return* void. Remark* <src>, <mask> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* The address of <src>, <mask> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* When the data type of <src> and <dst> is half or bfloat16\\_t, the data type of <mask> must be short. When the data type of <src> and <dst> are float, the data type of <mask> must be int;\n* <dst> cannot be overlapped with <src>;\n* The default mluPoolBPOverlap option is OVERLAP\\_ACC;\n* [input\\_height] and [input\\_width] of <src> must be greater than 0;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height> and <stride\\_width> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}). Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "maxpool_index": "void __bang_maxpool_index(unsigned short *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width)   void __bang_maxpool_index(unsigned short *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_maxpool_index(unsigned short *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_maxpool_index(unsigned short *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_maxpool_index(unsigned int *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_maxpool_index(unsigned short *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_maxpool_index(unsigned int *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   Applies maxpooling forward operation with index on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the index of the maximum value in each window. When the data type of <src> is half or bfloat16\\_t, the data type of <dst> is unsigned short. When the data type of <src> is float, the data type of <dst> is unsigned int. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple maximum values, the index is the position of the first maximum value. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The function with dilation is supported on (m)tp\\_3xx or higher;\n* <dst> cannot be overlapped with <src>;\n* In the function without stride, <stride\\_width> equals <kernel\\_width> and <stride\\_height> equals <kernel\\_height>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* <stride\\_height> and <stride\\_width> must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "maxpool_value_index": "void __bang_maxpool_value_index(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride)   void __bang_maxpool_value_index(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride)   void __bang_maxpool_value_index(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride)   void __bang_maxpool_value_index(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_maxpool_value_index(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_maxpool_value_index(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   Performs maximum pooling operation with the kernel [kernel\\_height, kernel\\_width] and the stride [stride\\_width, stride\\_height] on the tensor <src>[channel, height, width] in \\_\\_nram\\_\\_ address space, then stores the maximum value and the corresponding index to <dst>. When the data type of <src> is half, the data type of value in <dst> is half and the data type of index in <dst> is unsigned short. When the data type of <src> is float, the data type of value in <dst> is float and the data type of index in <dst> is unsigned int. When the kernel moves to the edge of input <width> and the kernel overflows, it will automatically adapt to the size of <kernel\\_width>, so as to ensure that useless input is not included. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple maximum values, the index is the position of the first maximum value. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: The input channel.\n* [in] height: The height of input source.\n* [in] width: The width of input source.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] value\\_index\\_stride: The offset from the beginning of data value to index value in bytes.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* For the output tensor <dst>[output\\_channel, output\\_height, output\\_width], [output\\_channel] = <channel>, and [output\\_height, output\\_width] are obtained by deducing from [height, width], [kernel\\_height, kernel\\_width] and [stride\\_width, stride\\_height];\n* For the value part of <dst>, when <value\\_index\\_stride> > 0, the address operands <dst> can be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height>, <stride\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation.\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example\n```",
    "minpool": "void __bang_minpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width)   void __bang_minpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_minpool(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_minpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_minpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_minpool(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_minpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   Applies minpooling forward operation on <src>``[``<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the minimum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple minimum values, the result is the first minimum value. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of sliding window.\n* [in] kernel\\_width: The width of sliding window.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The function with dilation is supported on (m)tp\\_3xx or higher;\n* <dst> cannot be overlapped with <src>;\n* In the function without stride, <stride\\_width> equals <kernel\\_width> and <stride\\_height> equals <kernel\\_height>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* <stride\\_height> and <stride\\_width> must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "minpool_index": "void __bang_minpool_index(unsigned short *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width)   void __bang_minpool_index(unsigned short *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_minpool_index(unsigned short *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_minpool_index(unsigned short *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_minpool_index(unsigned int *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_minpool_index(unsigned short *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_minpool_index(unsigned int *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   Applies minpooling forward operation with index on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the index with the minimum value in each window. When the data type of <src> is half or bfloat16\\_t, the data type of <dst> is unsigned short. When the data type of <src> is float, the data type of <dst> is unsigned int. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple minimum values, the index is the position of the first minimum value. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of sliding window.\n* [in] kernel\\_width: The width of sliding window.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The function with dilation is supported on (m)tp\\_3xx or higher;\n* <dst> cannot be overlapped with <src>;\n* In the function without stride, <stride\\_width> equals <kernel\\_width> and <stride\\_height> equals <kernel\\_height>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* <stride\\_height> and <stride\\_width> must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "minpool_value_index": "void __bang_minpool_value_index(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride)   void __bang_minpool_value_index(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride)   void __bang_minpool_value_index(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride)   void __bang_minpool_value_index(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_minpool_value_index(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_minpool_value_index(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: The input channel.\n* [in] height: The height of input source.\n* [in] width: The width of input source.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] value\\_index\\_stride: The offset from the beginning of data value to index value in bytes.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* For the output tensor <dst>[output\\_channel, output\\_height, output\\_width], [output\\_channel] = <channel>, and [output\\_height, output\\_width] are obtained by deducing from [height, width], [kernel\\_height, kernel\\_width] and [stride\\_width, stride\\_height];\n* For the value part of <dst>, when <value\\_index\\_stride> > 0, the address operands <dst> can be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height>, <stride\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation.\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example\n```",
    "nan_maxpool": "void __bang_nan_maxpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_maxpool(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_maxpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   Applies maxpooling forward operation on <src> [<height>, <width>, <channel>], a three-dimensional tensor with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the maximum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple maximum values, the result is the first maximum value. Parameters* [out] dst: The address of destination tensor. And the tensor data layout is HWC.\n* [in] src: The address of source tensor. And the tensor data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of sliding window.\n* [in] kernel\\_width: The width of sliding window.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height>, <stride\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "nan_maxpool_index": "void __bang_nan_maxpool_index(unsigned short *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_maxpool_index(unsigned short *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_maxpool_index(unsigned int *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   Applies maxpooling forward operation with index on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the index of the maximum value in each window. When the data type of <src> is half or bfloat16\\_t, the data type of <dst> is unsigned short. When the data type of <src> is float, the data type of <dst> is unsigned int. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple maximum values, the index is the position of the first maximum value. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height>, <stride\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "nan_maxpool_value_index": "void __bang_nan_maxpool_value_index(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_maxpool_value_index(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_maxpool_value_index(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: The input channel.\n* [in] height: The height of input source.\n* [in] width: The width of input source.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] value\\_index\\_stride: The offset from the beginning of data value to index value in bytes.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* For the output tensor <dst>[output\\_channel, output\\_height, output\\_width], [output\\_channel] = <channel>, and [output\\_height, output\\_width] are obtained by deducing from [height, width], [kernel\\_height, kernel\\_width] and [stride\\_width, stride\\_height];\n* For the value part of <dst>, when <value\\_index\\_stride> > 0, the address operands <dst> can be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height>, <stride\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "nan_minpool": "void __bang_nan_minpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_minpool(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_minpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   Applies minpooling forward operation on <src>``[``<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the minimum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple minimum values, the result is the first minimum value. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of sliding window.\n* [in] kernel\\_width: The width of sliding window.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height>, <stride\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "nan_minpool_index": "void __bang_nan_minpool_index(unsigned short *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_minpool_index(unsigned short *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_minpool_index(unsigned int *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   Applies minpooling forward operation with index on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and selects the index with the minimum value in each window. When the data type of <src> is half or bfloat16\\_t, the data type of <dst> is unsigned short. When the data type of <src> is float, the data type of <dst> is unsigned int. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple minimum values, the index is the position of the first minimum value. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of sliding window.\n* [in] kernel\\_width: The width of sliding window.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height>, <stride\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "nan_minpool_value_index": "void __bang_nan_minpool_value_index(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_minpool_value_index(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_nan_minpool_value_index(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int value_index_stride, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: The input channel.\n* [in] height: The height of input source.\n* [in] width: The width of input source.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: The stride in W direction.\n* [in] stride\\_height: The stride in H direction.\n* [in] value\\_index\\_stride: The offset from the beginning of data value to index value in bytes.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* For the output tensor <dst>[output\\_channel, output\\_height, output\\_width], [output\\_channel] = <channel>, and [output\\_height, output\\_width] are obtained by deducing from [height, width], [kernel\\_height, kernel\\_width] and [stride\\_width, stride\\_height];\n* For the value part of <dst>, when <value\\_index\\_stride> > 0, the address operands <dst> can be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height>, <stride\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "relu": "void __bang_relu(char *dst, const char *src, unsigned int elem_count)   void __bang_relu(short *dst, const short *src, unsigned int elem_count)   void __bang_relu(int *dst, const int *src, unsigned int elem_count)   void __bang_relu(half *dst, const half *src, unsigned int elem_count)   void __bang_relu(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_relu(float *dst, const float *src, unsigned int elem_count)   This instruction performs relu operation on each element in vector <src> and saves the result to vector <dst>. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source. Return* void. Remark* <elem\\_count> must be greater than zero;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short and char are not supported on tp\\_520;\n* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example\n```",
    "relun": "void __bang_relun(int *dst, const int *src, unsigned int elem_count, int nvalue)   void __bang_relun(short *dst, const short *src, unsigned int elem_count, short nvalue)   void __bang_relun(char *dst, const char *src, unsigned int elem_count, char nvalue)   void __bang_relun(half *dst, const half *src, unsigned int elem_count, half nvalue)   void __bang_relun(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count, bfloat16_t nvalue)   void __bang_relun(float *dst, const float *src, unsigned int elem_count, float nvalue)   The instruction performs relun operation on each element in <src>. If the element in <src> is less than 0, corresponding element in <dst> will be 0. If the element is greater than <nvalue>, corresponding element in <dst> will be <nvalue>. Otherwise, the element in <dst> will be itself. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source.\n* [in] nvalue: The N value of instruction. Return* void. Remark* <elem\\_count> must be greater than zero;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short and char are not supported on tp\\_520;\n* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <nvalue> must be greater than zero, and cannot be INF or NaN. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example\n```",
    "reshape_filter": "void __bang_reshape_filter(half *dst, const half *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_filter(short *dst, const short *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_filter(unsigned short *dst, const unsigned short *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_filter(int8_t *dst, const int8_t *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_filter(char *dst, const char *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_filter(unsigned char *dst, const unsigned char *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_filter(float *dst, const float *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_filter(int *dst, const int *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_filter(unsigned int *dst, const unsigned int *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   Reshapes the vector <src> to <n> / 64 along n dimension and suit for \\_\\_bang\\_mlp() and \\_\\_bang\\_conv(), where the vector <src> is in \\_\\_nram\\_\\_ space, then gives the result to the vector <dst> in \\_\\_nram\\_\\_ space. \n```",
    "reshape_nchw2nhwc": "void __bang_reshape_nchw2nhwc(half *dst, const half *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nchw2nhwc(short *dst, const short *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nchw2nhwc(unsigned short *dst, const unsigned short *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nchw2nhwc(int8_t *dst, const int8_t *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nchw2nhwc(char *dst, const char *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nchw2nhwc(unsigned char *dst, const unsigned char *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nchw2nhwc(float *dst, const float *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nchw2nhwc(int *dst, const int *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nchw2nhwc(unsigned int *dst, const unsigned int *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   Reshapes the vector <src> from NCHW to NHWC, where the vector <src> is in \\_\\_nram\\_\\_ space and has an order of NCHW, then gives the result to the vector <dst> in \\_\\_nram\\_\\_ space and has an order of NHWC. Parameters* [out] dst: The address of output kernel whose data layout is NHWC .\n* [in] src: The address of input kernel whose data layout is NCHW .\n* [in] n: The batch number of input kernel, also can represent channel output..\n* [in] h: The height of input kernel.\n* [in] w: The width of input kernel.\n* [in] c: The channel input of kernel. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* ( \\times  \\times sizeof(type)) must be divisible by 64;\n* ( \\times sizeof(type)) must be divisible by 64;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "reshape_nhwc2nchw": "void __bang_reshape_nhwc2nchw(half *dst, const half *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nhwc2nchw(short *dst, const short *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nhwc2nchw(unsigned short *dst, const unsigned short *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nhwc2nchw(int8_t *dst, const int8_t *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nhwc2nchw(char *dst, const char *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nhwc2nchw(unsigned char *dst, const unsigned char *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nhwc2nchw(float *dst, const float *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nhwc2nchw(int *dst, const int *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   void __bang_reshape_nhwc2nchw(unsigned int *dst, const unsigned int *src, unsigned int n, unsigned int h, unsigned int w, unsigned int c)   Reshapes the vector <src> from NHWC to NCHW, where the vector <src> is in \\_\\_nram\\_\\_ space and has an order of NHWC, then gives the result to the vector <dst> in \\_\\_nram\\_\\_ space and has an order of NCHW . Parameters* [out] dst: The address of output kernel whose data layout is NCHW .\n* [in] src: The address of input kernel whose data layout is NHWC .\n* [in] n: The batch number of input kernel, also can represent channel output.\n* [in] h: The height of input kernel.\n* [in] w: The width of input kernel.\n* [in] c: The channel input of kernel. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* ( \\times  \\times sizeof(type)) must be divisible by 64;\n* ( \\times sizeof(type)) must be divisible by 64;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "ssparse_filter_index": "void __bang_ssparse_filter_index(half *dst, const half *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_index(float *dst, const float *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_index(int8_t *dst, const int8_t *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_index(int16_t *dst, const int16_t *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_index(int *dst, const int *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_index(bfloat16_t *dst, const bfloat16_t *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   Selects 2 elements with larger absolute value from every 4 elements of <src> and stores the index of selected elements in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] input\\_channel: The number of input channel of source vector.\n* [in] src\\_height: The height of source vector.\n* [in] src\\_width: The width of source vector.\n* [in] output\\_channel: The number of channel of destination vector. Return* void Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <src> is split by 8 elements on input\\_channel dimension. When the split part is less than 8 elements, hardware will pad to 8 elements with zero;\n* Each bit in index corresponds to one element in <src>;\n* There is no alignment constraint for parameter <input\\_channel>, but the size of input\\_channel dimension of <dst> must align to ceil(<input\\_channel> / (8 \\* (sizeof(typeof(<src>))))) byte(s). Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example\n```",
    "ssparse_filter_sparse_index": "void __bang_ssparse_filter_sparse_index(half *dst, const half *src, const half *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_sparse_index(float *dst, const float *src, const float *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_sparse_index(int8_t *dst, const int8_t *src, const int8_t *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_sparse_index(int16_t *dst, const int16_t *src, const int16_t *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_sparse_index(int *dst, const int *src, const int *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_sparse_index(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   Selects 2 elements based on <index> from every 4 elements of <src>, sets the unselected elements to zero and stores the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] index: The address of index vector.\n* [in] input\\_channel: The number of input channel of source vector.\n* [in] src\\_height: The height of source vector.\n* [in] src\\_width: The width of source vector.\n* [in] output\\_channel: The number of channel of destination vector. Return* void Remark* <dst>, <src> and <index> must point to \\_\\_nram\\_\\_ address space;\n* Each bit in <index> corresponds to one element in <src>;\n* <dst> and <src> have the same <input\\_channel> dimension size;\n* The byte size of <input\\_channel> dimension of <index> equals ceil(<input\\_channel> / bit\\_size(typeof(<src>)));\n* If <index> is split by 4 bits and some parts do not belong to {4'b0011, 4'b0101, 4'b1001, 4'b0110, 4'b1010, 4'b1100}, hardware will set illegal parts to 4'b0011 to keep the propram running. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example\n```",
    "ssparse_filter_union": "void __bang_ssparse_filter_union(half *dst, const half *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union(float *dst, const float *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union(int8_t *dst, const int8_t *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union(int16_t *dst, const int16_t *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union(int *dst, const int *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union(bfloat16_t *dst, const bfloat16_t *src, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   Selects 2 elements with larger absolute value from every 4 elements of <src> and stores the selected elements and corresponding indexes in <dst> in form of 96-byte structure. Each structure consists of 64-byte data and 32-byte index. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] input\\_channel: The number of input channel of source vector.\n* [in] src\\_height: The height of source vector.\n* [in] src\\_width: The width of source vector.\n* [in] output\\_channel: The number of channel of destination vector. Return* void Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <src> is split by 128 bytes on input\\_channel dimension. When the split part is less than 128 bytes, hardware will pad to 128 bytes with zero;\n* Each bit in index corresponds to 4 bits in <src>. If one bit is 1 in output index, that means its corresponding 4 bits in <src> are selected;\n* There is no alignment constraint for parameter <input\\_channel>, but the size of input\\_channel dimension of <dst> must align to (ceil(<input\\_channel> / 128) \\* 96) byte(s). Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example\n```",
    "ssparse_filter_union_index": "void __bang_ssparse_filter_union_index(half *dst, const half *src, const half *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union_index(float *dst, const float *src, const float *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union_index(int8_t *dst, const int8_t *src, const int8_t *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union_index(int16_t *dst, const int16_t *src, const int16_t *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union_index(int *dst, const int *src, const int *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   void __bang_ssparse_filter_union_index(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *index, unsigned int input_channel, unsigned int src_height, unsigned int src_width, unsigned int output_channel)   Selects 2 elements based on <index> from every 4 elements of <src> and stores the selected elements and corresponding indexes in <dst> in form of 96-byte structure. Each structure consists of 64-byte data and 32-byte index. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] index: The address of index vector.\n* [in] input\\_channel: The number of input channel of source vector.\n* [in] src\\_height: The height of source vector.\n* [in] src\\_width: The width of source vector.\n* [in] output\\_channel: The number of channel of destination vector. Return* void. Remark* <dst>, <src> and <index> must point to \\_\\_nram\\_\\_ address space;\n* Each bit in <index> corresponds to one element in <src>;\n* Each bit in output index corresponds to 4 bits in <src>. If one bit is 1 in output index, its corresponding 4 bits in <src> are selected;\n* There is no alignment constraint for parameter <input\\_channel>, but the size of input\\_channel dimension of <dst> must align to 96 bytes;\n* The data part of <dst> should be 64-byte aligned. Otherwise, hardware will pad to 64 bytes with zero;\n* The index part of <dst> should be 32-byte aligned. Otherwise,\n    + If bit\\_size(<type>) == 4, hardware will pad to 32 bytes with 4'b0011.\n    + If bit\\_size(<type>) == 8, hardware will pad to 32 bytes with 8'b0000\\_1111.\n    + If bit\\_size(<type>) == 16, hardware will pad to 32 bytes with 16'b0000\\_0000\\_1111\\_1111.\n    + If bit\\_size(<type>) == 32, hardware will pad to 32 bytes with 32'b0000\\_0000\\_0000\\_0000\\_1111\\_1111\\_1111\\_1111;\n* Split <index> by 4 bits and set illegal parts, which do not belong to {4'b0011, 4'b0101, 4'b1001, 4'b0110, 4'b1010, 4'b1100}, to 4'b0011. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example\n```",
    "sumpool": "void __bang_sumpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width)   void __bang_sumpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_sumpool(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_sumpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   Applies sumpooling forward operation on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and saves the sum in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: Stride of W direction.\n* [in] stride\\_height: Stride of H direction. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height> and <kernel\\_width> must be greater than 0;\n* <stride\\_height> and <stride\\_width> must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}). Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "sumpool_bp": "void __bang_sumpool_bp(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   void __bang_sumpool_bp(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   void __bang_sumpool_bp(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   Performs sumpooling backward propagation operation on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and calculates the sum value in each window. <overlap> indicates the type of overlap options. <overlap> is assigned to an enumerated type called mluPoolBPOverlap that contains 2 enumerators listed in the table below. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. Table 3.30 Semantics of mluPoolBPOverlap | mluPoolBPOverlap Type | Semantic |\n| --- | --- |\n| OVERLAP\\_ACC | Accumulates the overlap parts of the output. |\n| OVERLAP\\_COVER | Covers the overlap parts of the output. | See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of output feature map.\n* [in] width: The width of output feature map.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] overlap: The type of overlap options. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* The default mluPoolBPOverlap option is OVERLAP\\_ACC;\n* [input\\_height] and [input\\_width] of <src> must be greater than 0;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height> and <stride\\_width> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}).\n* This function was deprecated from CNCC v4.5.0. Use __bang_sumpool_bp and __bang_cycle_mul instead on (m)tp_2xx or use __bang_sumpool_bp and __bang_mul_scalar instead on (m)tp_3xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```\n #include  __mlu_entry__ void PoolSumBpKernel(half* output, half* input,\n                                    unsigned int channels, int out_height,\n                                    unsigned int out_width, int kernel_height,\n                                    unsigned int kernel_width, int stride_width,\n                                    unsigned int stride_height) {\n   __nram__ half a_tmp[INPUT_COUNT];\n   __nram__ half b_tmp[OUTPUT_COUNT];\n   __memcpy(b_tmp, output, OUTPUT_COUNT * sizeof(half), GDRAM2NRAM);\n   __memcpy(a_tmp, input, INPUT_COUNT * sizeof(half), GDRAM2NRAM);\n   __bang_sumpool_bp(b_tmp, a_tmp, channels, out_height, out_width,\n                     kernel_height, kernel_width, stride_width,\n                     stride_height);\n   __memcpy(output, b_tmp, OUTPUT_COUNT * sizeof(half), NRAM2GDRAM);\n} ```",
    "unpool": "void __bang_unpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int index)   void __bang_unpool(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int index)   void __bang_unpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int index)   Applies unpooling backward operation on <src>, a tensor. Every element of <src> tensor corresponds to a kernel window on <dst> tensor operand. The elements of <src> tensor is written into <index>’th position in that kernel window on <dst> tensor, and other positions in the kernel window are written zero. The Figure Process of Unpool Operation shows an example with the following parameters, height = 5, width = 5, kernel\\_height = 2, kernel\\_width = 2, stride\\_height = 3, stride\\_width = 3, input\\_height = 2, input\\_width = 2, and index = 1.  Fig. 3.4 Process of Unpool Operation Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of output feature map.\n* [in] width: The width of output feature map.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: W direction of stride.\n* [in] stride\\_height: H direction of stride.\n* [in] index: Index within kernel window. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The shape of <dst> tensor [<height>, <width>, out\\_channel] and <src> tensor [input\\_height, input\\_width, <channel>] has following restrictions: ( = (input\\_height – 1) *  + ), ( = (input\\_width – 1) *  + ), (out\\_channel = );\n* The <index>’th position in kernel window means ikh’th row and ikw’th column in kernel window, where (ikh * <kernel\\_width> + ikw = <index>);\n* If <stride\\_width> > <kernel\\_width> or <stride\\_height> > <kernel\\_height>, the elements in <dst> that do not belong to any kernel window remain unchanged;\n* <dst> cannot be overlapped with <src>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height> and <stride\\_width> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}). Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "atomic_cas": "void __bang_atomic_cas(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned short src3)   void __bang_atomic_cas(short *dst, short *src1, short src2, short src3)   void __bang_atomic_cas(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int src3)   void __bang_atomic_cas(float *dst, float *src1, float src2, float src3)   void __bang_atomic_cas(half *dst, half *src1, half src2, half src3)   void __bang_atomic_cas(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, bfloat16_t src3)   void __bang_atomic_cas(int *dst, int *src1, int src2, int src3)   If <src2> is equal to <\\*src1>, stores <src3> in <src1>. Stores the original value of <\\*src1> in <dst>. That is: <\\*dst> = <\\*src1>; <\\*src1> = (<\\*src1> == <src2>) ? <src3> : <\\*src1>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1: The address of first operand.\n* [in] src2: The second operand.\n* [in] src3: The third operand. Return* void. Remark* This function only operates on one element;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1> must be sizeof(type) aligned;\n* bfloat16\\_t, float and half are supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example\n```",
    "atomic_cas_async": "void __bang_atomic_cas_async(unsigned short *dst, unsigned short *src1, unsigned short src2, unsigned short src3)   void __bang_atomic_cas_async(short *dst, short *src1, short src2, short src3)   void __bang_atomic_cas_async(unsigned int *dst, unsigned int *src1, unsigned int src2, unsigned int src3)   void __bang_atomic_cas_async(float *dst, float *src1, float src2, float src3)   void __bang_atomic_cas_async(half *dst, half *src1, half src2, half src3)   void __bang_atomic_cas_async(bfloat16_t *dst, bfloat16_t *src1, bfloat16_t src2, bfloat16_t src3)   void __bang_atomic_cas_async(int *dst, int *src1, int src2, int src3)   If <src2> is equal to <\\*src1>, stores <src3> in <src1>. Stores the original value of <\\*src1> in <dst>. That is: <\\*dst> = <\\*src1>; <\\*src1> = (<\\*src1> == <src2>) ? <src3> : <\\*src1>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1: The address of first operand.\n* [in] src2: The second operand.\n* [in] src3: The third operand. Return* void. Remark* This function only operates on one element;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src1> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1> must be sizeof(type) aligned;\n* bfloat16\\_t, float and half are supported on mtp\\_592 or higher. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 322 and 520;\n* CNCC Version: cncc --version 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx except tp\\_322 and tp\\_520. Example\n```",
    "atomic_reduce_cas": "void __bang_atomic_reduce_cas(short *dst, short src1, short src2)   void __bang_atomic_reduce_cas(half *dst, half src1, half src2)   void __bang_atomic_reduce_cas(float *dst, float src1, float src2)   void __bang_atomic_reduce_cas(bfloat16_t *dst, bfloat16_t src1, bfloat16_t src2)   void __bang_atomic_reduce_cas(int *dst, int src1, int src2)   If <src1> is equal to <\\*dst>, stores <src2> in <dst>. That is: <\\*dst> = (<\\*dst> == <src1>) ? <src2> : <\\*dst>. Parameters* [out] dst: The address of destination operand.\n* [in] src1: The first operand.\n* [in] src2: The second operand. Return* void. Remark* This function only operates on one element;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example\n```",
    "atomic_reduce_cas_async": "void __bang_atomic_reduce_cas_async(short *dst, short src1, short src2)   void __bang_atomic_reduce_cas_async(half *dst, half src1, half src2)   void __bang_atomic_reduce_cas_async(float *dst, float src1, float src2)   void __bang_atomic_reduce_cas_async(bfloat16_t *dst, bfloat16_t src1, bfloat16_t src2)   void __bang_atomic_reduce_cas_async(int *dst, int src1, int src2)   If <src1> is equal to <\\*dst>, stores <src2> in <dst>. That is: <\\*dst> = (<\\*dst> == <src1>) ? <src2> : <\\*dst>. Parameters* [out] dst: The address of destination operand.\n* [in] src1: The first operand.\n* [in] src2: The second operand. Return* void. Remark* This function only operates on one element;\n* bfloat16\\_t is supported on mtp\\_592 or higher;\n* <dst> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <dst> must be sizeof(type) aligned. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 372 except 520;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_372 except tp\\_520. Example\n```",
    "printf": "int __bang_printf(const char *fmt, ...)   Similar to standard printf function, prints arguments to screen, formatted by the format string. Parameters* [in] fmt: The format string, which must be a literal constant string. Return* void. Remark* <fmt> must be a literal constant string;\n* This function can at most accept 17 parameters including the format string;\n* The type of parameters can be different. It must be one of: char, unsigned char, short, unsigned short, int, unsigned int, half, float, char, bool, pointer;\n* Since this function involves extremely time-consuming interaction between CPU and MLU, it might cause significant performance degradation. Instruction Pipeline* NA. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "discrete_atomic_add": "void __bang_discrete_atomic_add(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_add(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_add(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_add(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_add(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_add(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_add(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_add(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_add(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_add(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_add(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_add(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_add(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_add(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_add(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_add(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_add(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Adds <src2> to the values in discrete <src1> addresses. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic add is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example\n```",
    "discrete_atomic_and": "void __bang_discrete_atomic_and(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_and(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_and(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_and(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_and(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_and(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_and(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_and(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_and(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_and(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_and(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_and(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Performs bitwise AND on the values in discrete <src1> addresses with <src2> respectively. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic bitwise AND is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_cas": "void __bang_discrete_atomic_cas(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, short src3, unsigned int size)   void __bang_discrete_atomic_cas(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, short src3, unsigned int size)   void __bang_discrete_atomic_cas(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, short src3, unsigned int size)   void __bang_discrete_atomic_cas(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, int src3, unsigned int size)   void __bang_discrete_atomic_cas(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, int src3, unsigned int size)   void __bang_discrete_atomic_cas(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, int src3, unsigned int size)   void __bang_discrete_atomic_cas(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, half src3, unsigned int size)   void __bang_discrete_atomic_cas(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, half src3, unsigned int size)   void __bang_discrete_atomic_cas(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, half src3, unsigned int size)   void __bang_discrete_atomic_cas(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, float src3, unsigned int size)   void __bang_discrete_atomic_cas(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, float src3, unsigned int size)   void __bang_discrete_atomic_cas(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, float src3, unsigned int size)   void __bang_discrete_atomic_cas(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, bfloat16_t src3, unsigned int size)   void __bang_discrete_atomic_cas(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, bfloat16_t src3, unsigned int size)   void __bang_discrete_atomic_cas(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, bfloat16_t src3, unsigned int size)   void __bang_discrete_atomic_cas(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, short src3, unsigned int size)   void __bang_discrete_atomic_cas(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, short src3, unsigned int size)   void __bang_discrete_atomic_cas(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, short src3, unsigned int size)   void __bang_discrete_atomic_cas(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, int src3, unsigned int size)   void __bang_discrete_atomic_cas(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, int src3, unsigned int size)   void __bang_discrete_atomic_cas(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, int src3, unsigned int size)   void __bang_discrete_atomic_cas(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, half src3, unsigned int size)   void __bang_discrete_atomic_cas(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, half src3, unsigned int size)   void __bang_discrete_atomic_cas(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, half src3, unsigned int size)   void __bang_discrete_atomic_cas(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, float src3, unsigned int size)   void __bang_discrete_atomic_cas(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, float src3, unsigned int size)   void __bang_discrete_atomic_cas(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, float src3, unsigned int size)   void __bang_discrete_atomic_cas(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, bfloat16_t src3, unsigned int size)   void __bang_discrete_atomic_cas(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, bfloat16_t src3, unsigned int size)   void __bang_discrete_atomic_cas(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, bfloat16_t src3, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Stores the values in <src2> in discrete <src1> addresses respectively if they are equal to <src3>. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] src3: The third operand.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic compare-and-swap is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_dec": "void __bang_discrete_atomic_dec(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_dec(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_dec(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_dec(unsigned short *dst, const unsigned short *src1_base, const unsigned char *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_dec(unsigned short *dst, const unsigned short *src1_base, const unsigned short *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_dec(unsigned short *dst, const unsigned short *src1_base, const unsigned int *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_dec(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_dec(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_dec(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_dec(unsigned int *dst, const unsigned int *src1_base, const unsigned char *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_dec(unsigned int *dst, const unsigned int *src1_base, const unsigned short *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_dec(unsigned int *dst, const unsigned int *src1_base, const unsigned int *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_dec(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(unsigned short *dst, const unsigned short *src1_base, const unsigned char *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(unsigned short *dst, const unsigned short *src1_base, const unsigned short *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(unsigned short *dst, const unsigned short *src1_base, const unsigned int *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(unsigned int *dst, const unsigned int *src1_base, const unsigned char *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(unsigned int *dst, const unsigned int *src1_base, const unsigned short *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_dec(unsigned int *dst, const unsigned int *src1_base, const unsigned int *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Decrements the values in discrete <src1> addresses by 1 if they are not greater than the corresponding values in <src2> and not equal to 0; otherwise, sets them to the corresponding values in <src2>. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic decrement is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_exch": "void __bang_discrete_atomic_exch(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_exch(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_exch(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_exch(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_exch(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_exch(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_exch(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_exch(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_exch(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_exch(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_exch(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_exch(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_exch(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_exch(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_exch(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_exch(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_exch(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Stores the values in <src2> in discrete <src1> addresses respectively. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic exchange is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_inc": "void __bang_discrete_atomic_inc(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_inc(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_inc(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_inc(unsigned short *dst, const unsigned short *src1_base, const unsigned char *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_inc(unsigned short *dst, const unsigned short *src1_base, const unsigned short *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_inc(unsigned short *dst, const unsigned short *src1_base, const unsigned int *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_inc(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_inc(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_inc(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_inc(unsigned int *dst, const unsigned int *src1_base, const unsigned char *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_inc(unsigned int *dst, const unsigned int *src1_base, const unsigned short *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_inc(unsigned int *dst, const unsigned int *src1_base, const unsigned int *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_inc(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(unsigned short *dst, const unsigned short *src1_base, const unsigned char *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(unsigned short *dst, const unsigned short *src1_base, const unsigned short *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(unsigned short *dst, const unsigned short *src1_base, const unsigned int *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(unsigned int *dst, const unsigned int *src1_base, const unsigned char *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(unsigned int *dst, const unsigned int *src1_base, const unsigned short *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_inc(unsigned int *dst, const unsigned int *src1_base, const unsigned int *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Increments the values in discrete <src1> addresses by 1 if they are smaller than the corresponding values in <src2>; otherwise, sets them to 0. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic increment is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_max": "void __bang_discrete_atomic_max(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_max(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_max(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_max(unsigned short *dst, const unsigned short *src1_base, const unsigned char *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_max(unsigned short *dst, const unsigned short *src1_base, const unsigned short *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_max(unsigned short *dst, const unsigned short *src1_base, const unsigned int *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_max(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_max(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_max(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_max(unsigned int *dst, const unsigned int *src1_base, const unsigned char *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_max(unsigned int *dst, const unsigned int *src1_base, const unsigned short *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_max(unsigned int *dst, const unsigned int *src1_base, const unsigned int *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_max(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_max(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_max(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_max(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_max(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_max(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_max(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(unsigned short *dst, const unsigned short *src1_base, const unsigned char *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(unsigned short *dst, const unsigned short *src1_base, const unsigned short *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(unsigned short *dst, const unsigned short *src1_base, const unsigned int *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(unsigned int *dst, const unsigned int *src1_base, const unsigned char *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(unsigned int *dst, const unsigned int *src1_base, const unsigned short *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(unsigned int *dst, const unsigned int *src1_base, const unsigned int *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Sets the values in discrete <src1> addresses to the greater values between the original values and the corresponding values in <src2>. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_min": "void __bang_discrete_atomic_min(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_min(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_min(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_min(unsigned short *dst, const unsigned short *src1_base, const unsigned char *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_min(unsigned short *dst, const unsigned short *src1_base, const unsigned short *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_min(unsigned short *dst, const unsigned short *src1_base, const unsigned int *src1_offset, const unsigned short *src2, unsigned int size)   void __bang_discrete_atomic_min(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_min(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_min(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_min(unsigned int *dst, const unsigned int *src1_base, const unsigned char *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_min(unsigned int *dst, const unsigned int *src1_base, const unsigned short *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_min(unsigned int *dst, const unsigned int *src1_base, const unsigned int *src1_offset, const unsigned int *src2, unsigned int size)   void __bang_discrete_atomic_min(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_min(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_min(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_min(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_min(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_min(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_min(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(unsigned short *dst, const unsigned short *src1_base, const unsigned char *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(unsigned short *dst, const unsigned short *src1_base, const unsigned short *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(unsigned short *dst, const unsigned short *src1_base, const unsigned int *src1_offset, const unsigned short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(unsigned int *dst, const unsigned int *src1_base, const unsigned char *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(unsigned int *dst, const unsigned int *src1_base, const unsigned short *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(unsigned int *dst, const unsigned int *src1_base, const unsigned int *src1_offset, const unsigned int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Sets the values in discrete <src1> addresses to the smaller values between the original values and the corresponding values in <src2>. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_nan_max": "void __bang_discrete_atomic_nan_max(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_nan_max(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_max(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_max(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_max(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_max(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_max(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Sets the values in discrete <src1> addresses to the greater values between the original values and the corresponding values in <src2>. Stores the original values in discrete <src1> addresses in <dst>. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_nan_min": "void __bang_discrete_atomic_nan_min(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_nan_min(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_min(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_min(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_min(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_min(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_min(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_nan_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Sets the values in discrete <src1> addresses to the smaller values between the original values and the corresponding values in <src2>. Stores the original values in discrete <src1> addresses in <dst>. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_number_max": "void __bang_discrete_atomic_number_max(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_number_max(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_number_max(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_number_max(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_number_max(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_number_max(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_number_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_number_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_number_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_number_max(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_max(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_max(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_max(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_max(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_max(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_max(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Sets the values in discrete <src1> addresses to the greater values between the original values and the corresponding values in <src2>. Stores the original values in discrete <src1> addresses in <dst>. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_number_min": "void __bang_discrete_atomic_number_min(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_number_min(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_number_min(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, unsigned int size)   void __bang_discrete_atomic_number_min(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_number_min(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_number_min(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, unsigned int size)   void __bang_discrete_atomic_number_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_number_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_number_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, unsigned int size)   void __bang_discrete_atomic_number_min(half *dst, const half *src1_base, const unsigned char *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_min(half *dst, const half *src1_base, const unsigned short *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_min(half *dst, const half *src1_base, const unsigned int *src1_offset, const half *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_min(float *dst, const float *src1_base, const unsigned char *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_min(float *dst, const float *src1_base, const unsigned short *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_min(float *dst, const float *src1_base, const unsigned int *src1_offset, const float *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned char *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned short *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_number_min(bfloat16_t *dst, const bfloat16_t *src1_base, const unsigned int *src1_offset, const bfloat16_t *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Sets the values in discrete <src1> addresses to the smaller values between the original values and the corresponding values in <src2>. Stores the original values in discrete <src1> addresses in <dst>. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_or": "void __bang_discrete_atomic_or(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_or(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_or(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_or(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_or(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_or(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_or(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_or(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_or(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_or(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_or(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_or(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Performs bitwise OR on the values in discrete <src1> addresses with <src2> respectively. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic bitwise OR is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "discrete_atomic_xor": "void __bang_discrete_atomic_xor(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_xor(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_xor(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, unsigned int size)   void __bang_discrete_atomic_xor(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_xor(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_xor(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, unsigned int size)   void __bang_discrete_atomic_xor(short *dst, const short *src1_base, const unsigned char *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_xor(short *dst, const short *src1_base, const unsigned short *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_xor(short *dst, const short *src1_base, const unsigned int *src1_offset, const short *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_xor(int *dst, const int *src1_base, const unsigned char *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_xor(int *dst, const int *src1_base, const unsigned short *src1_offset, const int *src2, const void *mask, unsigned int size)   void __bang_discrete_atomic_xor(int *dst, const int *src1_base, const unsigned int *src1_offset, const int *src2, const void *mask, unsigned int size)   Computes the discrete <src1> addresses by adding offsets stored in <src1\\_offset> to <src1\\_base>. Performs bitwise XOR on the values in discrete <src1> addresses with <src2> respectively. Stores the original values in discrete <src1> addresses in <dst>. All steps are inseparable. Parameters* [out] dst: The address of destination operand.\n* [in] src1\\_base: The base address of the first operand.\n* [in] src1\\_offset: The address of the offsets of the first operand.\n* [in] src2: The second operand.\n* [in] mask: The address of mask.\n* [in] size: The number of elements to be computed. Return* void. Remark* <size> must be greater than zero;\n* <src1\\_base> must point to \\_\\_mlu\\_device\\_\\_ address space;\n* The address of <src1\\_base> must be sizeof(type) aligned;\n* <dst>, <src1\\_offset>, <src2> and <mask> must point to \\_\\_nram\\_\\_ address space;\n* The offsets stored in <src1\\_offset> are in bytes, and must be sizeof(type) aligned;\n* <mask> has <size> effective bits, and each bit controls if atomic bitwise XOR is performed on the corresponding element. If no <mask> is given, all elements are computed. Instruction Pipeline* IO. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 592;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_592. Example* None.",
    "matmul": "void __bang_matmul(half *dst, const int4x2_t *src0, const int4x2_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int4x2_t *src0, const int8_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int4x2_t *src0, const int16_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int8_t *src0, const int4x2_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int8_t *src0, const int8_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int8_t *src0, const int16_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int16_t *src0, const int4x2_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int16_t *src0, const int8_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int16_t *src0, const int16_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int4x2_t *src0, const int4x2_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int4x2_t *src0, const int8_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int4x2_t *src0, const int16_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int8_t *src0, const int4x2_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int8_t *src0, const int8_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int8_t *src0, const int16_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int16_t *src0, const int4x2_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int16_t *src0, const int8_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int16_t *src0, const int16_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const half *src0, const half *src1, unsigned int M, unsigned int K, unsigned int N)   void __bang_matmul(float *dst, const float *src0, const float *src1, unsigned int M, unsigned int K, unsigned int N)   void __bang_matmul(float *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int M, unsigned int K, unsigned int N)   void __bang_matmul(int16_t *dst, const int8_t *src0, const int8_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(int16_t *dst, const int16_t *src0, const int8_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(int16_t *dst, const int16_t *src0, const int16_t *src1, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int4x2_t *src0, const int4x2_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int4x2_t *src0, const int8_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int4x2_t *src0, const int16_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int8_t *src0, const int4x2_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int8_t *src0, const int8_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int8_t *src0, const int16_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int16_t *src0, const int4x2_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int16_t *src0, const int8_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(half *dst, const int16_t *src0, const int16_t *src1, const half *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int4x2_t *src0, const int4x2_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int4x2_t *src0, const int8_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int4x2_t *src0, const int16_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int8_t *src0, const int4x2_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int8_t *src0, const int8_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int8_t *src0, const int16_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int16_t *src0, const int4x2_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int16_t *src0, const int8_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   void __bang_matmul(float *dst, const int16_t *src0, const int16_t *src1, const float *src2, unsigned int M, unsigned int K, unsigned int N, int fix_position)   For version without <src2>, use the two-dimensional tensor <src0>[<M>, <K>] to perform a product operation on the two-dimensional tensor <src1>[<K>, <N>] and stores the result in the two-dimensional tensor <dst>[<M>, <N>] , i.e., ( =  \\times ). For version with <src2>, use the two-dimensional tensor <src0>[<M>, <K>] to perform a product operation on the two-dimensional tensor <src1>[<K>, <N>] and add the two-dimensional tensor <src2>[<M>, <N>] and stores the result in the two-dimensional tensor <dst>[<M>, <N>] , i.e., ( =  \\times  + ). See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination matrix which has row-major data layout.\n* [in] src0: The address of source0 matrix which has row-major data layout.\n* [in] src1: The address of source1 matrix which has column-major data layout.\n* [in] src2: The address of source2 matrix which has row-major data layout.\n* [in] M: The height of source0 matrix.\n* [in] K: The width of source0 matrix.\n* [in] N: The width of source1 matrix.\n* [in] fix\\_position: Sum of the scale factor of <src0> and <src1>. Return* void. Remark* <src0> , <src2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src1> must point to \\_\\_wram\\_\\_ address space;\n* <fix\\_position> must be in the range [-127, 127];\n* The address of <src1> must be 32-byte aligned;\n* The matrix <src1> must be reshaped either on host or on device with \\_\\_bang\\_reshape();\n* The address of <dst> , <src0> and <src2> must be 64-byte aligned on (m)tp\\_2xx;\n* <K> \\* sizeof(typeof<src0>) must be 64-byte aligned on (m)tp\\_2xx;\n* <N> must be divisible by 64 on (m)tp\\_2xx;\n* <N> \\* sizeof(typeof<dst>) must be 64-byte aligned on (m)tp\\_2xx;\n* The byte size of <src1> must be 64-byte aligned;\n* On (m)tp\\_3xx and higher, M dimension of <src1> must satisfy the following alignment constraints:\n    + If sizeof(typeof<src0>) / sizeof(typeof<src1>) == 4, K \\* sizeof(typeof<src1>) must be 16-byte aligned;\n    + If sizeof(typeof<src0>) / sizeof(typeof<src1>) == 2, K \\* sizeof(typeof<src1>) must be 32-byte aligned;\n    + Otherwise, K \\* sizeof(typeof<src1>) must be 64-byte aligned;\n* On (m)tp\\_3xx and higher, there is no alignment constraint for parameter <N>, but when allocating memory, the N dimension of memory space of <src1> must be 64 aligned;\n* <M>, <K> and <N> must be greater than 0;\n* <dst> cannot be overlapped with <src0>;\n* <dst> can be overlapped with <src2>. Compatibility between Various Architectures Table 3.31 Data Types Supported on (m)tp\\_2xx | Src0 Type | Src1 Type | Src2 Type | Dst Type |\n| --- | --- | --- | --- |\n| int4 | int4 | half | half |\n| int8_t | int4 | half | half |\n| int8_t | int8_t | half | half |\n| int16_t | int4 | half | half |\n| int16_t | int8_t | half | half |\n| int16_t | int16_t | half | half |\n| int4 | int4 | float | float |\n| int8_t | int4 | float | float |\n| int8_t | int8_t | float | float |\n| int16_t | int4 | float | float |\n| int16_t | int8_t | float | float |\n| int16_t | int16_t | float | float |\n| int4 | int4 | none | half |\n| int8_t | int4 | none | half |\n| int8_t | int8_t | none | half |\n| int16_t | int4 | none | half |\n| int16_t | int8_t | none | half |\n| int16_t | int16_t | none | half |\n| int4 | int4 | none | float |\n| int8_t | int4 | none | float |\n| int8_t | int8_t | none | float |\n| int16_t | int4 | none | float |\n| int16_t | int8_t | none | float |\n| int16_t | int16_t | none | float |\n| int8_t | int8_t | none | int16_t |\n| int16_t | int8_t | none | int16_t |\n| int16_t | int16_t | none | int16_t | Table 3.32 Data Types Supported on mtp\\_372 and mtp\\_592 | Src0 Type | Src1 Type | Src2 Type | Dst Type |\n| --- | --- | --- | --- |\n| int4 | int4 | half | half |\n| int4 | int8_t | half | half |\n| int4 | int16_t | half | half |\n| int8_t | int4 | half | half |\n| int8_t | int8_t | half | half |\n| int8_t | int16_t | half | half |\n| int16_t | int4 | half | half |\n| int16_t | int8_t | half | half |\n| int16_t | int16_t | half | half |\n| int4 | int4 | float | float |\n| int4 | int8_t | float | float |\n| int4 | int16_t | float | float |\n| int8_t | int4 | float | float |\n| int8_t | int8_t | float | float |\n| int8_t | int16_t | float | float |\n| int16_t | int4 | float | float |\n| int16_t | int8_t | float | float |\n| int16_t | int16_t | float | float |\n| int4 | int4 | none | half |\n| int4 | int8_t | none | half |\n| int4 | int16_t | none | half |\n| int8_t | int4 | none | half |\n| int8_t | int8_t | none | half |\n| int8_t | int16_t | none | half |\n| int16_t | int4 | none | half |\n| int16_t | int8_t | none | half |\n| int16_t | int16_t | none | half |\n| int4 | int4 | none | float |\n| int4 | int8_t | none | float |\n| int4 | int16_t | none | float |\n| int8_t | int4 | none | float |\n| int8_t | int8_t | none | float |\n| int8_t | int16_t | none | float |\n| int16_t | int4 | none | float |\n| int16_t | int8_t | none | float |\n| int16_t | int16_t | none | float |\n| half | half | none | float |\n| float | float | none | float |\n| bfloat16_t | bfloat16_t | none | float |\n| int8_t | int8_t | none | int16_t |\n| int16_t | int8_t | none | int16_t |\n| int16_t | int16_t | none | int16_t | Table 3.33 Data Types Supported on tp\\_322 and tp\\_520 | Src0 Type | Src1 Type | Src2 Type | Dst Type |\n| --- | --- | --- | --- |\n| int4 | int4 | half | half |\n| int4 | int8_t | half | half |\n| int4 | int16_t | half | half |\n| int8_t | int4 | half | half |\n| int8_t | int8_t | half | half |\n| int8_t | int16_t | half | half |\n| int16_t | int4 | half | half |\n| int16_t | int8_t | half | half |\n| int16_t | int16_t | half | half |\n| int4 | int4 | float | float |\n| int4 | int8_t | float | float |\n| int4 | int16_t | float | float |\n| int8_t | int4 | float | float |\n| int8_t | int8_t | float | float |\n| int8_t | int16_t | float | float |\n| int16_t | int4 | float | float |\n| int16_t | int8_t | float | float |\n| int16_t | int16_t | float | float |\n| int4 | int4 | none | half |\n| int4 | int8_t | none | half |\n| int4 | int16_t | none | half |\n| int8_t | int4 | none | half |\n| int8_t | int8_t | none | half |\n| int8_t | int16_t | none | half |\n| int16_t | int4 | none | half |\n| int16_t | int8_t | none | half |\n| int16_t | int16_t | none | half |\n| int4 | int4 | none | float |\n| int4 | int8_t | none | float |\n| int4 | int16_t | none | float |\n| int8_t | int4 | none | float |\n| int8_t | int8_t | none | float |\n| int8_t | int16_t | none | float |\n| int16_t | int4 | none | float |\n| int16_t | int8_t | none | float |\n| int16_t | int16_t | none | float |\n| int8_t | int8_t | none | int16_t |\n| int16_t | int8_t | none | int16_t |\n| int16_t | int16_t | none | int16_t | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 4.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "active_abs": "void __bang_active_abs(half *dst, const half *src, unsigned int elem_count)   void __bang_active_abs(float *dst, const float *src, unsigned int elem_count)   This function computes the absolute value of each element in vector <src> and saves the result to vector <dst>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: 0;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ space;\n* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The range of <src> operand is ([-65504, 65504]) when type is half, and ([-3.4 * 10^{38}, 3.4 * 10^{38}]) when type is float. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_cos": "void __bang_active_cos(half *dst, const half *src, unsigned int elem_count)   void __bang_active_cos(float *dst, const float *src, unsigned int elem_count)   Applies active (cosine) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: within 0.01;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The element value of <src> is in the range [-2π, 2π] radian;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_exp": "void __bang_active_exp(half *dst, const half *src, unsigned int elem_count)   void __bang_active_exp(float *dst, const float *src, unsigned int elem_count)   Applies active (exponent) operation on source operand <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The result is 5.96e-8, when the element value of <src> is less than -7.75;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is half, the relative error refer to the table Relative Error of __bang_active_exp(half) for accuracy information;\n* When the data type of the elements of <src> is float, the element value is in the range [-3.4e38, 11]， the average relative error is within 0.01; Table 3.34 Relative Error of \\_\\_bang\\_active\\_exp(half) | Interval | Maximum absolute error | Maximum relative error | Average relative error |\n| --- | --- | --- | --- |\n| [-65504, -7.75) | 0.000426 | N/A | N/A |\n| [-7.75, -5.12] | N/A | 0.003 | N/A |\n| (-5.12, -0) | N/A | 0.008 | N/A |\n| [-0, +0] | 0 | N/A | N/A |\n| (0, 0.003] | N/A | 0.003 | N/A |\n| (0.003, 9.12] | N/A | 0.01 | N/A |\n| (9.12, 10.3] | N/A | 0.011 | N/A |\n| (10.3, 11] | N/A | 0.05 | N/A |\n| [-15.5，11] | N/A | N/A | 0.00687 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_exp_less_0": "void __bang_active_exp_less_0(half *dst, const half *src, unsigned int elem_count)   void __bang_active_exp_less_0(float *dst, const float *src, unsigned int elem_count)   Applies active (exponent) operation on source operand <src> when the value of <src> is less than 0. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The result is 5.96e-8, when the element value of <src> is less than -15.5;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is float, the element value is in the range [-3.4e38, 0); when the data type of the elements of <src> is half, the element value is in the range [-65504, 0);\n* When the data type of the elements of <src> is float, the average relative error is within 0.003; when the data type of the elements of <src> is half, the average relative error is within 0.01. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_exphp": "void __bang_active_exphp(half *dst, const half *src, unsigned int elem_count)   void __bang_active_exphp(float *dst, const float *src, unsigned int elem_count)   Applies high precision active (exponent) operation on source operand <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is half, the relative error refer to the table Relative Error of __bang_active_exphp(half) for accuracy information;\n* When the data type of the elements of <src> is float, the element value is in the range [-3.4e38, 16];\n* When the element value of <src> is less than -15.5 for the data type of float, the result is 3e-7; when the element value of <src> is less than -7.75 for the data type of half, the result is 5.96e-8;\n* When the data type of the elements of <src> is float, the average relative error is within 0.003; Table 3.35 Relative Error of \\_\\_bang\\_active\\_exphp(half) | Interval | Maximum absolute error | Maximum relative error | Average relative error |\n| --- | --- | --- | --- |\n| [-65504, -7.75) | 0.000426 | N/A | N/A |\n| [-7.75, -5.12] | N/A | 0.003 | N/A |\n| (-5.12, -0) | N/A | 0.008 | N/A |\n| [-0, +0] | 0 | N/A | N/A |\n| (0, 0.003] | N/A | 0.003 | N/A |\n| (0.003, 9.12] | N/A | 0.01 | N/A |\n| (9.12, 10.3] | N/A | 0.011 | N/A |\n| (10.3, 11] | N/A | 0.05 | N/A |\n| [-15.5，11] | N/A | N/A | 0.00687 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_gelu": "void __bang_active_gelu(half *dst, const half *src, unsigned int elem_count)   void __bang_active_gelu(float *dst, const float *src, unsigned int elem_count)   Applies active (gelu) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: within 0.003;\n* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is half, the relative error refer to the table Relative Error of __bang_active_gelu(half) for accuracy information;\n* When the data type of the elements of <src> is float, the element value is in the range [-3.4e38, 3.4e38], the average relative error is within 0.003;\n* When the element value of <src> is less than -3.875, the result is -5.96e-8; Table 3.36 Relative Error of \\_\\_bang\\_active\\_gelu(half) | Interval | Maximum absolute error | Maximum relative error | Average relative error |\n| --- | --- | --- | --- |\n| [-65504, -3.875] | 0.0001258 | N/A | N/A |\n| (-3.875, -2.91] | 0.0000653 | N/A | N/A |\n| (-2.91, -1.69] | N/A | 0.0108 | N/A |\n| (-1.69, -0.627] | N/A | 0.003 | N/A |\n| (-0.627, -0.134] | N/A | 0.01 | N/A |\n| (-0.137, -0) | 0.001571 | N/A | N/A |\n| [-0, +0] | 0 | N/A | N/A |\n| (0, 0.130) | 0.001556 | N/A | N/A |\n| (0.130, 0.5] | N/A | 0.01 | N/A |\n| (0.5, 65504] | N/A | 0.003 | N/A |\n| [-4.85, 4.85] | N/A | N/A | 0.0023 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_gelup": "void __bang_active_gelup(half *dst, const half *src, unsigned int elem_count)   void __bang_active_gelup(float *dst, const float *src, unsigned int elem_count)   Applies active (gelup) operation on <src>, which has higher precision than active(gelu) does. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The result is -5.96e-8, when the element value of <src> is less than -3.875;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is half, the relative error refer to the table Relative Error of __bang_active_gelup(half) for accuracy information;\n* When the data type of the elements of <src> is float, the element values of <src> are in the range [-3.4e38, 3.4e38];\n* When the data type of the elements of <src> is float, the average relative error rate is within 0.003. Despite having higher average relative error than normal gelu operation, it has higher precision on critical interval; Table 3.37 Relative Error of \\_\\_bang\\_active\\_gelup(half) | Interval | Maximum absolute error | Maximum relative error | Average relative error |\n| --- | --- | --- | --- |\n| [-65504, -3.875] | 0.0001258 | N/A | N/A |\n| (-3.875, -2.68] | 0.0001678 | N/A | N/A |\n| (-2.68, -2.10] | N/A | 0.0108 | N/A |\n| (-2.10, -0.347] | N/A | 0.003 | N/A |\n| (-0.347, -0.154] | N/A | 0.01 | N/A |\n| (-0.154, -0) | 0.001221 | N/A | N/A |\n| [-0, +0] | 0 | N/A | N/A |\n| (0, 0.453) | 0.003537 | N/A | N/A |\n| [0.453, 1.45) | N/A | 0.0112 | N/A |\n| [1.45, 65504] | N/A | 0.003 | N/A |\n| [-4.85, 4.85] | N/A | N/A | 0.00411 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_log": "void __bang_active_log(half *dst, const half *src, unsigned int elem_count)   void __bang_active_log(float *dst, const float *src, unsigned int elem_count)   Applies active (log base e) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: within 0.01;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The element value of <src> is in the range [6.1e-5, 63484];\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_loghp": "void __bang_active_loghp(half *dst, const half *src, unsigned int elem_count)   void __bang_active_loghp(float *dst, const float *src, unsigned int elem_count)   Applies high precision active (log base e) operation on source operand <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is half, the relative error refer to the table Relative Error of __bang_active_loghp(half) for accuracy information;\n* When the data type of the elements of <src> is float, the element value is in the range [7.2e-9, 507903];\n* When the data type of the elements of <src> is float, the average relative error is within 0.001; Table 3.38 Relative Error of \\_\\_bang\\_active\\_loghp(half) | Interval | Maximum absolute error | Maximum relative error | Average relative error |\n| --- | --- | --- | --- |\n| [0.0000611, 0.000122] | N/A | 0.005 | N/A |\n| (0.000122, 0.0619] | N/A | 0.003 | N/A |\n| (0.0619, 0.325] | N/A | 0.01 | N/A |\n| (0.325, 2.64] | 0.0121 | N/A | N/A |\n| (2.64, 8.48] | N/A | 0.01 | N/A |\n| (8.48, 18000] | N/A | 0.005 | N/A |\n| (18000, 65504] | N/A | 0.003 | N/A |\n| [0.0000611, 65504] | N/A | N/A | 0.00145 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_pow2": "void __bang_active_pow2(half *dst, const half *src, unsigned int elem_count)   void __bang_active_pow2(float *dst, const float *src, unsigned int elem_count)   Applies active (pow2) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: 0;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the element of <src> is half , the element values are integers in the range [-24.0, 15.0] , such as -24.0, -23.0, ... 0.0, 1.0, 2.0, ... 15.0 ; when the data type of the element of <src> is float, the element values are integers in the range [-31.0, 31.0], such as -31.0, -30.0, ... 0.0, 1.0, 2.0, ... 31.0. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_recip": "void __bang_active_recip(half *dst, const half *src, unsigned int elem_count)   void __bang_active_recip(float *dst, const float *src, unsigned int elem_count)   Applies active (reciprocal) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information.  Fig. 3.9 Reciprocal Process Hint Recip means reciprocal. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The element values of <src> are in the range [0.0078125, 65472];\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is float, the average relative error is within 0.003; when the data type of the elements of <src> is half, the average relative error is within 0.01. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "active_recip_greater_1": "void __bang_active_recip_greater_1(half *dst, const half *src, unsigned int elem_count)   void __bang_active_recip_greater_1(float *dst, const float *src, unsigned int elem_count)   Applies active (reciprocal) operation on <src> when the value of <src> is greater than 1. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Hint Recip means reciprocal. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The element values of <src> are in the range [1, 63487];\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is float, the average relative error is within 0.003; when the data type of the elements of <src> is half, the average relative error is within 0.01. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_reciphp": "void __bang_active_reciphp(half *dst, const half *src, unsigned int elem_count)   void __bang_active_reciphp(float *dst, const float *src, unsigned int elem_count)   Applies high precision active (reciprocal) operation on source operand <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is half, the relative error refer to the table Relative Error of __bang_active_reciphp(half) for accuracy information;\n* When the data type of the elements of <src> is float, the element value is in the range [2.2205e-16, 2e6], and the average relative error is within 0.0004; Table 3.39 Relative Error of \\_\\_bang\\_active\\_reciphp(half) | Interval | Maximum absolute error | Maximum relative error | Average relative error |\n| --- | --- | --- | --- |\n| [0.00391, 16] | N/A | 0.003 | N/A |\n| (16, 884] | N/A | 0.01 | N/A |\n| (884, 65504] | 0.000134 | N/A | N/A |\n| [0.00391, 65504] | N/A | N/A | 0.000325 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_relu": "void __bang_active_relu(half *dst, const half *src, unsigned int elem_count)   void __bang_active_relu(float *dst, const float *src, unsigned int elem_count)   Applies active (relu) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: 0;\n* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The range of <src> operand is ([-65504, 65504]) when type is half, and ([-3.4 * 10^{38}, 3.4 * 10^{38}]) when type is float. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_rsqrt": "void __bang_active_rsqrt(half *dst, const half *src, unsigned int elem_count)   void __bang_active_rsqrt(float *dst, const float *src, unsigned int elem_count)   Applies active (rsqrt) operation on <src>, ( = 1 \\div sqrt{}). The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: within 0.01;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The element value of <src> is in the range [0.005, 63487];\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_rsqrthp": "void __bang_active_rsqrthp(half *dst, const half *src, unsigned int elem_count)   void __bang_active_rsqrthp(float *dst, const float *src, unsigned int elem_count)   Applies high precision active (rsqrt) operation on source operand <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is half, the relative error refer to the table Relative Error of __bang_active_rsqrthp(half) for accuracy information;\n* When the data type of the elements of <src> is float, the element value is in the range [0.000367, 1e6], the average relative error is within 0.0005; Table 3.40 Relative Error of \\_\\_bang\\_active\\_rsqrthp(half) | Interval | Maximum absolute error | Maximum relative error | Average relative error |\n| --- | --- | --- | --- |\n| [0.000367, 8.05] | N/A | 0.003 | N/A |\n| (8.05, 6972] | N/A | 0.01 | N/A |\n| (6972, 65504] | 0.000865 | N/A | N/A |\n| [0.000367, 65504] | N/A | N/A | 0.00043566 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_sigmoid": "void __bang_active_sigmoid(half *dst, const half *src, unsigned int elem_count)   void __bang_active_sigmoid(float *dst, const float *src, unsigned int elem_count)   Applies active (sigmoid) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: within 0.01;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The range of <src> operand is ([-65504, 65504]) when type is half, and ([-3.4 * 10^{38}, 3.4 * 10^{38}]) when type is float;\n* The result is 0, when the element value of <src> is less than -7.75; the result is 1, when the element value of <src> is greater than 7.75. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_sign": "void __bang_active_sign(half *dst, const half *src, unsigned int elem_count)   void __bang_active_sign(float *dst, const float *src, unsigned int elem_count)   Applies active (sign) operation on <src>. If ( \\ge 0.0), then, stores 1.0 in <dst>; otherwise, stores -1.0 in <dst>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: 0;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the element value of <src> is -0 or +0, the corresponding result is 1;\n* When the data type of the elements of <src> is float, the element value is in the range [-3.4e38, 3.4e38]; when the data type of the elements of <src> is half, the element value is in the range [-65504, 65504]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_sin": "void __bang_active_sin(half *dst, const half *src, unsigned int elem_count)   void __bang_active_sin(float *dst, const float *src, unsigned int elem_count)   Applies active (sine) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The element value of <src> is in the range [-2π, 2π] radian;\n* Average relative error: within 0.01;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_sqrt": "void __bang_active_sqrt(half *dst, const half *src, unsigned int elem_count)   void __bang_active_sqrt(float *dst, const float *src, unsigned int elem_count)   Applies active (sqrt) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: within 0.01;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The element value of <src> is in the range [0, 63487];\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_sqrthp": "void __bang_active_sqrthp(half *dst, const half *src, unsigned int elem_count)   void __bang_active_sqrthp(float *dst, const float *src, unsigned int elem_count)   Applies high precision active (exponent) operation on source operand <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is half, the relative error refer to the table Relative Error of __bang_active_sqrthp(half) for accuracy information;\n* When the data type of the elements of <src> is float, the element value is in the range [0, 677268], the average relative error is within 0.003; Table 3.41 Relative Error of \\_\\_bang\\_active\\_sqrthp(half) | Interval | Maximum absolute error | Maximum relative error | Average relative error |\n| --- | --- | --- | --- |\n| [0, 0.000123] | 0.0025235 | N/A | N/A |\n| (0.000123, 0.000244] | N/A | 0.01 | N/A |\n| (0.000244, 0.0189] | N/A | 0.003 | N/A |\n| (0.0189, 0.0501] | 0.003406 | N/A | N/A |\n| (0.0501, 0.0813] | N/A | 0.01 | N/A |\n| (0.0813, 8488] | N/A | 0.003 | N/A |\n| (8488, 64704] | N/A | 0.01 | N/A |\n| (64704, 65504] | N/A | 0.01539 | N/A |\n| [0, 65504] | N/A | N/A | 0.00225 | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "active_tanh": "void __bang_active_tanh(half *dst, const half *src, unsigned int elem_count)   void __bang_active_tanh(float *dst, const float *src, unsigned int elem_count)   Applies active (tanh) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* Average relative error: within 0.01;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* When the data type of the elements of <src> is float, the element value is in the range [-3.4e38, 3.4e38]; when the data type of the elements of <src> is half, the element value is in the range [-65504, 65504]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor3_cos": "void __bang_taylor3_cos(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor3_cos(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor3 (cos) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.00001 for half and float type respectively;\n* Refer to the following tables for special value of \\_\\_bang\\_taylor3\\_cos; Table 3.42 Special Value of \\_\\_bang\\_taylor3\\_cos(half) | Input | (-NaN) | (-INF) | [-65504, -7.75] | [7.75, 65504] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | +0.0 | +0.0 | (+NaN) | (+NaN) | Table 3.43 Special Value of \\_\\_bang\\_taylor3\\_cos(float) | Input | (-NaN) | (-INF) | [-3.4e38, -7.75] | [7.75, 3.4e38] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | +0.0 | +0.0 | (+NaN) | (+NaN) | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor3_sigmoid": "void __bang_taylor3_sigmoid(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor3_sigmoid(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor3 (sigmoid) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for half and float type respectively;\n* Refer to the following tables for special value of \\_\\_bang\\_taylor3\\_\\_sigmoid; Table 3.44 Special Value of \\_\\_bang\\_taylor3\\_sigmoid(half) | Input | (-NaN) | (-INF) | [-65504, -7.75] | [7.75, 65504] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | 5.96e-8 | 5.96e-8 | 5.96e-8 | 1 | 1 | 1 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | 5.96e-8 | 1 | (+NaN) | (+NaN) | Table 3.45 Special Value of \\_\\_bang\\_taylor3\\_sigmoid(float) | Input | (-NaN) | (-INF) | [-3.4e38, -7.75] | [7.75, 3.4e38] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | 1.4e-45 | 1.4e-45 | 1.4e-45 | 0.99999994 | 0.99999994 | 0.99999994 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | 1.4e-45 | 0.99999994 | (+NaN) | (+NaN) | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor3_sin": "void __bang_taylor3_sin(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor3_sin(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor3 (sine) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.00001 for half and float type respectively;\n* Refer to the following tables for special value of \\_\\_bang\\_taylor3\\_sin; Table 3.46 Special Value of \\_\\_bang\\_taylor3\\_sin(half) | Input | (-NaN) | (-INF) | [-65504, -7.75] | [7.75, 65504] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | +0.0 | +0.0 | (+NaN) | (+NaN) | Table 3.47 Special Value of \\_\\_bang\\_taylor3\\_sin(float) | Input | (-NaN) | (-INF) | [-3.4e38, -7.75] | [7.75, 3.4e38] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | +0.0 | +0.0 | (+NaN) | (+NaN) | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor3_softplus": "void __bang_taylor3_softplus(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor3_softplus(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor3 (softplus) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for half and float type respectively;\n* Refer to the following tables for special value of \\_\\_bang\\_taylor3\\_softplus; Table 3.48 Special Value of \\_\\_bang\\_taylor3\\_softplus(half) | Input | (-NaN) | (-INF) | [-65504, -7.75] | [7.75, 65504] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | 0.000215292 | 0.000215292 | 0.000215292 | y = x | 65504 | 65504 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | 0.000215292 | y = x | (+NaN) | (+NaN) | Table 3.49 Special Value of \\_\\_bang\\_taylor3\\_softplus(float) | Input | (-NaN) | (-INF) | [-3.4e38, -7.75] | [7.75, 3.4e38] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | 0.0002153\n2489 | 0.0002153\n2489 | 0.0002153\n2489 | y = x +\n4.76837e-7 | 3.4e38 | 3.4e38 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | 0.0002153\n2489 | y = x +\n4.76837e-7 | (+NaN) | (+NaN) | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor3_tanh": "void __bang_taylor3_tanh(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor3_tanh(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor3 (tanh) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> must be in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.00001 for half and float type respectively. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor4_cos": "void __bang_taylor4_cos(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor4_cos(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor4 (cos) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.000001 for half and float type respectively;\n* Refer to the following tables for special value of \\_\\_bang\\_taylor4\\_cos; Table 3.50 Special Value of \\_\\_bang\\_taylor4\\_cos(half) | Input | (-NaN) | (-INF) | [-65504, -7.75] | [7.75, 65504] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | +0.0 | +0.0 | (+NaN) | (+NaN) | Table 3.51 Special Value of \\_\\_bang\\_taylor4\\_cos(float) | Input | (-NaN) | (-INF) | [-3.4e38, -7.75] | [7.75, 3.4e38] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | +0.0 | +0.0 | (+NaN) | (+NaN) | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor4_sigmoid": "void __bang_taylor4_sigmoid(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor4_sigmoid(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor4 (sigmoid) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* The value of elements in <src> is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.0000001 for half and float type respectively;\n* Refer to the following tables for special value of \\_\\_bang\\_taylor4\\_sigmoid; Table 3.52 Special Value of \\_\\_bang\\_taylor4\\_sigmoid(half) | Input | (-NaN) | (-INF) | [-65504, -7.75] | [7.75, 65504] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | 5.96e-8 | 5.96e-8 | 5.96e-8 | 1 | 1 | 1 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | 5.96e-8 | 1 | (+NaN) | (+NaN) | Table 3.53 Special Value of \\_\\_bang\\_taylor4\\_sigmoid(float) | Input | (-NaN) | (-INF) | [-3.4e38, -7.75] | [7.75, 3.4e38] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | 1.4e-45 | 1.4e-45 | 1.4e-45 | 0.99999994 | 0.99999994 | 0.99999994 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | 1.4e-45 | 0.99999994 | (+NaN) | (+NaN) | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor4_sin": "void __bang_taylor4_sin(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor4_sin(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor4 (sine) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.000001 for half and float type respectively;\n* Refer to the following tables for special value of \\_\\_bang\\_taylor4\\_sin; Table 3.54 Special Value of \\_\\_bang\\_taylor4\\_sin(half) | Input | (-NaN) | (-INF) | [-65504, -7.75] | [7.75, 65504] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | +0.0 | +0.0 | (+NaN) | (+NaN) | Table 3.55 Special Value of \\_\\_bang\\_taylor4\\_sin(float) | Input | (-NaN) | (-INF) | [-3.4e38, -7.75] | [7.75, 3.4e38] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | +0.0 | +0.0 | (+NaN) | (+NaN) | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor4_softplus": "void __bang_taylor4_softplus(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor4_softplus(float *dst, float *src, float *aux1, float *aux2, unsigned int elem_count)   Applies active with taylor4 (softplus) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.0000001 for half and float type respectively;\n* Refer to the following tables for special value of \\_\\_bang\\_taylor4\\_softplus; Table 3.56 Special Value of \\_\\_bang\\_taylor4\\_softplus(half) | Input | (-NaN) | (-INF) | [-65504, -7.75] | [7.75, 65504] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | 0.000215292 | 0.000215292 | 0.000215292 | y = x | 65504 | 65504 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | 0.000215292 | y = x | (+NaN) | (+NaN) | Table 3.57 Special Value of \\_\\_bang\\_taylor4\\_softplus(float) | Input | (-NaN) | (-INF) | [-3.4e38, -7.75] | [7.75, 3.4e38] | (+INF) | (+NaN) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Output on (m)tp\\_2xx or earlier | 0.0002153\n2489 | 0.0002153\n2489 | 0.0002153\n2489 | y = x +\n4.76837e-7 | 3.4e38 | 3.4e38 |\n| Output on (m)tp\\_3xx or higher | (+NaN) | (+NaN) | 0.0002153\n2489 | y = x +\n4.76837e-7 | (+NaN) | (+NaN) | Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "taylor4_tanh": "void __bang_taylor4_tanh(half *dst, const half *src, const half *aux1, const half *aux2, unsigned int elem_count)   void __bang_taylor4_tanh(float *dst, const float *src, const float *aux1, const float *aux2, unsigned int elem_count)   Applies active with taylor4 (tanh) operation on <src>. The function requires auxiliary \\_\\_nram\\_\\_ space internally. See the table Activation Table Space for the Activation Function for more information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] aux1: The auxiliary \\_\\_nram\\_\\_ space 1.\n* [in] aux2: The auxiliary \\_\\_nram\\_\\_ space 2.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> , <aux1> and <aux2> must have the same size as <src>;\n* <src> , <aux1> , <aux2> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> , <aux1> , <aux2> and <src> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src>, <aux1>, <aux2> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The value of elements in <src> must be in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for half and float type respectively. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "band": "void __bang_band(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_band(short *dst, const short *src0, const short *src1, unsigned int elem_count)   Applies bit-wise AND operation on two vectors. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of first source vector.\n* [in] src1: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src0>;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int and short are supported on (m)tp\\_3xx or higher;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_band instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "band_scalar": "void __bang_band_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_band_scalar(float *dst, const float *src, float value, unsigned int elem_count)   void __bang_band_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_band_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_band_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_band_scalar(char *dst, const char *src, char value, unsigned int elem_count)   This function performs bit-wise AND operation between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int, short and char are not supported on tp\\_520;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bnot": "void __bang_bnot(int *dst, const int *src, unsigned int elem_count)   void __bang_bnot(short *dst, const short *src, unsigned int elem_count)   Applies bit-wise NOT operation on a vector. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* int and short are supported on (m)tp\\_3xx or higher;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_bnot instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "bor": "void __bang_bor(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_bor(short *dst, const short *src0, const short *src1, unsigned int elem_count)   Applies bit-wise OR operation on two vectors. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of first source vector.\n* [in] src1: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src0>;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int and short are supported on (m)tp\\_3xx or higher;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_bor instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "bor_scalar": "void __bang_bor_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_bor_scalar(float *dst, const float *src, float value, unsigned int elem_count)   void __bang_bor_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_bor_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_bor_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_bor_scalar(char *dst, const char *src, char value, unsigned int elem_count)   This function performs bit-wise OR operation between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int, short and char are not supported on tp\\_520;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_band_scalar for more details.",
    "bxor": "void __bang_bxor(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_bxor(short *dst, const short *src0, const short *src1, unsigned int elem_count)   Applies bit-wise XOR operation on two vectors. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of first source vector.\n* [in] src1: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src0>;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int and short are supported on (m)tp\\_3xx or higher;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_bxor instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "bxor_scalar": "void __bang_bxor_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_bxor_scalar(float *dst, const float *src, float value, unsigned int elem_count)   void __bang_bxor_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_bxor_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_bxor_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_bxor_scalar(char *dst, const char *src, char value, unsigned int elem_count)   This function performs bit-wise XOR operation between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int, short and char are not supported on tp\\_520;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_band_scalar for more details.",
    "cycle_band": "void __bang_cycle_band(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_band(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies bit-wise AND operation with the corresponding element in <seg>. The result is assigned to <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int and short are supported on (m)tp\\_3xx or higher;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322;\n* This function was deprecated from CNCC v4.0.0. Use corresponding char function instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_bor": "void __bang_cycle_bor(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_bor(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies bit-wise OR operation with the corresponding element in <seg>. The result is assigned to <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int and short are supported on (m)tp\\_3xx or higher;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322;\n* This function was deprecated from CNCC v4.0.0. Use corresponding char function instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_bxor": "void __bang_cycle_bxor(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_bxor(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies bit-wise XOR operation with the corresponding element in <seg>. The result is assigned to <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int and short are supported on (m)tp\\_3xx or higher;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322;\n* This function was deprecated from CNCC v4.0.0. Use __bang_cycle_bxor instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "argmax": "void __bang_argmax(half *dst, const half *src, unsigned int elem_count)   void __bang_argmax(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_argmax(float *dst, const float *src, unsigned int elem_count)   Finds the maximum value and its corresponding index in <src> vector except NaN. The result is composed of two parts. The first part is the maximum value of corresponding type, and the second part is the index of the first maximum value position in <src> vector, whose data type is unsigned int. The maximum value and index are stored continuously in <dst>. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "argmin": "void __bang_argmin(half *dst, const half *src, unsigned int elem_count)   void __bang_argmin(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_argmin(float *dst, const float *src, unsigned int elem_count)   Finds the minimum value and its corresponding index in <src> vector except NaN. The result is composed of two parts. The first part is the minimum value of corresponding data type, and the second part is the index of the first minimum value position in <src> vector, whose data type is unsigned int. The minimum value and index are stored continuously. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "cycle_eq": "void __bang_cycle_eq(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_eq(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_eq(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_eq(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_eq(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_eq(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part and the corresponding element in <seg> are equal. The result is assigned to <dst>. If the element of <src> is equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short and char. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "cycle_equ": "void __bang_cycle_equ(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_equ(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_equ(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part and the corresponding element in <seg> are unordered or equal. The result is assigned to <dst>. If the element of <src> is unordered or equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "cycle_ge": "void __bang_cycle_ge(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ge(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ge(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ge(unsigned int *dst, const unsigned int *src, const unsigned int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ge(unsigned short *dst, const unsigned short *src, const unsigned short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ge(unsigned char *dst, const unsigned char *src, const unsigned char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ge(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ge(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ge(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part is greater than or equal to the corresponding element in <seg>. The result is assigned to <dst>. If the element of <src> is greater than or equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short, char, unsigned int, unsigned short and unsigned char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short, char, unsigned int, unsigned short and unsigned char. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_geu": "void __bang_cycle_geu(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_geu(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_geu(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part is unordered or greater than or equal to the corresponding element in <seg>. The result is assigned to <dst>. If the element of <src> is unordered or greater than or equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_cycle_equ for more details.",
    "cycle_gt": "void __bang_cycle_gt(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_gt(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_gt(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part is greater than the corresponding element in <seg>. The result is assigned to <dst>. If the element of <src> is greater than <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_gtu": "void __bang_cycle_gtu(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_gtu(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_gtu(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part is unordered or greater than the corresponding element in <seg>. The result is assigned to <dst>. If the element of <src> is unordered or greater than <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_cycle_equ for more details.",
    "cycle_le": "void __bang_cycle_le(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_le(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_le(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part is less than or equal to the corresponding element in <seg>. The result is assigned to <dst>. If the element of <src> is less than or equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_leu": "void __bang_cycle_leu(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_leu(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_leu(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part is unordered or less than or equal to the corresponding element in <seg>. The result is assigned to <dst>. If the element of <src> is unordered or less than or equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_cycle_equ for more details.",
    "cycle_lt": "void __bang_cycle_lt(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_lt(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_lt(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_lt(unsigned int *dst, const unsigned int *src, const unsigned int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_lt(unsigned short *dst, const unsigned short *src, const unsigned short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_lt(unsigned char *dst, const unsigned char *src, const unsigned char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_lt(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_lt(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_lt(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part is less than the corresponding element in <seg>. The result is assigned to <dst>. If the element of <src> is less than <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short, char, unsigned int, unsigned short and unsigned char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short, char, unsigned int, unsigned short and unsigned char;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_ltu": "void __bang_cycle_ltu(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ltu(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ltu(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part is unordered or less than the corresponding element in <seg>. The result is assigned to <dst>. If the element of <src> is unordered or less than <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_cycle_equ for more details.",
    "cycle_maxequal": "void __bang_cycle_maxequal(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maxequal(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maxequal(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maxequal(unsigned int *dst, const unsigned int *src, const unsigned int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maxequal(unsigned short *dst, const unsigned short *src, const unsigned short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maxequal(unsigned char *dst, const unsigned char *src, const unsigned char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maxequal(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maxequal(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maxequal(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies maxequal operation (select the maximum value) with the corresponding element in <seg>. The result is assigned to <dst>. If one of the elements being compared is a NaN, then the element in <src> is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short, char, unsigned int, unsigned short and unsigned char;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* int, short, char, unsigned int, unsigned short and unsigned char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "cycle_maximum": "void __bang_cycle_maximum(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maximum(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_maximum(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies max operation (select the maximum value) with the corresponding element in <seg>. The result is assigned to <dst>. If both of the elements being compared are NaN, then NaN is returned. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "cycle_minequal": "void __bang_cycle_minequal(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minequal(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minequal(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minequal(unsigned int *dst, const unsigned int *src, const unsigned int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minequal(unsigned short *dst, const unsigned short *src, const unsigned short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minequal(unsigned char *dst, const unsigned char *src, const unsigned char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minequal(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minequal(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minequal(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies minequal operation (select the minimum value) with the corresponding element in <seg>. The result is assigned to <dst>. If one of the elements being compared is a NaN, then the element in <src> is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short, char, unsigned int, unsigned short and unsigned char;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* int, short, char, unsigned int, unsigned short and unsigned char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_minimum": "void __bang_cycle_minimum(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minimum(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_minimum(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies min operation (select the minimum value) with the corresponding element in <seg>. The result is assigned to <dst>. If both of the elements being compared are NaN, then NaN is returned. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "cycle_nan_maximum": "void __bang_cycle_nan_maximum(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_nan_maximum(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_nan_maximum(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies max operation (select the maximum value) with the corresponding element in <seg>. The result is assigned to <dst>. If one of the elements being compared is a NaN, then that element is returned. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "cycle_nan_minimum": "void __bang_cycle_nan_minimum(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_nan_minimum(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_nan_minimum(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part applies min operation (select the minimum value) with the corresponding element in <seg>. The result is assigned to <dst>. If one of the elements being compared is a NaN, then that element is returned. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "cycle_ne": "void __bang_cycle_ne(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ne(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ne(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ne(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ne(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_ne(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part and the corresponding element in <seg> are NOT equal. The result is assigned to <dst>. If the element of <src> is not equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short and char;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_neu": "void __bang_cycle_neu(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_neu(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_neu(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts, then judges whether each element in each part and the corresponding element in <seg> are unordered or not equal. The result is assigned to <dst>. If the element of <src> is unordered or not equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <dst> can be overlapped with <src>;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_cycle_equ for more details.",
    "eq": "void __bang_eq(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_eq(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_eq(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_eq(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_eq(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_eq(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs equality comparison with <src0> and <src1> and saves the result in <dst>. If the element of <src0> and the element of <src1> are equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "eq_bitindex": "void __bang_eq_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_eq_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_eq_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs equality comparison with <src0> and <src1> element-wisely. If the two elements are equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.\nThe comparison process is illustrated in the figure below, the comparison result between the first element <element0> of <src0> and the first element <element0> of <src1> will be saved in <bit0> of <dst> . The other elements do the same comparison in turn. Fig. 3.10 The Calculation Process of Half Type \\_\\_bang\\_eq\\_bitindex Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be divisible by 512 on (m)tp\\_2xx;\n* <elem\\_count> must be divisible by 8 on (m)tp\\_3xx or higher;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "eq_scalar": "void __bang_eq_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_eq_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_eq_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_eq_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_eq_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_eq_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function performs equality comparison with <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If the element of <src> and <value> are equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* int, short and char are not supported on tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "equ": "void __bang_equ(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_equ(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_equ(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs unordered or equality comparison with <src0> and <src1> and saves the result in <dst>. If the element of <src0> and the element of <src1> are unordered or equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "equ_bitindex": "void __bang_equ_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_equ_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_equ_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs unordered or equality comparison with <src0> and <src1> element-wisely. If the two elements are unordered or equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero and divisible by 8. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "equ_scalar": "void __bang_equ_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_equ_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_equ_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function performs unordered or equality comparison with <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If the element of <src> and <value> are unordered or equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "ge": "void __bang_ge(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_ge(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_ge(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_ge(unsigned int *dst, const unsigned int *src0, const unsigned int *src1, unsigned int elem_count)   void __bang_ge(unsigned short *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_ge(unsigned char *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_ge(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_ge(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_ge(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely to determine whether the element in <src0> is greater than or equal to that in <src1> and saves the result in <dst>. If the element of <src0> is greater than or equal to the element of <src1>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first vector.\n* [in] src1: The address of the second vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short, char, unsigned int, unsigned short and unsigned char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq for more details.",
    "ge_bitindex": "void __bang_ge_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_ge_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_ge_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely, if the element of <src0> is greater than or equal to that of <src1>, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.\nThe comparison process is illustrated in the figure below, the comparison result between the first element <element0> of <src0> and the first element <element0> of <src1> will be saved in <bit0> of <dst> . The other elements do the same comparison in turn. Fig. 3.11 The Calculation Process of Half Type \\_\\_bang\\_ge\\_bitindex Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be divisible by 512 on (m)tp\\_2xx;\n* <elem\\_count> must be divisible by 8 on (m)tp\\_3xx or higher;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq_bitindex for more details.",
    "ge_scalar": "void __bang_ge_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_ge_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_ge_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_ge_scalar(unsigned int *dst, const unsigned int *src, unsigned int value, unsigned int elem_count)   void __bang_ge_scalar(unsigned short *dst, const unsigned short *src, unsigned short value, unsigned int elem_count)   void __bang_ge_scalar(unsigned char *dst, const unsigned char *src, unsigned char value, unsigned int elem_count)   void __bang_ge_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_ge_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_ge_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are greater than or equal to <value> and saves the result in <dst>. If the element of <src> is greater than or equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* int, short and char are supported on (m)tp\\_3xx or higher;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* int, short, char, unsigned int, unsigned short and unsigned char are not supported on tp\\_520. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "geu": "void __bang_geu(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_geu(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_geu(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely to determine whether the element in <src0> is unordered or greater than or equal to that in <src1> and saves the result in <dst>. If the element of <src0> is unordered or greater than or equal to the element of <src1>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first vector.\n* [in] src1: The address of the second vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ for more details.",
    "geu_bitindex": "void __bang_geu_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_geu_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_geu_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely, if the element of <src0> is unoredred or greater than or equal to that of <src1>, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero and divisible by 8. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_bitindex for more details.",
    "geu_scalar": "void __bang_geu_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_geu_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_geu_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are unordered or greater than or equal to <value> and saves the result in <dst>. If the element of <src> is unordered or greater than or equal to <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_scalar for more details.",
    "gt": "void __bang_gt(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_gt(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_gt(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely to determine whether the element in <src0> is greater than that in <src1> and saves the result in <dst>. If the element of <src0> is greater than the element of <src1>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first vector.\n* [in] src1: The address of the second vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq for more details.",
    "gt_bitindex": "void __bang_gt_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_gt_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_gt_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely, if the element of <src0> is greater than that of <src1>, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.\nThe comparison process is illustrated in the figure below, the comparison result between the first element <element0> of <src0> and the first element <element0> of <src1> will be saved in <bit0> of <dst> . The other elements do the same comparison in turn. Fig. 3.12 The Calculation Process of Half Type \\_\\_bang\\_gt\\_bitindex Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be divisible by 512 on (m)tp\\_2xx;\n* <elem\\_count> must be divisible by 8 on (m)tp\\_3xx or higher;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq_bitindex for more details.",
    "gt_scalar": "void __bang_gt_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_gt_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_gt_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are greater than <value> and saves the result in <dst>. If the element of <src> is greater than <value>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_eq_scalar for more details.",
    "gtu": "void __bang_gtu(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_gtu(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_gtu(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely to determine whether the element in <src0> is unordered or greater than that in <src1> and saves the result in <dst>. If the element of <src0> is unordered or greater than the element of <src1>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first vector.\n* [in] src1: The address of the second vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ for more details.",
    "gtu_bitindex": "void __bang_gtu_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_gtu_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_gtu_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely, if the element of <src0> is unordered or greater than that of <src1>, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero and divisible by 8. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_bitindex for more details.",
    "gtu_scalar": "void __bang_gtu_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_gtu_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_gtu_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are unordered or greater than <value> and saves the result in <dst>. If the element of <src> is unordered or greater than <value>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_scalar for more details.",
    "le": "void __bang_le(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_le(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_le(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely to determine whether the element in <src0> is less than or equal to that in <src1> and saves the result in <dst>. If the element of <src0> is less than or equal to the element of <src1>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first vector.\n* [in] src1: The address of the second vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq for more details.",
    "le_bitindex": "void __bang_le_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_le_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_le_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely, if the element of <src0> is less than or equal to that of <src1>, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.\nThe comparison process is illustrated in the figure below, the comparison result between the first element <element0> of <src0> and the first element <element0> of <src1> will be saved in <bit0> of <dst> . The other elements do the same comparison in turn. Fig. 3.13 The Calculation Process of Half Type \\_\\_bang\\_le\\_bitindex Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be divisible by 512 on (m)tp\\_2xx;\n* <elem\\_count> must be divisible by 8 on (m)tp\\_3xx or higher;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq_bitindex for more details.",
    "le_scalar": "void __bang_le_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_le_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_le_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are less than or equal to <value> and saves the result in <dst>. If the element of <src> is less than or equal to <value>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_eq_scalar for more details.",
    "leu": "void __bang_leu(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_leu(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_leu(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely to determine whether the element in <src0> is unordered or less than or equal to that in <src1> and saves the result in <dst>. If the element of <src0> is unordered or less than or equal to the element of <src1>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first vector.\n* [in] src1: The address of the second vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ for more details.",
    "leu_bitindex": "void __bang_leu_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_leu_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_leu_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely, if the element of <src0> is unordered or less than or equal to that of <src1>, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero and divisible by 8. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_bitindex for more details.",
    "leu_scalar": "void __bang_leu_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_leu_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_leu_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are unordered or less than or equal to <value> and saves the result in <dst>. If the element of <src> is unordered or less than or equal to <value>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_scalar for more details.",
    "lt": "void __bang_lt(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_lt(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_lt(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_lt(unsigned int *dst, const unsigned int *src0, const unsigned int *src1, unsigned int elem_count)   void __bang_lt(unsigned short *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_lt(unsigned char *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_lt(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_lt(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_lt(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely to determine whether the element in <src0> is less than that in <src1> and saves the result in <dst>. If the element of <src0> is less than the element of <src1>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first vector.\n* [in] src1: The address of the second vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short, char, unsigned int, unsigned short and unsigned char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq for more details.",
    "lt_bitindex": "void __bang_lt_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_lt_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_lt_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely, if the element of <src0> is less than that of <src1>, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.\nThe comparison process is illustrated in the figure below, the comparison result between the first element <element0> of <src0> and the first element <element0> of <src1> will be saved in <bit0> of <dst> . The other elements do the same comparison in turn. Fig. 3.14 The Calculation Process of Half Type \\_\\_bang\\_lt\\_bitindex Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be divisible by 512 on (m)tp\\_2xx;\n* <elem\\_count> must be divisible by 8 on (m)tp\\_3xx or higher;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq_bitindex for more details.",
    "lt_scalar": "void __bang_lt_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_lt_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_lt_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_lt_scalar(unsigned int *dst, const unsigned int *src, unsigned int value, unsigned int elem_count)   void __bang_lt_scalar(unsigned short *dst, const unsigned short *src, unsigned short value, unsigned int elem_count)   void __bang_lt_scalar(unsigned char *dst, const unsigned char *src, unsigned char value, unsigned int elem_count)   void __bang_lt_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_lt_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_lt_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are less than <value> and saves the result in <dst>. If the element of <src> is less than <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* int, short, char, unsigned int, unsigned short and unsigned char are not supported on tp\\_520. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_eq_scalar for more details.",
    "ltu": "void __bang_ltu(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_ltu(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_ltu(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely to determine whether the element in <src0> is unordered or less than that in <src1> and saves the result in <dst>. If the element of <src0> is unordered or less than the element of <src1>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first vector.\n* [in] src1: The address of the second vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ for more details.",
    "ltu_bitindex": "void __bang_ltu_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_ltu_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_ltu_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function compares with <elem\\_count> elements in <src0> and <src1> element-wisely, if the element of <src0> is unordered or less than that of <src1>, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero and divisible by 8. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_bitindex for more details.",
    "ltu_scalar": "void __bang_ltu_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_ltu_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_ltu_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are unordered or less than <value> and saves the result in <dst>. If the element of <src> is unordered or less than <value>, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_scalar for more details.",
    "maxeq_scalar": "void __bang_maxeq_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_maxeq_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_maxeq_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_maxeq_scalar(unsigned int *dst, const unsigned int *src, unsigned int value, unsigned int elem_count)   void __bang_maxeq_scalar(unsigned short *dst, const unsigned short *src, unsigned short value, unsigned int elem_count)   void __bang_maxeq_scalar(unsigned char *dst, const unsigned char *src, unsigned char value, unsigned int elem_count)   void __bang_maxeq_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_maxeq_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_maxeq_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function finds the maximum between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If one of the elements being compared is a NaN, then the element in <src> is returned. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* int, short, char, unsigned int, unsigned short and unsigned char are not supported on tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_eq_scalar for more details.",
    "maxequal": "void __bang_maxequal(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_maxequal(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_maxequal(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_maxequal(unsigned int *dst, const unsigned int *src0, const unsigned int *src1, unsigned int elem_count)   void __bang_maxequal(unsigned short *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_maxequal(unsigned char *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_maxequal(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_maxequal(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_maxequal(float *dst, const float *src0, const float *src1, unsigned int elem_count)   Finds maximum value of each two corresponding elements in the two vectors. If one of the elements being compared are NaN, then the element in <src0> is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector\n* [in] src0: The address of first source vector\n* [in] src1: The address of second source vector\n* [in] elem\\_count: The number of elements in source vector Return* void. Remark* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* int, short, char, unsigned int, unsigned short and unsigned char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src0>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "maximum": "void __bang_maximum(half *dst, const half *src, int distance, unsigned int size)   Finds maximum value of each two corresponding elements in two vectors between which the distance is <distance>. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] distance: The distance between the two source vector.\n* [in] size: The elements number of destination vector. Return* void. Remark* <size> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <size> \\* sizeof (type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_maxequal instead. Instruction Pipeline* Compute. Requirements* None. Example",
    "maximum_scalar": "void __bang_maximum_scalar(float *dst, float *src, float value, unsigned int elem_count)   void __bang_maximum_scalar(half *dst, half *src, half value, unsigned int elem_count)   void __bang_maximum_scalar(bfloat16_t *dst, bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   This function finds the maximum between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If only one of the element in <src> and <value> is NaN, the result is the other. If both of the elements in <src> and <value> are NaN, the result is NaN. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_eq_scalar for more details.",
    "mineq_scalar": "void __bang_mineq_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_mineq_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_mineq_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_mineq_scalar(unsigned int *dst, const unsigned int *src, unsigned int value, unsigned int elem_count)   void __bang_mineq_scalar(unsigned short *dst, const unsigned short *src, unsigned short value, unsigned int elem_count)   void __bang_mineq_scalar(unsigned char *dst, const unsigned char *src, unsigned char value, unsigned int elem_count)   void __bang_mineq_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_mineq_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_mineq_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function finds the minimum between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If one of the elements being compared is a NaN, then the element in <src> is returned. See the table :ref:floating\\_point\\_calculation\\_of\\_stream\\_and\\_scalar\\_binary\\_operation\\_functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* int, short, char, unsigned int, unsigned short and unsigned char are not supported on tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_eq_scalar for more details.",
    "minequal": "void __bang_minequal(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_minequal(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_minequal(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_minequal(unsigned int *dst, const unsigned int *src0, const unsigned int *src1, unsigned int elem_count)   void __bang_minequal(unsigned short *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_minequal(unsigned char *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_minequal(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_minequal(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_minequal(float *dst, const float *src0, const float *src1, unsigned int elem_count)   Finds minimum value of each two corresponding elements in the two vectors. If one of the elements being compared are NaN, then the element in <src0> is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector\n* [in] src0: The address of first source vector\n* [in] src1: The address of second source vector\n* [in] elem\\_count: The number of elements in source vector Return* void. Remark* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* int, short, char, unsigned int, unsigned short and unsigned char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src0>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "minimum": "void __bang_minimum(float *dst, const float *src0, const float *src1, unsigned int elem_count)   void __bang_minimum(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_minimum(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   Compares two vectors and returns a new vector containing the element-wise minima. If both of the elements being compared are NaN, then NaN is returned. Parameters* [out] dst: The address of destination vector\n* [in] src0: The address of first source vector\n* [in] src1: The address of second source vector\n* [in] elem\\_count: The number of elements in source vector Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src0> or <src1>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "minimum_scalar": "void __bang_minimum_scalar(float *dst, float *src, float value, unsigned int elem_count)   void __bang_minimum_scalar(half *dst, half *src, half value, unsigned int elem_count)   void __bang_minimum_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   This function finds the minimum between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If only one of the element in <src> and <value> is NaN, the result is the other. If both of the elements in <src> and <value> are NaN, the result is NaN. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_eq_scalar for more details.",
    "nan_argmax": "void __bang_nan_argmax(half *dst, const half *src, unsigned int elem_count)   void __bang_nan_argmax(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_nan_argmax(float *dst, const float *src, unsigned int elem_count)   Finds the maximum value and its corresponding index in <src> vector. The result is composed of two parts. The first part is the maximum value of corresponding type, and the second part is the index of the first maximum value position in <src> vector, whose data type is unsigned int. The maximum value and index are stored continuously in <dst>. If one of the elements being compared is a NaN, then that element and its corresponding index are returned. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "nan_argmin": "void __bang_nan_argmin(half *dst, const half *src, unsigned int elem_count)   void __bang_nan_argmin(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_nan_argmin(float *dst, const float *src, unsigned int elem_count)   Finds the minimum value and its corresponding index in <src> vector. The result is composed of two parts. The first part is the minimum value of corresponding type, and the second part is the index of the first minimum value position in <src> vector, whose data type is unsigned int. The minimum value and index are stored continuously in <dst>. If one of the elements being compared is a NaN, then that element and its corresponding index are returned. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "nan_maximum": "void __bang_nan_maximum(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_nan_maximum(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_nan_maximum(float *dst, const float *src0, const float *src1, unsigned int elem_count)   Compares two vectors and returns a new vector containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. Parameters* [out] dst: The address of destination vector\n* [in] src0: The address of first source vector\n* [in] src1: The address of second source vector\n* [in] elem\\_count: The number of elements in source vector Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src0> or <src1>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "nan_maximum_scalar": "void __bang_nan_maximum_scalar(float *dst, const float *src, float value, unsigned int elem_count)   void __bang_nan_maximum_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_nan_maximum_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   This function finds the maximum between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If only one of the element in <src> and <value> is NaN, the result is NaN. If both of the elements in <src> and <value> are NaN, the result is NaN. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero; Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx Example* See the example of __bang_eq_scalar for more details.",
    "nan_minimum": "void __bang_nan_minimum(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_nan_minimum(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_nan_minimum(float *dst, const float *src0, const float *src1, unsigned int elem_count)   Compares two vectors and returns a new vector containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. Parameters* [out] dst: The address of destination vector\n* [in] src0: The address of first source vector\n* [in] src1: The address of second source vector\n* [in] elem\\_count: The number of elements in source vector Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src0> or <src1>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "nan_minimum_scalar": "void __bang_nan_minimum_scalar(float *dst, const float *src, float value, unsigned int elem_count)   void __bang_nan_minimum_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_nan_minimum_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   This function finds the minimum between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If only one of the element in <src> and <value> is NaN, the result is NaN. If both of the elements in <src> and <value> are NaN, the result is NaN. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.3.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_eq_scalar for more details.",
    "ne": "void __bang_ne(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_ne(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_ne(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_ne(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_ne(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_ne(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs inequality comparison with <src0> and <src1> element-wisely and saves the result in <dst>. If the element of <src0> and the element of <src1> are not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq for more details.",
    "ne_bitindex": "void __bang_ne_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_ne_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_ne_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs inequality comparison with <src0> and <src1> element-wisely. If the two elements are not equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.\nThe comparison process is illustrated in the figure below, the comparison result between the first element <element0> of <src0> and the first element <element0> of <src1> will be saved in <bit0> of <dst> . The other elements do the same comparison in turn. Fig. 3.15 The Calculation Process of Half Type \\_\\_bang\\_ne\\_bitindex Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be divisible by 512 on (m)tp\\_2xx;\n* <elem\\_count> must be divisible by 8 on (m)tp\\_3xx or higher;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_eq_bitindex for more details.",
    "ne_scalar": "void __bang_ne_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_ne_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_ne_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_ne_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_ne_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_ne_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function performs inequality comparison with <elem\\_count> elements of <src> and <value> and saves the result in <dst>. The type of result is same as the type of <src>. If the element of <src> and <value> are not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* int, short and char are not supported on tp\\_520. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_eq_scalar for more details.",
    "neu": "void __bang_neu(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_neu(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_neu(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs unoredred or inequality comparison with <src0> and <src1> element-wisely and saves the result in <dst>. If the element of <src0> and the element of <src1> are unordered or not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ for more details.",
    "neu_bitindex": "void __bang_neu_bitindex(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_neu_bitindex(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_neu_bitindex(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs unordered or inequality comparison with <src0> and <src1> element-wisely. If the two elements are unordered or not equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in <dst>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> , <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero and divisible by 8. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_bitindex for more details.",
    "neu_scalar": "void __bang_neu_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_neu_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_neu_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function performs unordered or inequality comparison with <elem\\_count> elements of <src> and <value> and saves the result in <dst>. The type of result is same as the type of <src>. If the element of <src> and <value> are unordered or not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* See the example of __bang_equ_scalar for more details.",
    "fcmpfilter": "void __bang_fcmpfilter(CompareMode mode, half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_fcmpfilter(CompareMode mode, half *dst, const half *src0, half src1, unsigned int elem_count)   void __bang_fcmpfilter(CompareMode mode, float *dst, const float *src0, const float *src1, unsigned int elem_count)   void __bang_fcmpfilter(CompareMode mode, bfloat16_t *dst, const bfloat16_t *src0, bfloat16_t src1, unsigned int elem_count)   void __bang_fcmpfilter(CompareMode mode, bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_fcmpfilter(CompareMode mode, float *dst, const float *src0, float src1, unsigned int elem_count)   This function performs element-wise comparison with <src0> and <src1> according to <mode>. <mode> indicates the type of comparison. <mode> is assigned to an enumerated type called CompareMode that contains six enumerators listed in the table below. The elements in <src0> that meet the given comparison criteria <mode> will be selected and written to <dst> continuously. The result is composed of two parts. The first part is the number of selected elements in <src0>, whose data type is unsigned int, and the second part is the selected elements. Table 3.58 Semantics of CompareMode | CompareMode Type | Semantic |\n| --- | --- |\n| CMP\\_EQ | (=) |\n| CMP\\_NE | (\\neq) |\n| CMP\\_LT | (<) |\n| CMP\\_LE | (\\leq) |\n| CMP\\_GT | (>) |\n| CMP\\_GE | (\\geq) | See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [in] mode: The comparison mode.\n* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector or the second source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0> and <dst> must point to \\_\\_nram\\_\\_ address space. <src1> must also point to \\_\\_nram\\_\\_ address space if it is a vector;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src1> can be either vectors or scalars. When <src1> is a vector, the length of <src1> must be the same as that of <src0>;\n* <dst> can be overlapped with <src0>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```\n #include  #define ELEM_NUM 128\n #define RES_ELEM_NUM (ELEM_NUM + 1) __mlu_entry__ void kernel_fabs(CompareMode mode, float* dst,\n                                float *src0, float *src1) {\n   __nram__ float dst_nram[RES_ELEM_NUM];\n   __nram__ float src0_nram[ELEM_NUM];\n   __nram__ float src1_nram[ELEM_NUM];\n   __memcpy(src0_nram, src0, ELEM_NUM * sizeof(float), GDRAM2NRAM);\n   __memcpy(src1_nram, src1, ELEM_NUM * sizeof(float), GDRAM2NRAM);\n   __bang_fcmpfilter(mode, dst_nram, src0_nram, src1_nram, ELEM_NUM);\n   __memcpy(dst, dst_nram, RES_ELEM_NUM * sizeof(float), NRAM2GDRAM);\n} ```",
    "fusion": "void __bang_fusion(mluFusionOpCode op_code, half *dst, const half *src0, half src1, half src2, unsigned int src_elem_count)   void __bang_fusion(mluFusionOpCode op_code, float *dst, const float *src0, const float *src1, float src2, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_fusion(mluFusionOpCode op_code, float *dst, const float *src0, float src1, const float *src2, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_fusion(mluFusionOpCode op_code, float *dst, const float *src0, float src1, float src2, unsigned int src_elem_count)   void __bang_fusion(mluFusionOpCode op_code, half *dst, const half *src0, const half *src1, const half *src2, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_fusion(mluFusionOpCode op_code, half *dst, const half *src0, const half *src1, half src2, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_fusion(mluFusionOpCode op_code, half *dst, const half *src0, half src1, const half *src2, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_fusion(mluFusionOpCode op_code, bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, const bfloat16_t *src2, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_fusion(mluFusionOpCode op_code, bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, bfloat16_t src2, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_fusion(mluFusionOpCode op_code, bfloat16_t *dst, const bfloat16_t *src0, bfloat16_t src1, const bfloat16_t *src2, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_fusion(mluFusionOpCode op_code, bfloat16_t *dst, const bfloat16_t *src0, bfloat16_t src1, bfloat16_t src2, unsigned int src_elem_count)   void __bang_fusion(mluFusionOpCode op_code, float *dst, const float *src0, const float *src1, const float *src2, unsigned int src_elem_count, unsigned int seg_elem_count)   This function performs fused arithmetic calculation on vectors <src0> , <src1> and <src2> element-wisely according to <op\\_code> and saves the result in <dst>. <op\\_code> indicates the type of operator. <op\\_code> is assigned to an enumerated type called mluFusionOpCode that contains eight enumerators listed in the table below.  Table 3.59 Semantics of mluFusionOpCode | mluFusionOpCode Type | Semantic |\n| --- | --- |\n| FUSION\\_FMA | ( =  \\times  + ) |\n| FUSION\\_FMS | ( =  \\times  - ) |\n| FUSION\\_FAM | ( = ( + ) \\times ) |\n| FUSION\\_FSM | ( = ( - ) \\times ) |\n| FUSION\\_FAA | ( =  +  + ) |\n| FUSION\\_FAS | ( =  +  - ) |\n| FUSION\\_FSS | ( =  -  - ) |\n| FUSION\\_FSA | ( =  -  + ) | Note For the last two characters of enumerators, ‘M’ means multiplication, ‘A’ means addition and ‘S’ means subtraction. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [in] op\\_code: The type of operator.\n* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The second source scalar or the address of the second source vector.\n* [in] src2: The third source scalar or the address of the third source vector.\n* [in] src\\_elem\\_count: The number of elements in <dst> and <src0>.\n* [in] seg\\_elem\\_count: The number of elements in <src1> and <src2>. Return* void. Remark* <dst> can be overlapped with <src0>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src1> or <src2> must also point to \\_\\_nram\\_\\_ address space if it is a vector;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "and": "void __bang_and(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_and(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_and(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_and(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_and(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_and(float *dst, const float *src0, const float *src1, unsigned int elem_count)   Performs logical AND operation between elements in two vectors. If both the elements of <src0> and <src1> are non-zero, the result is 1. Otherwise, the result is 0. The type of result is the same as that of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of first source vector.\n* [in] src1: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src0>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "and_scalar": "void __bang_and_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_and_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_and_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_and_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_and_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_and_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function performs logical AND operation between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If both the elements of <src> and <value> are non-zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* int, short and char are not supported on tp\\_520. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "cycle_and": "void __bang_cycle_and(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_and(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_and(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_and(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_and(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_and(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part AND the corresponding element in <seg>. The result is assigned to <dst>. If both the elements of <src0> and <src1> are non-zero, the result is 1. Otherwise, the result is 0. The type of result is the same as that of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short and char;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "cycle_or": "void __bang_cycle_or(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_or(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_or(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_or(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_or(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_or(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part OR the corresponding element in <seg>. The result is assigned to <dst>. If both the elements of <src0> and <src1> are zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short and char;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_xor": "void __bang_cycle_xor(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_xor(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_xor(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_xor(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_xor(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_xor(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Divides <src> into <src\\_elem\\_count> / <seg\\_elem\\_count> parts. Each element in each part XOR the corresponding element in <seg>. The result is assigned to <dst>. If both the elements of <src0> and <src1> are zero or non-zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher, except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short and char;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "not": "void __bang_not(half *dst, const half *src, unsigned int elem_count)   void __bang_not(int *dst, const int *src, unsigned int elem_count)   void __bang_not(short *dst, const short *src, unsigned int elem_count)   void __bang_not(char *dst, const char *src, unsigned int elem_count)   void __bang_not(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_not(float *dst, const float *src, unsigned int elem_count)   Applies element-wisely NOT operation on a vector. For each element in <src>, if it equals to zero, then stores 1 at the corresponding position in <dst>; otherwise, stores 0 at the position in <dst>. The type of result is the same as that of <src>. See the table Floating Point Calculation of Stream and Scalar Unary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "or": "void __bang_or(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_or(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_or(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_or(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_or(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_or(float *dst, const float *src0, const float *src1, unsigned int elem_count)   Performs logical OR operation between elements in two vectors. If both the elements of <src0> and <src1> are zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of first source vector.\n* [in] src1: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "or_scalar": "void __bang_or_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_or_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_or_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_or_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_or_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_or_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function performs logical OR operation between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If either the element of <src> or <value> is non-zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* int, short and char are not supported on tp\\_520. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_and_scalar for more details.",
    "xor": "void __bang_xor(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_xor(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_xor(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_xor(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_xor(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_xor(float *dst, const float *src0, const float *src1, unsigned int elem_count)   Performs logical XOR operation between elements in two vectors. If both the elements of <src0> and <src1> are zero or non-zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of <src0> and <src1>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of first source vector.\n* [in] src1: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src0>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "xor_scalar": "void __bang_xor_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_xor_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_xor_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_xor_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_xor_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_xor_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function performs logical OR operation between <elem\\_count> elements of <src> and <value> and saves the result in <dst>. If the element of <src> is zero and <value> is non-zero, or the element of <src> is non-zero and <value> is zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* int, short and char are not supported on tp\\_520. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_and_scalar for more details.",
    "filter": "unsigned int __bang_filter(half *dst, const half *src, const half *index, unsigned int elem_count)   unsigned int __bang_filter(float *dst, const float *src, const float *index, unsigned int elem_count)   unsigned int __bang_filter(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *index, unsigned int elem_count)   Copies elements from <src> to <dst> if the corresponding values in <index> is not equal to zero, and returns the number of selected elements. The selected elements are stored continuously in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] index: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* unsigned int. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* The <src>, <index> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> \\* sizeof(type) must be a multiple of 128 bytes on (m)tp\\_2xx;\n* The address of <src>, <index> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* On (m)tp\\_2xx, if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;\n* On (m)tp\\_2xx, the reserved space for selected data in <dst> cannot be smaller than the size of <src> and if the selected elements(including pad) does not fill the entire <dst> space, the remaining data in <dst> may also be changed. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "filter_bitindex": "unsigned int __bang_filter_bitindex(half *dst, const half *src, const void *bitmask, unsigned int elem_count)   unsigned int __bang_filter_bitindex(float *dst, const float *src, const void *bitmask, unsigned int elem_count)   unsigned int __bang_filter_bitindex(bfloat16_t *dst, const bfloat16_t *src, const void *bitmask, unsigned int elem_count)   Copies elements from <src> to <dst> if the corresponding bit values in <bitmask> is not equal to zero, and returns the number of selected elements. The selected elements are stored continuously in <dst>. The behavior is illustrated in the figure below, in this example, <bitmask> is 0x41100000. Fig. 3.16 The Calculation Process of Floating-point Type \\_\\_bang\\_filter\\_bitindex Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] bitmask: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* unsigned int. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* <elem\\_count> must be divisible by 512 on (m)tp\\_2xx and by 8 on mtp\\_372;\n* <dst> can be overlapped with <src>;\n* The <src>, <bitmask> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <bitmask> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* On (m)tp\\_2xx, if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;\n* On (m)tp\\_2xx, the reserved space for selected data in <dst> cannot be smaller than the size of <src> and if the selected elements(including pad) does not fill the entire <dst> space, the remaining data in <dst> may also be changed. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "maskmove": "void __bang_maskmove(half *dst, const half *src, const half *mask, unsigned int elem_count)   void __bang_maskmove(float *dst, const float *src, const float *mask, unsigned int elem_count)   Selects bytes in <src>, whose element count is <elem\\_count>, according to the bit value of the vector <mask>, and stores the result in <dst>. The bytes in <src> will be selected if corresponding bit values in <mask> are not equal to zero. If the bit value of mask is 1, stores the corresponding byte of <src> to <dst>; otherwise, keeps the corresponding byte in <dst> unchanged. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] mask: The address of mask vector.\n* [in] elem\\_count: The length of source vector. Return* void. Remark* <elem\\_count> \\* sizeof(type) must be a multiple of 1024 bytes on (m)tp\\_2xx;\n* <elem\\_count> \\* sizeof(type) must be a multiple of 8 bytes on (m)tp\\_3xx;\n* <src>, <mask> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <mask> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.0.0. Use __bang_maskmove instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "mirror": "void __bang_mirror(bfloat16_t *dst, const bfloat16_t *src, unsigned int height, unsigned int width)   void __bang_mirror(int8_t *dst, const int8_t *src, unsigned int height, unsigned int width)   void __bang_mirror(char *dst, const char *src, unsigned int height, unsigned int width)   void __bang_mirror(unsigned char *dst, const unsigned char *src, unsigned int height, unsigned int width)   void __bang_mirror(unsigned short *dst, const unsigned short *src, unsigned int height, unsigned int width)   void __bang_mirror(short *dst, const short *src, unsigned int height, unsigned int width)   void __bang_mirror(half *dst, const half *src, unsigned int height, unsigned int width)   void __bang_mirror(unsigned int *dst, const unsigned int *src, unsigned int height, unsigned int width)   Flips <src>, a matrix whose size is <height> * <width>, in the left/right direction, and stores the result in <dst>. Parameters* [out] dst: The address of destination matrix.\n* [in] src: The address of source matrix.\n* [in] height: The width of <src>.\n* [in] width: The height of <src>. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <height> * sizeof(type) must be divisible by 64 on (m)tp\\_2xx;\n* <width> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* <height> and <width> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "pad": "void __bang_pad(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(short *dst, const short *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(unsigned short *dst, const unsigned short *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(int8_t *dst, const int8_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(char *dst, const char *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(unsigned char *dst, const unsigned char *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(int *dst, const int *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(unsigned int *dst, const unsigned int *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width)   void __bang_pad(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width, half pad_value)   void __bang_pad(short *dst, const short *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width, short pad_value)   void __bang_pad(char *dst, const char *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width, char pad_value)   void __bang_pad(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width, float pad_value)   void __bang_pad(int *dst, const int *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width, unsigned int pad_value)   void __bang_pad(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int pad_height, unsigned int pad_width, bfloat16_t pad_value)   Applies padding operation on <src>. Parameters* [out] dst: The destination vector, whose data layout is HWC.\n* [in] src: The source vector, whose data layout is HWC.\n* [in] channel: Number of channels.\n* [in] height: The height of <src>.\n* [in] width: The width of <src>.\n* [in] pad\\_width: Number of columns whose elements is all zero or <pad\\_value> on the horizontal of pad.\n* [in] pad\\_height: Number of columns whose elements is all zero or <pad\\_value> on the vertical of pad.\n* [in] pad\\_value: The value of padding. Return* void. Remark* <height> and <width> must be greater than 0;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <dst> cannot be overlapped with <src>;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> \\* <width> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* <pad\\_width> \\* <channel> \\* sizeof(type) must be 128-byte aligned on (m)tp\\_2xx;\n* If <height> == 1, <pad\\_width> must be equal to 0;\n* <pad\\_value> are only supported on (m)tp\\_5xx or higher;\n* This function was deprecated from CNCC v4.0.0. Use __bang_pad instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "rotate180": "void __bang_rotate180(bfloat16_t *dst, const bfloat16_t *src, unsigned int height, unsigned int width)   void __bang_rotate180(int8_t *dst, const int8_t *src, unsigned int height, unsigned int width)   void __bang_rotate180(char *dst, const char *src, unsigned int height, unsigned int width)   void __bang_rotate180(unsigned char *dst, const unsigned char *src, unsigned int height, unsigned int width)   void __bang_rotate180(half *dst, const half *src, unsigned int height, unsigned int width)   void __bang_rotate180(short *dst, const short *src, unsigned int height, unsigned int width)   void __bang_rotate180(unsigned short *dst, const unsigned short *src, unsigned int height, unsigned int width)   void __bang_rotate180(float *dst, const float *src, unsigned int height, unsigned int width)   void __bang_rotate180(int *dst, const int *src, unsigned int height, unsigned int width)   void __bang_rotate180(unsigned int *dst, const unsigned int *src, unsigned int height, unsigned int width)   Rotates <src> , a matrix, whose size is <height> * <width> , by 180 degrees in clockwise direction, and stores the result in <dst> . Parameters* [out] dst: The address of destination matrix.\n* [in] src: The address of source matrix.\n* [in] height: The height of <src>.\n* [in] width: The width of <src>. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <height> * sizeof(type) and <width> * sizeof(type) must be divisible by 128 bytes on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* <height> and <width> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "rotate270": "void __bang_rotate270(bfloat16_t *dst, const bfloat16_t *src, unsigned int height, unsigned int width)   void __bang_rotate270(int8_t *dst, const int8_t *src, unsigned int height, unsigned int width)   void __bang_rotate270(char *dst, const char *src, unsigned int height, unsigned int width)   void __bang_rotate270(unsigned char *dst, const unsigned char *src, unsigned int height, unsigned int width)   void __bang_rotate270(half *dst, const half *src, unsigned int height, unsigned int width)   void __bang_rotate270(short *dst, const short *src, unsigned int height, unsigned int width)   void __bang_rotate270(unsigned short *dst, const unsigned short *src, unsigned int height, unsigned int width)   void __bang_rotate270(float *dst, const float *src, unsigned int height, unsigned int width)   void __bang_rotate270(int *dst, const int *src, unsigned int height, unsigned int width)   void __bang_rotate270(unsigned int *dst, const unsigned int *src, unsigned int height, unsigned int width)   Rotates <src> , a matrix, whose size is <height> * <width> , by 270 degrees in clockwise direction, and stores the result in <dst> . Parameters* [out] dst: The address of destination matrix.\n* [in] src: The address of source matrix.\n* [in] height: The height of <src>.\n* [in] width: The width of <src>. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <height> * sizeof(type) and <width> * sizeof(type) must be divisible by 128 bytes on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* <height> and <width> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "rotate90": "void __bang_rotate90(bfloat16_t *dst, const bfloat16_t *src, unsigned int height, unsigned int width)   void __bang_rotate90(int8_t *dst, const int8_t *src, unsigned int height, unsigned int width)   void __bang_rotate90(char *dst, const char *src, unsigned int height, unsigned int width)   void __bang_rotate90(unsigned char *dst, const unsigned char *src, unsigned int height, unsigned int width)   void __bang_rotate90(half *dst, const half *src, unsigned int height, unsigned int width)   void __bang_rotate90(short *dst, const short *src, unsigned int height, unsigned int width)   void __bang_rotate90(unsigned short *dst, const unsigned short *src, unsigned int height, unsigned int width)   void __bang_rotate90(float *dst, const float *src, unsigned int height, unsigned int width)   void __bang_rotate90(int *dst, const int *src, unsigned int height, unsigned int width)   void __bang_rotate90(unsigned int *dst, const unsigned int *src, unsigned int height, unsigned int width)   Rotates <src> , a matrix, whose size is <height> * <width> , by 90 degrees in clockwise direction, and stores the result in <dst> . Parameters* [out] dst: The address of destination matrix.\n* [in] src: The address of source matrix.\n* [in] height: The height of <src>.\n* [in] width: The width of <src>. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <height> \\* sizeof(type) and <width> * sizeof(type) must be divisible by 128 bytes on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* <height> and <width> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "tiling_2d_b128": "void __bang_tiling_2d_b128(void *dst, const void *src, unsigned int n2, unsigned int s2, unsigned int n1, unsigned int s1, unsigned int n7, unsigned int s7, unsigned int n6, unsigned int s6)   Applies 2D tiling operation on <src> for matrix transpose and store the matrix to the <dst>. As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. <s1> of data in each segment are copied to destination area <n1> times. There are 4 segments in the second dimension. <s2> of data in each segment are copied to destination area <n2> times. Then, calculate matrix transpose based on 128-bit as one element and store the matrix into corresponding segments and dimensions of <dst>. Parameters* [out] dst: The address of output matrix.\n* [in] src: The address of input matrix.\n* [in] n2: Tiling input iteration 2.\n* [in] s2: Tiling input stride 2.\n* [in] n1: Tiling input iteration 1.\n* [in] s1: Tiling input stride 1.\n* [in] n7: Tiling output iteration 7.\n* [in] s7: Tiling output stride 7.\n* [in] n6: Tiling output iteration 6.\n* [in] s6: Tiling output stride 6. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* ( \\times  =  \\times  = 4);\n* <n1>, <n2>, <n6> and <n7> must be an immediate integer on (m)tp\\_2xx;\n* <s1>, <s2>, <s6> and <s7> must be greater than or equal to zero;\n* Unit of <s1>, <s2>, <s6>, <s7> is 64 bytes;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "tiling_2d_b16": "void __bang_tiling_2d_b16(void *dst, const void *src, unsigned int n2, unsigned int s2, unsigned int n1, unsigned int s1, unsigned int n7, unsigned int s7, unsigned int n6, unsigned int s6)   Applies 2D tiling operation on <src> for matrix transpose and store the matrix to the <dst>. As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. <s1> of data in each segment are copied to destination area <n1> times. There are 4 segments in the second dimension. <s2> of data in each segment are copied to destination area <n2> times. Then, calculate matrix transpose based on 16-bit as one element and store the matrix into corresponding segments and dimensions of <dst>. Parameters* [out] dst: The address of output matrix.\n* [in] src: The address of input matrix.\n* [in] n2: Tiling input iteration 2.\n* [in] s2: Tiling input stride 2.\n* [in] n1: Tiling input iteration 1.\n* [in] s1: Tiling input stride 1.\n* [in] n7: Tiling output iteration 7.\n* [in] s7: Tiling output stride 7.\n* [in] n6: Tiling output iteration 6.\n* [in] s6: Tiling output stride 6. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* ( \\times  =  \\times  = 32);\n* <n1>, <n2>, <n6> and <n7> must be an immediate integer on (m)tp\\_2xx;\n* <s1>, <s2>, <s6> and <s7> must be greater than or equal to zero;\n* Unit of <s1>, <s2>, <s6>, <s7> is 64 bytes;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "tiling_2d_b256": "void __bang_tiling_2d_b256(void *dst, const void *src, unsigned int n2, unsigned int s2, unsigned int n1, unsigned int s1, unsigned int n7, unsigned int s7, unsigned int n6, unsigned int s6)   Applies 2D tiling operation on <src> for matrix transpose and store the matrix to the <dst>. As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. <s1> of data in each segment are copied to destination area <n1> times. There are 4 segments in the second dimension. <s2> of data in each segment are copied to destination area <n2> times. Then, calculate matrix transpose based on 256-bit as one element and store the matrix into corresponding segments and dimensions of <dst>. Parameters* [out] dst: The address of output matrix.\n* [in] src: The address of input matrix.\n* [in] n2: Tiling input iteration 2.\n* [in] s2: Tiling input stride 2.\n* [in] n1: Tiling input iteration 1.\n* [in] s1: Tiling input stride 1.\n* [in] n7: Tiling output iteration 7.\n* [in] s7: Tiling output stride 7.\n* [in] n6: Tiling output iteration 6.\n* [in] s6: Tiling output stride 6. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* ( \\times  =  \\times  = 2);\n* <n1>, <n2>, <n6> and <n7> must be an immediate integer on (m)tp\\_2xx;\n* <s1>, <s2>, <s6> and <s7> must be greater than or equal to zero;\n* Unit of <s1>, <s2>, <s6>, <s7> is 64 bytes;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "tiling_2d_b32": "void __bang_tiling_2d_b32(void *dst, const void *src, unsigned int n2, unsigned int s2, unsigned int n1, unsigned int s1, unsigned int n7, unsigned int s7, unsigned int n6, unsigned int s6)   Applies 2D tiling operation on <src> for matrix transpose and store the matrix to the <dst>. As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. <s1> of data in each segment are copied to destination area <n1> times. There are 4 segments in the second dimension. <s2> of data in each segment are copied to destination area <n2> times. Then, calculate matrix transpose based on 32-bit as one element and store the matrix into corresponding segments and dimensions of <dst>. Parameters* [out] dst: The address of output matrix.\n* [in] src: The address of input matrix.\n* [in] n2: Tiling input iteration 2.\n* [in] s2: Tiling input stride 2.\n* [in] n1: Tiling input iteration 1.\n* [in] s1: Tiling input stride 1.\n* [in] n7: Tiling output iteration 7.\n* [in] s7: Tiling output stride 7.\n* [in] n6: Tiling output iteration 6.\n* [in] s6: Tiling output stride 6. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* ( \\times  =  \\times  = 16);\n* <n1>, <n2>, <n6> and <n7> must be an immediate integer on (m)tp\\_2xx;\n* <s1>, <s2>, <s6> and <s7> must be greater than or equal to zero;\n* Unit of <s1>, <s2>, <s6>, <s7> is 64 bytes;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "tiling_2d_b64": "void __bang_tiling_2d_b64(void *dst, const void *src, unsigned int n2, unsigned int s2, unsigned int n1, unsigned int s1, unsigned int n7, unsigned int s7, unsigned int n6, unsigned int s6)   Applies 2D tiling operation on <src> for matrix transpose and store the matrix to the <dst>. As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. <s1> of data in each segment are copied to destination area <n1> times. There are 4 segments in the second dimension. <s2> of data in each segment are copied to destination area <n2> times. Then, calculate matrix transpose based on 64-bit as one element and store the matrix into corresponding segments and dimensions of <dst>. Parameters* [out] dst: The address of output matrix.\n* [in] src: The address of input matrix.\n* [in] n2: Tiling input iteration 2.\n* [in] s2: Tiling input stride 2.\n* [in] n1: Tiling input iteration 1.\n* [in] s1: Tiling input stride 1.\n* [in] n7: Tiling output iteration 7.\n* [in] s7: Tiling output stride 7.\n* [in] n6: Tiling output iteration 6.\n* [in] s6: Tiling output stride 6. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* ( \\times  =  \\times  = 8);\n* <n1>, <n2>, <n6> and <n7> must be an immediate integer on (m)tp\\_2xx;\n* <s1>, <s2>, <s6> and <s7> must be greater than or equal to zero;\n* Unit of <s1>, <s2>, <s6>, <s7> is 64 bytes;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "tiling_2d_b8": "void __bang_tiling_2d_b8(void *dst, const void *src, unsigned int n2, unsigned int s2, unsigned int n1, unsigned int s1, unsigned int n7, unsigned int s7, unsigned int n6, unsigned int s6)   Applies 2D tiling operation on <src> for matrix transpose and stores the matrix to the <dst>. As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. <s1> of data in each segment are copied to destination area <n1> times. There are 4 segments in the second dimension. <s2> of data in each segment are copied to destination area <n2> times. Then, calculate matrix transpose based on 8-bit as one element and store the matrix into corresponding segments and dimensions of <dst>.  Fig. 3.17 The Process of 2 Dimensional Tiling Function Parameters* [out] dst: The address of output matrix.\n* [in] src: The address of input matrix.\n* [in] n2: Tiling input iteration 2.\n* [in] s2: Tiling input stride 2.\n* [in] n1: Tiling input iteration 1.\n* [in] s1: Tiling input stride 1.\n* [in] n7: Tiling output iteration 7.\n* [in] s7: Tiling output stride 7.\n* [in] n6: Tiling output iteration 6.\n* [in] s6: Tiling output stride 6. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* ( \\times  =  \\times  = 64);\n* <n1>, <n2>, <n6> and <n7> must be an immediate integer on (m)tp\\_2xx;\n* <s1>, <s2>, <s6> and <s7> must be greater than or equal to zero;\n* Unit of <s1>, <s2>, <s6>, <s7> is 64 bytes;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "tiling_3d_b1024": "void __bang_tiling_3d_b1024(void *dst, const void *src, unsigned int n5, unsigned int s5, unsigned int n4, unsigned int s4, unsigned int n3, unsigned int s3, unsigned int n10, unsigned int s10, unsigned int n9, unsigned int s9, unsigned int n8, unsigned int s8, unsigned int op)   Copies data from <src> to <dst> in 3 dimensions. As shown in Figure The Process of 3 Dimensional Tiling Function ,the cells with blue background indicate <op> of data to be copied in each segment. In this case, there are 3 segments in the first dimension. <s3> of data in each segment are copied to destination area <n3> times. There are 2 segments in the second dimension. <s4> of data in each segment are copied to destination area <n4> times. And there are 2 segments in the third dimension. <s5> of data in each segment are copied to destination area <n5> times. Then, copy the data into corresponding segments and dimensions of <dst>.  Fig. 3.18 The Process of 3 Dimensional Tiling Function Parameters* [out] dst: The address of output tensor.\n* [in] src: The address of input tensor.\n* [in] n5: Tiling input outer iteration 5.\n* [in] s5: Tiling input outer stride 5.\n* [in] n4: Tiling input outer iteration 4.\n* [in] s4: Tiling input outer stride 4.\n* [in] n3: Tiling input outer iteration 3.\n* [in] s3: Tiling input outer stride 3.\n* [in] n10: Tiling output outer iteration 10.\n* [in] s10: Tiling output outer stride 10.\n* [in] n9: Tiling output outer iteration 9.\n* [in] s9: Tiling output outer stride 9.\n* [in] n8: Tiling output outer iteration 8.\n* [in] s8: Tiling output outer stride 8.\n* [in] op: The number of tiling unit (128 bytes). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <op> must be an immediate integer;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* Unit of <s3>, <s4>, <s5>, <s8>, <s9> and <s10> is 64 bytes;\n* <s3>, <s4>, <s5>, <s8>, <s9> and <s10> must be greater than or equal to zero;\n* ( \\times  \\times  ==  \\times  \\times );\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "transpose": "void __bang_transpose(bfloat16_t *dst, const bfloat16_t *src, unsigned int height, unsigned int width)   void __bang_transpose(half *dst, const half *src, unsigned int height, unsigned int width)   void __bang_transpose(short *dst, const short *src, unsigned int height, unsigned int width)   void __bang_transpose(unsigned short *dst, const unsigned short *src, unsigned int height, unsigned int width)   void __bang_transpose(int8_t *dst, const int8_t *src, unsigned int height, unsigned int width)   void __bang_transpose(char *dst, const char *src, unsigned int height, unsigned int width)   void __bang_transpose(unsigned char *dst, const unsigned char *src, unsigned int height, unsigned int width)   void __bang_transpose(float *dst, const float *src, unsigned int height, unsigned int width)   void __bang_transpose(int *dst, const int *src, unsigned int height, unsigned int width)   void __bang_transpose(unsigned int *dst, const unsigned int *src, unsigned int height, unsigned int width)   Transposes operand src[height][width], a matrix, to dst[width][height]. Parameters* [out] dst: The address of destination matrix, and the matrix has WH data layout.\n* [in] src: The address of source matrix, and the matrix has HW data layout.\n* [in] height: The height of <src>.\n* [in] width: The width of <src>. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <height> \\* sizeof(type) and <width> \\* sizeof(type) must be divisible by 64 on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* <height> and <width> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```\n #include  #define WIDTH 128\n #define HEIGHT 64\n #define LEN (HEIGHT * WIDTH) __mlu_entry__ void kernel(short* dst, short* src) {\n   __nram__ short ny[LEN];\n   __nram__ short nx[LEN];\n  __memcpy(nx, src, LEN * sizeof(short), GDRAM2NRAM);\n  __bang_transpose(ny, nx, HEIGHT, WIDTH);\n  __memcpy(dst, ny, LEN * sizeof(short), NRAM2GDRAM);\n} ```",
    "abs": "void __bang_abs(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_abs(half *dst, const half *src, unsigned int elem_count)   void __bang_abs(float *dst, const float *src, unsigned int elem_count)   void __bang_abs(char *dst, const char *src, unsigned int elem_count)   void __bang_abs(short *dst, const short *src, unsigned int elem_count)   void __bang_abs(int *dst, const int *src, unsigned int elem_count)   This function computes the absolute value of <src> element-wisely and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* int, short and charare not supported on tp\\_520;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> must be greater than zero;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* None.",
    "add": "void __bang_add(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_add(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_add(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_add(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_add(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_add(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs addition operation element-wisely on <src0> and <src1> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* float is the supported on (m)tp\\_2xx or higher;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "add_scalar": "void __bang_add_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_add_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_add_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_add_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_add_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_add_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function adds <value> to <elem\\_count> elements of <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "add_tz": "void __bang_add_tz(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_add_tz(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_add_tz(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs addition operation element-wisely on <src0> and <src1> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "adds": "void __bang_adds(unsigned char *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_adds(unsigned short *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_adds(unsigned int *dst, const unsigned int *src0, const unsigned int *src1, unsigned int elem_count)   void __bang_adds(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_adds(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_adds(int *dst, const int *src0, const int *src1, unsigned int elem_count)   This function performs saturated addition operation element-wisely on <src0> and <src1> and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372 and tp\\_520;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "adds_scalar": "void __bang_adds_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_adds_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_adds_scalar(int *dst, const int *src, int value, unsigned int elem_count)   This function adds <value> to <elem\\_count> elements of <src> and saves the saturated result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "count": "void __bang_count(unsigned int *dst, const half *src, unsigned int elem_count)   void __bang_count(unsigned int *dst, const float *src, unsigned int elem_count)   Counts the number of non-zero elements in the input vector. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The size of <dst> is at least 128 bytes on (m)tp\\_2xx, and at least 4 bytes on (m)tp\\_3xx;\n* The number of non-zero elements is stored in the first 4 bytes of <dst>. The remaining 124 bytes of <dst> on (m)tp\\_2xx will be set to 0. The remaining part of <dst> will not be changed on (m)tp\\_3xx;\n* <dst> can be overlapped with <src>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_count instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "count_bitindex": "void __bang_count_bitindex(unsigned int *dst, const half *src, unsigned int elem_count)   void __bang_count_bitindex(unsigned int *dst, const float *src, unsigned int elem_count)   Counts the number of non-zero bit in the input vector. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* The size of <dst> is at least 128 bytes on (m)tp\\_2xx, and at least 4 bytes on (m)tp\\_3xx;\n* The number of non-zero bits is stored in the first 4 bytes of <dst>. The remaining 124 bytes of <dst> on (m)tp\\_2xx will be set to 0. The remaining part of <dst> will not be changed on (m)tp\\_3xx;\n* <dst> can be overlapped with <src>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_count_bitindex instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "cycle_add": "void __bang_cycle_add(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_add(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_add(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_add(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_add(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_add(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   This function divides <src> into N parts ( N = <src\\_elem\\_count> / <seg\\_elem\\_count> ), adds each element in each part of <src> and the corresponding element in <seg>, and assigns the result to <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.  Fig. 3.19 Description of \\_\\_bang\\_cycle\\_add Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short and char;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "cycle_add_tz": "void __bang_cycle_add_tz(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_add_tz(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_add_tz(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   Adds two input vectors segment by segment in round-to-zero mode. This function is calculated in the same way as ::__bang_cycle_add function. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 3.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "cycle_adds": "void __bang_cycle_adds(unsigned int *dst, const unsigned int *src, const unsigned int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_adds(unsigned short *dst, const unsigned short *src, const unsigned short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_adds(unsigned char *dst, const unsigned char *src, const unsigned char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_adds(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_adds(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_adds(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   This function divides <src> into N parts ( N = <src\\_elem\\_count> / <seg\\_elem\\_count> ), adds each element in each part of <src> and the corresponding element in <seg>, and assigns the saturated result to <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "cycle_mul": "void __bang_cycle_mul(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mul(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mul(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mul(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mul(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mul(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   This function divides <src> into N parts ( N = <src\\_elem\\_count> / <seg\\_elem\\_count> ), multiplies each element in each part of <src> and the corresponding element in <seg>, and assigns the result to <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short and char;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_mulh": "void __bang_cycle_mulh(unsigned int *dst, const unsigned int *src, const unsigned int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mulh(unsigned short *dst, const unsigned short *src, const unsigned short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mulh(unsigned char *dst, const unsigned char *src, const unsigned char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mulh(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mulh(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_mulh(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   This function divides <src> into N parts ( N = <src\\_elem\\_count> / <seg\\_elem\\_count> ), multiplies each element in each part of <src> and the corresponding element in <seg>, and assigns the upper half of result to <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "cycle_muls": "void __bang_cycle_muls(unsigned short *dst, const unsigned char *src, const unsigned char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_muls(unsigned int *dst, const unsigned short *src, const unsigned short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_muls(int *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_muls(short *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   This function divides <src> into N parts ( N = <src\\_elem\\_count> / <seg\\_elem\\_count> ), multiplies each element in each part of <src> and the corresponding element in <seg>, and assigns the result to <dst>. The size of <dst> is twice as long as that of <src>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <seg\\_elem\\_count> \\* sizeof(source type) cannot be greater than 65536 on tp\\_322;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "cycle_sub": "void __bang_cycle_sub(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_sub(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_sub(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_sub(half *dst, const half *src, const half *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_sub(bfloat16_t *dst, const bfloat16_t *src, const bfloat16_t *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_sub(float *dst, const float *src, const float *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   This function divides <src> into N parts ( N = <src\\_elem\\_count> / <seg\\_elem\\_count> ), subtracts each element in each part of <src> and the corresponding element in <seg>, and assigns the result to <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src\\_elem\\_count> \\* sizeof(type) and <seg\\_elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322 when vector type is int, short and char;\n* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <seg> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "cycle_subs": "void __bang_cycle_subs(unsigned int *dst, const unsigned int *src, const unsigned int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_subs(unsigned short *dst, const unsigned short *src, const unsigned short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_subs(unsigned char *dst, const unsigned char *src, const unsigned char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_subs(int *dst, const int *src, const int *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_subs(short *dst, const short *src, const short *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   void __bang_cycle_subs(char *dst, const char *src, const char *seg, unsigned int src_elem_count, unsigned int seg_elem_count)   This function divides <src> into N parts ( N = <src\\_elem\\_count> / <seg\\_elem\\_count> ), subtracts each element in each part of <src> and the corresponding element in <seg>, and assigns the saturated result to <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] seg: The address of second source vector.\n* [in] src\\_elem\\_count: The number of elements in <src> vector.\n* [in] seg\\_elem\\_count: The number of elements in <seg> vector. Return* void. Remark* <src\\_elem\\_count> must be divisible by <seg\\_elem\\_count>;\n* <src\\_elem\\_count> and <seg\\_elem\\_count> must be greater than zero;\n* <seg\\_elem\\_count> \\* sizeof(type) cannot be greater than 65536 on tp\\_322;\n* <src>, <seg> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "findfirst1": "void __bang_findfirst1(unsigned int *dst, const half *src, unsigned int elem_count)   void __bang_findfirst1(unsigned int *dst, const float *src, unsigned int elem_count)   Finds the first non-zero data in the values of <src>, and stores the index of the first non-zero data in the first element of <dst>. If <src> is all zero, stores 0xffff-ffff. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <elem\\_count> \\* sizeof (type) must be divisible by 128 on (m)tp\\_2xx;\n* The total number of bytes of <dst> is at least 128 on (m)tp\\_2xx, and at least 4 on (m)tp\\_3xx;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_findfirst1 instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "findlast1": "void __bang_findlast1(unsigned int *dst, const half *src, unsigned int elem_count)   void __bang_findlast1(unsigned int *dst, const float *src, unsigned int elem_count)   Finds the last non-zero data in the values of <src>, and stores the index of the last non-zero data in <dst>. If <src> is all zero, stores 0xffff-ffff. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <elem\\_count> \\* sizeof (type) must be divisible by 128 on (m)tp\\_2xx;\n* The total number of bytes of <dst> is at least 128 on (m)tp\\_2xx, and at least 4 on (m)tp\\_3xx;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_findlast1 instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "floor": "void __bang_floor(float *dst, const float *src, unsigned int elem_count)   This function performs floor operation element-wisely on <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "histogram": "void __bang_histogram(half *dst, const int8_t *src, const int8_t *kernel, unsigned int size)   void __bang_histogram(float *dst, const int8_t *src, const int8_t *kernel, unsigned int size)   void __bang_histogram(int16_t *dst, const int8_t *src, const int8_t *kernel, unsigned int size)   void __bang_histogram(int32_t *dst, const int8_t *src, const int8_t *kernel, unsigned int size)   void __bang_histogram(half *dst, const int16_t *src, const int16_t *kernel, unsigned int size)   void __bang_histogram(float *dst, const int16_t *src, const int16_t *kernel, unsigned int size)   void __bang_histogram(int16_t *dst, const int16_t *src, const int16_t *kernel, unsigned int size)   void __bang_histogram(int32_t *dst, const int16_t *src, const int16_t *kernel, unsigned int size)   void __bang_histogram(float *dst, const half *src, const half *kernel, unsigned int size)   void __bang_histogram(float *dst, const bfloat16_t *src, const bfloat16_t *kernel, unsigned int size)   Generates a histogram of <src> according to kernel. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information;\nThe data layout of <kernel> is 64 rows. Every row is 64 bytes, and the value of each row is corresponding to the histogram of x-axis. There are 32 values in each row when data type is int16\\_t, half or bfloat16\\_t, and 64 values when data type is int8\\_t. Parameters* [out] dst: The address of destination vector\n* [in] src: The address of source vector\n* [in] kernel: The address of kernel vector\n* [in] size: The elements number of source vector Return* void. Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <kernel> must point to \\_\\_wram\\_\\_ address space;\n* The address of <dst> and <src> must be 64-byte aligned;\n* The address of <kernel> must be 32-byte aligned;\n* <size> \\* sizeof(typeof<src>) must be 64-byte aligned on (m)tp\\_2xx;\n* The element number of <dst> is 64;\n* <size> must be greater than 0;\n* <dst> cannot be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 220 except 270 and 290;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20 except (m)tp\\_270 and mtp\\_290;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_220 except (m)tp\\_270. Compatibility between Various Architectures Table 3.60 Histogram Data Types Supported on (m)tp\\_220 | Src Type | Kernel Type | Dst Type |\n| --- | --- | --- |\n| int8_t | int8_t | int16_t |\n| int8_t | int8_t | int32_t |\n| int8_t | int8_t | half |\n| int8_t | int8_t | float |\n| int16_t | int16_t | int16_t |\n| int16_t | int16_t | int32_t |\n| int16_t | int16_t | half |\n| int16_t | int16_t | float | Table 3.61 Histogram Data Types Supported on mtp\\_372 | Src Type | Kernel Type | Dst Type |\n| --- | --- | --- |\n| int8_t | int8_t | half |\n| int8_t | int8_t | float |\n| int8_t | int8_t | int16_t |\n| int8_t | int8_t | int32_t |\n| int16_t | int16_t | half |\n| int16_t | int16_t | float |\n| int16_t | int16_t | int16_t |\n| int16_t | int16_t | int32_t |\n| half | half | float |\n| bfloat16_t | bfloat16_t | float | Table 3.62 Histogram Data Types Supported on tp\\_322 and tp\\_520 | Src Type | Kernel Type | Dst Type |\n| --- | --- | --- |\n| int8_t | int8_t | half |\n| int8_t | int8_t | float |\n| int8_t | int8_t | int16_t |\n| int8_t | int8_t | int32_t |\n| int16_t | int16_t | half |\n| int16_t | int16_t | float |\n| int16_t | int16_t | int16_t |\n| int16_t | int16_t | int32_t | Table 3.63 Histogram Data Types Supported on (m)tp\\_59x | Src Type | Kernel Type | Dst Type |\n| --- | --- | --- |\n| int8_t | int8_t | half |\n| int8_t | int8_t | float |\n| int8_t | int8_t | int16_t |\n| int8_t | int8_t | int32_t |\n| half | half | float |\n| bfloat16_t | bfloat16_t | float | Example For example, <src> is [0, 1, 2, 3, 0, 1, 2, 3, 3] and data type of <src> is int16\\_t. If all numbers in kernel’s first line are 1, all numbers in kernel’s second line are 3, all numbers in kernel’s third line are 9, data type of <kernel> is int16\\_t. For <dst>, dst[0] is 2, which is equal to how many number 1(data of first line of kernel) in the <src>.dst[2] is 0, because there is no number 9(data of third line of kernel) in<src>. So <dst> is [2, 3, 0, 0, 0, ...] and the number of elements of <dst> is 64 and data type of <dst> is int32\\_t. ```",
    "integral": "void __bang_integral(int *dst, const short *src, const short *kernel, unsigned int size)   void __bang_integral(short *dst, const short *src, const short *kernel, unsigned int size)   void __bang_integral(half *dst, const int16_t *src, const int16_t *kernel, unsigned int size, int fix_position)   void __bang_integral(float *dst, const int16_t *src, const int16_t *kernel, unsigned int size, int fix_position)   void __bang_integral(int *dst, const char *src, const char *kernel, unsigned int size)   void __bang_integral(short *dst, const char *src, const char *kernel, unsigned int size)   void __bang_integral(half *dst, const int8_t *src, const int8_t *kernel, unsigned int size, int fix_position)   void __bang_integral(float *dst, const int8_t *src, const int8_t *kernel, unsigned int size, int fix_position)   void __bang_integral(float *dst, const float *src, const float *kernel, unsigned int size)   void __bang_integral(float *dst, const bfloat16_t *src, const bfloat16_t *kernel, unsigned int size)   void __bang_integral(float *dst, const half *src, const half *kernel, unsigned int size)   Generates integral of the input vector <src> according to <kernel>. When the value of Lower Triangular Matrix(LTM) of <kernel> are 1 and the other values are 0, it is equivalent to the prefix sum of the input vector <src>;\nGenerally, the value of elements in the LTM of <kernel> should be 1, so <dst>[n] is the sum of <src>[0] to <src>[n]. More details can be found in the example. Parameters* [out] dst: The address of destination vector\n* [in] src: The address of source vector\n* [in] kernel: The address of kernel vector\n* [in] size: The elements number of source vector\n* [in] fix\\_position: Sum of scale factor of <src> and <kernel>. Return* void. Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <kernel> must point to \\_\\_wram\\_\\_ address space;\n* The address of <dst> and <src> must be 64-byte aligned;\n* The address of <kernel> must be 32-byte aligned;\n* <size> \\* sizeof(typeof<src>) must be 64-byte aligned;\n* <size> \\* sizeof(typeof<src>) cannot be greater than 65472;\n* <dst> cannot be overlapped with <src>;\n* When data type of <src> is int8\\_t or char, <kernel> should be (64 \\times 64) Lower Triangular Matrix(LTM); when data type of <src> is int16\\_t, short or half, <kernel> should be (32 \\times 32) LTM; when datatype of <src> is float, <kernel> should be (16 \\times 16) LTM; kernel always requires 4096 bytes of memory, LTM should be placed at the beginning of the memory;\n* <fix\\_position> must be in the range [-127, 127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Compatibility between Various Architectures Table 3.64 Integral Data Types Supported on mtp\\_372 | Src Type | Kernel Type | Dst Type |\n| --- | --- | --- |\n| int8_t | int8_t | int16_t |\n| int8_t | int8_t | float |\n| int8_t | int8_t | half |\n| int16_t | int16_t | float |\n| int16_t | int16_t | half |\n| short | short | int |\n| short | short | short |\n| char | char | int |\n| char | char | short |\n| float | float | float |\n| half | half | float |\n| bfloat16_t | bfloat16_t | float | Table 3.65 Integral Data Types Supported on tp\\_322 and tp_520`` | Src Type | Kernel Type | Dst Type |\n| --- | --- | --- |\n| int8_t | int8_t | int16_t |\n| int8_t | int8_t | float |\n| int8_t | int8_t | half |\n| int16_t | int16_t | float |\n| int16_t | int16_t | half |\n| short | short | int |\n| short | short | short |\n| char | char | int |\n| char | char | short | Table 3.66 Integral Data Types Supported on (m)tp\\_59x | Src Type | Kernel Type | Dst Type |\n| --- | --- | --- |\n| int8_t | int8_t | float |\n| int8_t | int8_t | half |\n| char | char | int |\n| char | char | short |\n| float | float | float |\n| half | half | float |\n| bfloat16_t | bfloat16_t | float | Example When Lower Triangular Matrix of <kernel> value to k and the other value to 0. <dst>[n] is k times the sum of <src>[0] to <src>[n]; If k is 1, <size> is 64, <src> is [1, 1, ... , 1, 1] and data type of <src> is short, <dst> should be [1, 2, 3, ..., 63, 64] and data type of <dst> is int; If k is 2, <size> is 64, <src> is [1, 1, ... , 1, 1] and data type of <src> is short, <dst> should be [2, 4, 6, ... 126, 128] and data type of <dst> is int. ```",
    "lut": "void __bang_lut(int32_t *dst, const uint32_t *index, const int32_t *table, unsigned int elem_count, unsigned int table_length)   void __bang_lut(int32_t *dst, const uint16_t *index, const int32_t *table, unsigned int elem_count, unsigned int table_length)   void __bang_lut(int32_t *dst, const uint8_t *index, const int32_t *table, unsigned int elem_count, unsigned int table_length)   void __bang_lut(int16_t *dst, const uint16_t *index, const int16_t *table, unsigned int elem_count, unsigned int table_length)   void __bang_lut(int16_t *dst, const uint8_t *index, const int16_t *table, unsigned int elem_count, unsigned int table_length)   Applies lookup-table operation on <index>, value in <dst> remains unchanged if the corresponding value in <index> is greater than or equal to <table\\_length>. Table 3.67 Data Types Supported on (m)tp\\_220, tp\\_322, mtp\\_372 and mtp\\_592 | Index Type | Table Type | Dst Type | table_length |\n| --- | --- | --- | --- |\n| uint16_t | int16_t | int16_t | 64 aligned |\n| uint32_t | int32_t | int32_t | 64 aligned | Table 3.68 Data Types Supported on tp\\_520 | Index Type | Table Type | Dst Type | table_length |\n| --- | --- | --- | --- |\n| uint16_t | int16_t | int16_t | 64 aligned |\n| uint32_t | int32_t | int32_t | 64 aligned |\n| uint8_t | int16_t | int16_t | 128 aligned |\n| uint8_t | int32_t | int32_t | 128 aligned |\n| uint16_t | int32_t | int32_t | 128 aligned | Parameters* [out] dst: The address of destination vector.\n* [in] index: The address of index vector.\n* [in] table: The address of table vector.\n* [in] elem\\_count: Number of elements in index vector.\n* [in] table\\_length: Number of elements in table vector. Return* void. Remark* <index>, <table> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <index>, <table> and <dst> must be 64-byte aligned on (m)tp\\_220;\n* <elem\\_count> and <table\\_length> must be greater than zero;\n* <elem\\_count> must be divisible by 64 on (m)tp\\_220;\n* <dst>, <table> and <index> cannot be overlapped. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 220 except 270 and 290;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20 except (m)tp\\_270 and mtp\\_290;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_220 except (m)tp\\_270 and mtp\\_290. Example\n```\n  #include  __mlu_entry__ void kernel() {\n  __nram__ int dst[128] = {0,0,0,0,0,100,100};\n  __nram__ int idx[128] = {0,1,2,3,4,5,2277};\n  __nram__ int tbl[128] = {5,4,3,2,1};\n  __bang_lut(dst, idx, tbl, 8, 64);\n  // output: 5,4,3,2,1,0,100,5\n  printf(\"%d,%d,%d,%d,%d,%d,%d,%d\\n\",\n         dst[0], dst[1], dst[2], dst[3],\n         dst[4], dst[5], dst[6], dst[7]);\n} ```",
    "lut_s16": "void __bang_lut_s16(int16_t *dst, const int16_t *index, const int16_t *table, unsigned int elem_count, unsigned int table_length)   Applies lookup-table operation on <index>. Parameters* [out] dst: The address of destination vector.\n* [in] index: The address of index vector.\n* [in] table: The address of table vector.\n* [in] elem\\_count: Number of elements in index vector.\n* [in] table\\_length: Number of elements in table vector. Return* void. Remark* <index>, <table> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <index>, <table> and <dst> must be 64-byte aligned on (m)tp\\_220;\n* The data type of <dst> and <table> can be any type with the same size as that of <src>;\n* <elem\\_count> and <table\\_length> must be greater than zero;\n* <elem\\_count> must be divisible by 64 on (m)tp\\_220;\n* <dst>, <table> and <index> cannot be overlapped;\n* <table\\_length> must be divisible by 64. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 220 except 270 and 290;\n* CNCC Version: cncc --version >= 3.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20 except (m)tp\\_270 and mtp\\_290;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_220 except (m)tp\\_270 and mtp\\_290. Example* None.",
    "lut_s32": "void __bang_lut_s32(int *dst, const int *index, const int *table, unsigned int elem_count, unsigned int table_length)   Applies lookup-table operation on <index>. Parameters* [out] dst: The address of destination vector.\n* [in] index: The address of index vector.\n* [in] table: The address of table vector.\n* [in] elem\\_count: Number of elements in index vector.\n* [in] table\\_length: Number of elements in table vector. Return* void. Remark* <index>, <table> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <index>, <table> and <dst> must be 64-byte aligned on (m)tp\\_220;\n* The data type of <dst> and <table> can be any type with the same size as that of <src>;\n* <elem\\_count> and <table\\_length> must be greater than zero;\n* <elem\\_count> must be divisible by 64 on (m)tp\\_220;\n* <dst>, <table> and <index> cannot be overlapped;\n* <table\\_length> must be divisible by 64. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 220 except 270 and 290;\n* CNCC Version: cncc --version >= 3.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20 except (m)tp\\_270 and mtp\\_290;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_220 except (m)tp\\_270 and mtp\\_290. Example* None.",
    "mul": "void __bang_mul(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_mul(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_mul(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_mul(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_mul(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_mul(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs multiplication operation element-wisely on <src0> and <src1> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_add for more details.",
    "mul_scalar": "void __bang_mul_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_mul_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_mul_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_mul_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_mul_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_mul_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function multiplies <elem\\_count> elements of <src> by <value> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_add_scalar for more details.",
    "mulh": "void __bang_mulh(unsigned int *dst, const unsigned int *src0, const unsigned int *src1, unsigned int elem_count)   void __bang_mulh(unsigned short *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_mulh(unsigned char *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_mulh(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_mulh(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_mulh(int *dst, const int *src0, const int *src1, unsigned int elem_count)   This function performs multiplication operation element-wisely on <src0> and <src1> and saves the result in <dst>. Only upper half of each result is stored in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "mulh_scalar": "void __bang_mulh_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_mulh_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_mulh_scalar(int *dst, const int *src, int value, unsigned int elem_count)   This function multiplies <value> by <elem\\_count> elements of <src> and saves the result in <dst>. Only the upper half of each result is stored in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "muls": "void __bang_muls(unsigned short *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_muls(unsigned int *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_muls(short *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_muls(int *dst, const short *src0, const short *src1, unsigned int elem_count)   This function performs multiplication operation element-wisely on <src0> and <src1> and saves the result in <dst>. The size of <dst> is twice as long as that of <src0> and <src1>. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "muls_scalar": "void __bang_muls_scalar(unsigned short *dst, const unsigned char *src, unsigned char value, unsigned int elem_count)   void __bang_muls_scalar(unsigned int *dst, const unsigned short *src, unsigned short value, unsigned int elem_count)   void __bang_muls_scalar(short *dst, const char *src, char value, unsigned int elem_count)   void __bang_muls_scalar(int *dst, const short *src, short value, unsigned int elem_count)   This function multiplies <value> by <elem\\_count> elements of <src> and saves the result in <dst>. The size of <dst> is twice as long as that of <src>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "nearbyint": "void __bang_nearbyint(float *dst, const float *src, unsigned int elem_count)   This function performs round operation element-wisely on <src> in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "neg": "void __bang_neg(char *dst, const char *src, unsigned int elem_count)   void __bang_neg(short *dst, const short *src, unsigned int elem_count)   void __bang_neg(int *dst, const int *src, unsigned int elem_count)   This function computes the opposite value of <src> element-wisely and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "nsa": "void __bang_nsa(char *dst, const char *src, unsigned int elem_count)   void __bang_nsa(short *dst, const short *src, unsigned int elem_count)   void __bang_nsa(unsigned char *dst, const unsigned char *src, unsigned int elem_count)   void __bang_nsa(unsigned short *dst, const unsigned short *src, unsigned int elem_count)   void __bang_nsa(unsigned int *dst, const unsigned int *src, unsigned int elem_count)   void __bang_nsa(int *dst, const int *src, unsigned int elem_count)   This function counts the leading zeros or ones in <src> element-wisely and saves the result in <dst>. A leading zero is any digit that comes before the first nonzero digit in binary without the signed bit. If the value of element in <src> is a signed positive number, the result is the number of leading zeros minus one; if it is a negative number, the result is the number of leading ones minus one; if it is an unsigned number, the result is the number of leading zeros. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "popcnt": "int __bang_popcnt(const unsigned int *src, unsigned int elem_count)   int __bang_popcnt(const unsigned short *src, unsigned int elem_count)   int __bang_popcnt(const unsigned char *src, unsigned int elem_count)   Counts the number of bits that are set to 1 in <src>. Parameters* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* int. Remark* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 3.4.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "rand": "void __bang_rand(short *dst, unsigned int elem_count)   Generates a vector of uniformly distributed random number of short type. Parameters* [out] dst: The address of destination vector.\n* [in] elem\\_count: The number of elements in destination vector. Return* void. Remark* <elem\\_count> must be greater than zero and divisible by 64;\n* <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of must be 64-byte aligned on (m)tp\\_2xx. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200 except 520;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx except tp\\_520. Example\n```",
    "reduce_sum": "void __bang_reduce_sum(half *dst, const half *src, unsigned int elem_count)   void __bang_reduce_sum(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_reduce_sum(float *dst, const float *src, unsigned int elem_count)   Takes every 128-byte data from <src> to add them up and stores the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* The total number of bytes of <dst> is at least 128;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128;\n* The first element of every 128 bytes in destination operand <dst> is the sum of every 128-byte data, the other elements in destination operand <dst> of every 128 bytes will be set to zero on (m)tp\\_2xx, and they will not be changed on (m)tp\\_3xx;\n* This instruction takes every 128 bytes to calculate each time. When vector type is float, This function will take the 32 elements to calculate. When vector type is half, This function will take the 64 elements to calculate. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "rol": "void __bang_rol(unsigned char *dst, const unsigned char *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_rol(unsigned short *dst, const unsigned short *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_rol(unsigned int *dst, const unsigned int *src, unsigned int shift_bits, unsigned int elem_count)   This function performs left rotation operation on <src> element-wisely with <shift\\_bits> bits and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the source vector.\n* [in] shift\\_bits: The number of bits left shifted.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <shift\\_bits> must be greater than or equal to zero;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "ror": "void __bang_ror(unsigned char *dst, const unsigned char *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_ror(unsigned short *dst, const unsigned short *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_ror(unsigned int *dst, const unsigned int *src, unsigned int shift_bits, unsigned int elem_count)   This function performs right rotation operation on <src> element-wisely with <shift\\_bits> bits and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the source vector.\n* [in] shift\\_bits: The number of bits right shifted.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <shift\\_bits> must be greater than or equal to zero;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "round": "void __bang_round(float *dst, const float *src, unsigned int elem_count)   This function performs round operation element-wisely on <src> in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> cannot be overlapped with <src>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "set0in32": "void __bang_set0in32(void *dst, const void *src, int position, unsigned int elem_count)   Set the specified bit to 0. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] position: The specified position to be set to 0.\n* [in] elem\\_count: Number of elements in source. Return* void. Remark* <elem\\_count> must be greater than zero;\n* The bit width of element in <src> and <dst> is 32 bits;\n* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "set1in32": "void __bang_set1in32(void *dst, const void *src, int position, unsigned int elem_count)   Set the specified bit to 1. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] position: The specified position to be set to 1.\n* [in] elem\\_count: Number of elements in source. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* The bit width of element in <src> and <dst> is 32 bits;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "sll": "void __bang_sll(char *dst, const char *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_sll(short *dst, const short *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_sll(int *dst, const int *src, unsigned int shift_bits, unsigned int elem_count)   This function performs logical left shift element-wisely on <src> with <shift\\_bits> bits and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the first source vector.\n* [in] shift\\_bits: The number of bits left shifted.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <shift\\_bits> must be greater than or equal to zero;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "square": "void __bang_square(unsigned short *dst, const unsigned char *src, unsigned int elem_count)   void __bang_square(unsigned int *dst, const unsigned short *src, unsigned int elem_count)   void __bang_square(short *dst, const char *src, unsigned int elem_count)   void __bang_square(int *dst, const short *src, unsigned int elem_count)   void __bang_square(half *dst, const half *src, unsigned int elem_count)   void __bang_square(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_square(float *dst, const float *src, unsigned int elem_count)   Applies square activation operation on <src> element-wisely, and stores the result in <dst>. ( = ^2). See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* int, short, unsigned int and unsigned short are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> can be overlapped with <src>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "sra": "void __bang_sra(char *dst, const char *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_sra(short *dst, const short *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_sra(int *dst, const int *src, unsigned int shift_bits, unsigned int elem_count)   This function performs arithmetic right shift element-wisely on <src> with <shift\\_bits> bits and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the first source vector.\n* [in] shift\\_bits: The number of bits right shifted.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <shift\\_bits> must be greater than or equal to zero;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "srl": "void __bang_srl(unsigned char *dst, const unsigned char *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_srl(unsigned short *dst, const unsigned short *src, unsigned int shift_bits, unsigned int elem_count)   void __bang_srl(unsigned int *dst, const unsigned int *src, unsigned int shift_bits, unsigned int elem_count)   This function performs logical right shift element-wisely on <src> with <shift\\_bits> bits and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of the first source vector.\n* [in] shift\\_bits: The number of bits right shifted.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <shift\\_bits> must be greater than or equal to zero;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example* None.",
    "sub": "void __bang_sub(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_sub(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_sub(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_sub(unsigned char *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_sub(half *dst, const half *src0, const half *src1, unsigned int elem_count)   void __bang_sub(bfloat16_t *dst, const bfloat16_t *src0, const bfloat16_t *src1, unsigned int elem_count)   void __bang_sub(float *dst, const float *src0, const float *src1, unsigned int elem_count)   This function performs subtraction operation element-wisely on <src0> and <src1> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src0>, <src1> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_add for more details.",
    "sub_scalar": "void __bang_sub_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_sub_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_sub_scalar(int *dst, const int *src, int value, unsigned int elem_count)   void __bang_sub_scalar(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_sub_scalar(bfloat16_t *dst, const bfloat16_t *src, bfloat16_t value, unsigned int elem_count)   void __bang_sub_scalar(float *dst, const float *src, float value, unsigned int elem_count)   This function subtracts <value> from <elem\\_count> elements of <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero;\n* int, short and char are supported on (m)tp\\_3xx or higher except tp\\_520;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_add_scalar for more details.",
    "subs": "void __bang_subs(unsigned char *dst, const unsigned char *src0, const unsigned char *src1, unsigned int elem_count)   void __bang_subs(unsigned short *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_subs(unsigned int *dst, const unsigned int *src0, const unsigned int *src1, unsigned int elem_count)   void __bang_subs(char *dst, const char *src0, const char *src1, unsigned int elem_count)   void __bang_subs(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_subs(int *dst, const int *src0, const int *src1, unsigned int elem_count)   This function performs saturated subtraction operation element-wisely on <src0> and <src1> and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0>, <src1> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst>, <src0> and <src1> can be overlapped;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "subs_scalar": "void __bang_subs_scalar(char *dst, const char *src, char value, unsigned int elem_count)   void __bang_subs_scalar(short *dst, const short *src, short value, unsigned int elem_count)   void __bang_subs_scalar(int *dst, const int *src, int value, unsigned int elem_count)   This function subtracts <value> from <elem\\_count> elements of <src> and saves the saturated result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372 and 520;\n* CNCC Version: cncc --version >= 3.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372 and tp\\_520. Example* None.",
    "sum": "half __bang_sum(const half *src, unsigned int elem_count)   bfloat16_t __bang_sum(const bfloat16_t *src, unsigned int elem_count)   float __bang_sum(const float *src, unsigned int elem_count)   Accumulates all data from source operand <src>. Parameters* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source vector. Return* The result of accumulation. Remark* <src> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520 ;\n* CNCC Version: cncc --version >= 3.5.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx . Example* None.",
    "cos": "void __bang_cos(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_cos(float *dst, const float *src, unsigned int elem_count)   This function computes the cosine of each element in <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source and destination. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example* See the example of __bang_sin for more details.",
    "div": "void __bang_div(half *dst, const half *src0, const half *src1, half *src_addition, unsigned int elem_count)   void __bang_div(float *dst, const float *src0, const float *src1, float *src_addition, unsigned int elem_count)   This function performs division operation element-wisely on <src0> and <src1> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Div Operation Function for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of the first source vector.\n* [in] src1: The address of the second source vector.\n* [in] src\\_addition: The address of additional vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <src0>, <src1>, <dst> and <src\\_addition> must point to \\_\\_nram\\_\\_ address space;\n* <src0>, <src1>, <dst> and <src\\_addition> cannot be overlapped;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128;\n* The size of <src\\_addition> vector is identical to the size of <src0>, <src1> and <dst>;\n* <elem\\_count> must be greater than zero;\n* For higher precision, use surpass function __bang_div on tp\\_322 instead;\n* For higher precision, use __bang_recip and __bang_mul on mtp\\_372 instead;\n* This function was deprecated from CNCC v4.0.0. Use __bang_div instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "log": "void __bang_log(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_log(float *dst, const float *src, unsigned int elem_count)   This function computes the binary logarithm of each element in <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source and destination. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example* See the example of __bang_sin for more details.",
    "pow2": "void __bang_pow2(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_pow2(float *dst, const float *src, unsigned int elem_count)   This function computes the value of 2 to the power of <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source and destination. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example* See the example of __bang_sin for more details.",
    "recip": "void __bang_recip(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_recip(float *dst, const float *src, unsigned int elem_count)   This function computes the reciprocal of each element in <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source and destination. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example* See the example of __bang_sin for more details.",
    "rem": "void __bang_rem(short *dst, const short *src0, const short *src1, unsigned int elem_count)   void __bang_rem(int *dst, const int *src0, const int *src1, unsigned int elem_count)   void __bang_rem(unsigned short *dst, const unsigned short *src0, const unsigned short *src1, unsigned int elem_count)   void __bang_rem(unsigned int *dst, const unsigned int *src0, const unsigned int *src1, unsigned int elem_count)   void __bang_rem(short *dst, const short *src0, short src1, unsigned int elem_count)   void __bang_rem(int *dst, const int *src0, int src1, unsigned int elem_count)   void __bang_rem(unsigned short *dst, const unsigned short *src0, unsigned short src1, unsigned int elem_count)   void __bang_rem(unsigned int *dst, const unsigned int *src0, unsigned int src1, unsigned int elem_count)   This function computes the remainder of each element in <src> and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src0: The address of first source vector.\n* [in] src1: The address of second source vector, or the value of second source scalar.\n* [in] elem\\_count: Number of elements in source and destination. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> and <src0> must point to \\_\\_nram\\_\\_ address space;\n* <src1> must point to \\_\\_nram\\_\\_ address space if it is a vector;\n* The value of <src1> cannot be equal to zero;\n* <dst>, <src0> and <src1> (vector address) can be overlapped. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 372;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 except mtp\\_372;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except mtp\\_372. Example\n```",
    "rsqrt": "void __bang_rsqrt(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_rsqrt(float *dst, const float *src, unsigned int elem_count)   This function computes the reciprocal of square root of each element in <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source and destination. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example* See the example of __bang_sin for more details.",
    "sin": "void __bang_sin(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_sin(float *dst, const float *src, unsigned int elem_count)   This function computes the sine of each element in <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source and destination. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example\n```",
    "sqrt": "void __bang_sqrt(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_sqrt(float *dst, const float *src, unsigned int elem_count)   This function computes the square root of each element in <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: Number of elements in source and destination. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx . Example* See the example of __bang_sin for more details.",
    "bfloat162float": "void __bang_bfloat162float(float *dst, const bfloat16_t *src, unsigned int src_count)   This function converts type of <src> from bfloat16\\_t to float element-wisely and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bfloat162half": "void __bang_bfloat162half(half *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to half element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162half_dn": "void __bang_bfloat162half_dn(half *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to half element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162half_oz": "void __bang_bfloat162half_oz(half *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to half element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162half_rd": "void __bang_bfloat162half_rd(half *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to half element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162half_rm": "void __bang_bfloat162half_rm(half *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to half element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162half_rn": "void __bang_bfloat162half_rn(half *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to half element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162half_tz": "void __bang_bfloat162half_tz(half *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to half element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162half_up": "void __bang_bfloat162half_up(half *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to half element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int16": "void __bang_bfloat162int16(int16_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int16_dn": "void __bang_bfloat162int16_dn(int16_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int16_oz": "void __bang_bfloat162int16_oz(int16_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int16_rd": "void __bang_bfloat162int16_rd(int16_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int16_rm": "void __bang_bfloat162int16_rm(int16_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int16_rn": "void __bang_bfloat162int16_rn(int16_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int16_tz": "void __bang_bfloat162int16_tz(int16_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int16_up": "void __bang_bfloat162int16_up(int16_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int32": "void __bang_bfloat162int32(int32_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int32_dn": "void __bang_bfloat162int32_dn(int32_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int32\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int32_oz": "void __bang_bfloat162int32_oz(int32_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int32\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int32_rd": "void __bang_bfloat162int32_rd(int32_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int32\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int32_rm": "void __bang_bfloat162int32_rm(int32_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int32\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int32_rn": "void __bang_bfloat162int32_rn(int32_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int32\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int32_tz": "void __bang_bfloat162int32_tz(int32_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int32_up": "void __bang_bfloat162int32_up(int32_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int32\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int4_dn": "void __bang_bfloat162int4_dn(int4x2_t *dst, const bfloat16_t *src, unsigned int size, int dst_position)   This function converts type of <src> from bfloat16\\_t to int4 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bfloat162int4_oz": "void __bang_bfloat162int4_oz(int4x2_t *dst, const bfloat16_t *src, unsigned int size, int dst_position)   This function converts type of <src> from bfloat16\\_t to int4 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bfloat162int4_rd": "void __bang_bfloat162int4_rd(int4x2_t *dst, const bfloat16_t *src, unsigned int size, int dst_position)   This function converts type of <src> from bfloat16\\_t to int4 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bfloat162int4_rm": "void __bang_bfloat162int4_rm(int4x2_t *dst, const bfloat16_t *src, unsigned int size, int dst_position)   This function converts type of <src> from bfloat16\\_t to int4 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bfloat162int4_rn": "void __bang_bfloat162int4_rn(int4x2_t *dst, const bfloat16_t *src, unsigned int size, int dst_position)   This function converts type of <src> from bfloat16\\_t to int4 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bfloat162int4_tz": "void __bang_bfloat162int4_tz(int4x2_t *dst, const bfloat16_t *src, unsigned int size, int dst_position)   This function converts type of <src> from bfloat16\\_t to int4 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bfloat162int4_up": "void __bang_bfloat162int4_up(int4x2_t *dst, const bfloat16_t *src, unsigned int size, int dst_position)   This function converts type of <src> from bfloat16\\_t to int4 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "bfloat162int8": "void __bang_bfloat162int8(int8_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int8_dn": "void __bang_bfloat162int8_dn(int8_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int8\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int8_oz": "void __bang_bfloat162int8_oz(int8_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int8\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int8_rd": "void __bang_bfloat162int8_rd(int8_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int8\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int8_rm": "void __bang_bfloat162int8_rm(int8_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int8\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int8_rn": "void __bang_bfloat162int8_rn(int8_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int8\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int8_tz": "void __bang_bfloat162int8_tz(int8_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162int8_up": "void __bang_bfloat162int8_up(int8_t *dst, const bfloat16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from bfloat16\\_t to int8\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162tf32": "void __bang_bfloat162tf32(float *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to tf32 element-wisely and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162uchar": "void __bang_bfloat162uchar(unsigned char *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162uchar_dn": "void __bang_bfloat162uchar_dn(unsigned char *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to unsigned char element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162uchar_oz": "void __bang_bfloat162uchar_oz(unsigned char *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to unsigned char element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162uchar_rd": "void __bang_bfloat162uchar_rd(unsigned char *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to unsigned char element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162uchar_rm": "void __bang_bfloat162uchar_rm(unsigned char *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to unsigned char element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162uchar_rn": "void __bang_bfloat162uchar_rn(unsigned char *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to unsigned char element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162uchar_tz": "void __bang_bfloat162uchar_tz(unsigned char *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "bfloat162uchar_up": "void __bang_bfloat162uchar_up(unsigned char *dst, const bfloat16_t *src, unsigned int count)   This function converts type of <src> from bfloat16\\_t to unsigned char element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2bfloat16_dn": "void __bang_float2bfloat16_dn(bfloat16_t *dst, const float *src, unsigned int src_count)   This function converts type of <src> from float to bfloat16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2bfloat16_rm for more details.",
    "float2bfloat16_oz": "void __bang_float2bfloat16_oz(bfloat16_t *dst, const float *src, unsigned int src_count)   This function converts type of <src> from float to bfloat16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2bfloat16_rm for more details.",
    "float2bfloat16_rd": "void __bang_float2bfloat16_rd(bfloat16_t *dst, const float *src, unsigned int src_count)   This function converts type of <src> from float to bfloat16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2bfloat16_rm for more details.",
    "float2bfloat16_rm": "void __bang_float2bfloat16_rm(bfloat16_t *dst, const float *src, unsigned int src_count)   This function converts type of <src> from float to bfloat16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2bfloat16_rn": "void __bang_float2bfloat16_rn(bfloat16_t *dst, const float *src, unsigned int src_count)   This function converts type of <src> from float to bfloat16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2bfloat16_rm for more details.",
    "float2bfloat16_tz": "void __bang_float2bfloat16_tz(bfloat16_t *dst, const float *src, unsigned int src_count)   This function converts type of <src> from float to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2bfloat16_rm for more details.",
    "float2bfloat16_up": "void __bang_float2bfloat16_up(bfloat16_t *dst, const float *src, unsigned int src_count)   This function converts type of <src> from float to bfloat16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2bfloat16_rm for more details.",
    "float2half_dn": "void __bang_float2half_dn(half *dst, const float *src, unsigned int src_count)   void __bang_float2half_dn(half *dst, const float *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from float to half element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-down mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(float);\n* ( \\div sizeof(float) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2half_tz for more details.",
    "float2half_oz": "void __bang_float2half_oz(half *dst, const float *src, unsigned int src_count)   void __bang_float2half_oz(half *dst, const float *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from float to half element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-off-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(float);\n* ( \\div sizeof(float) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2half_tz for more details.",
    "float2half_rd": "void __bang_float2half_rd(half *dst, const float *src, unsigned int src_count)   void __bang_float2half_rd(half *dst, const float *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from float to half element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-nearest-off-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(float);\n* ( \\div sizeof(float) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2half_tz for more details.",
    "float2half_rm": "void __bang_float2half_rm(half *dst, const float *src, unsigned int src_count)   void __bang_float2half_rm(half *dst, const float *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from float to half element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-math mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(float);\n* ( \\div sizeof(float) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2half_rn": "void __bang_float2half_rn(half *dst, const float *src, unsigned int src_count)   void __bang_float2half_rn(half *dst, const float *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from float to half element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-nearest-even mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(float);\n* ( \\div sizeof(float) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2half_rm for more details.",
    "float2half_sr": "void __bang_float2half_sr(half *dst, const float *src, int *srv, unsigned int count)   Converts source vector with element type float to destination vector with element type half in round-stochastic mode. The number of elements in the source and destination vectors is <count>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] srv: The address of stochastic vector.\n* [in] count: The elements number of conversion. Return* void. Remark* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <src>, <srv> and <dst> must point to \\_\\_nram\\_\\_ address space. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "float2half_tz": "void __bang_float2half_tz(half *dst, const float *src, unsigned int src_count)   void __bang_float2half_tz(half *dst, const float *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from float to half element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-to-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(float);\n* ( \\div sizeof(float) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "float2half_up": "void __bang_float2half_up(half *dst, const float *src, unsigned int src_count)   void __bang_float2half_up(half *dst, const float *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from float to half element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-up mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(float);\n* ( \\div sizeof(float) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2half_tz for more details.",
    "float2int16_dn": "void __bang_float2int16_dn(int16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int16\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "float2int16_oz": "void __bang_float2int16_oz(int16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2int16_dn for more details.",
    "float2int16_rd": "void __bang_float2int16_rd(int16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2int16_dn for more details.",
    "float2int16_rm": "void __bang_float2int16_rm(int16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int16\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int16_dn for more details.",
    "float2int16_rn": "void __bang_float2int16_rn(int16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int16_dn for more details.",
    "float2int16_tz": "void __bang_float2int16_tz(int16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2int16_dn for more details.",
    "float2int16_up": "void __bang_float2int16_up(int16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int16\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2int16_dn for more details.",
    "float2int32": "void __bang_float2int32(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int32_dn": "void __bang_float2int32_dn(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int32_oz": "void __bang_float2int32_oz(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int32_rd": "void __bang_float2int32_rd(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int32_rm": "void __bang_float2int32_rm(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int32_rn": "void __bang_float2int32_rn(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int32_tz": "void __bang_float2int32_tz(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int32_up": "void __bang_float2int32_up(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int4_dn": "void __bang_float2int4_dn(int4x2_t *dst, const float *src, unsigned int size, int dst_position)   This function converts type of <src> from float to int4 element-wisely in round-down mode. and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int4_oz": "void __bang_float2int4_oz(int4x2_t *dst, const float *src, unsigned int size, int dst_position)   This function converts type of <src> from float to int4 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int4_rd": "void __bang_float2int4_rd(int4x2_t *dst, const float *src, unsigned int size, int dst_position)   This function converts type of <src> from float to int4 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int4_rm": "void __bang_float2int4_rm(int4x2_t *dst, const float *src, unsigned int size, int dst_position)   This function converts type of <src> from float to int4 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int4_rn": "void __bang_float2int4_rn(int4x2_t *dst, const float *src, unsigned int size, int dst_position)   This function converts type of <src> from float to int4 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int4_tz": "void __bang_float2int4_tz(int4x2_t *dst, const float *src, unsigned int size, int dst_position)   This function converts type of <src> from float to int4 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int4_up": "void __bang_float2int4_up(int4x2_t *dst, const float *src, unsigned int size, int dst_position)   This function converts type of <src> from float to int4 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int8_dn": "void __bang_float2int8_dn(int8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int8\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "float2int8_oz": "void __bang_float2int8_oz(int8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int8\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2int8_dn for more details.",
    "float2int8_rd": "void __bang_float2int8_rd(int8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int8\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2int8_dn for more details.",
    "float2int8_rm": "void __bang_float2int8_rm(int8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int8\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int8_dn for more details.",
    "float2int8_rn": "void __bang_float2int8_rn(int8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int8\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int8_dn for more details.",
    "float2int8_tz": "void __bang_float2int8_tz(int8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2int8_dn for more details.",
    "float2int8_up": "void __bang_float2int8_up(int8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int8\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_float2int8_dn for more details.",
    "float2tf32": "void __bang_float2tf32(float *dst, const float *src, unsigned int count)   This function converts type of <src> from float to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2tf32_dn": "void __bang_float2tf32_dn(float *dst, const float *src, unsigned int count)   This function converts type of <src> from float to tf32 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2tf32_oz": "void __bang_float2tf32_oz(float *dst, const float *src, unsigned int count)   This function converts type of <src> from float to tf32 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2tf32_rd": "void __bang_float2tf32_rd(float *dst, const float *src, unsigned int count)   This function converts type of <src> from float to tf32 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2tf32_rm": "void __bang_float2tf32_rm(float *dst, const float *src, unsigned int count)   This function converts type of <src> from float to tf32 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2tf32_rn": "void __bang_float2tf32_rn(float *dst, const float *src, unsigned int count)   This function converts type of <src> from float to tf32 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2tf32_sr": "void __bang_float2tf32_sr(float *dst, const float *src, const int *srv, unsigned int count)   Converts source vector with element type float to destination vector with element type tf32 in round-stochastic mode. The number of elements in the source and destination vectors is <count>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] srv: The address of stochastic vector.\n* [in] count: The elements number of conversion. Return* void. Remark* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <src>, <srv> and <dst> must point to \\_\\_nram\\_\\_ address space. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example* None.",
    "float2tf32_tz": "void __bang_float2tf32_tz(float *dst, const float *src, unsigned int count)   This function converts type of <src> from float to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2tf32_up": "void __bang_float2tf32_up(float *dst, const float *src, unsigned int count)   This function converts type of <src> from float to tf32 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "float2uchar": "void __bang_float2uchar(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from float to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uchar_dn": "void __bang_float2uchar_dn(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from float to unsigned char element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uchar_oz": "void __bang_float2uchar_oz(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from float to unsigned char element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uchar_rd": "void __bang_float2uchar_rd(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from float to unsigned char element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uchar_rm": "void __bang_float2uchar_rm(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from float to unsigned char element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uchar_rn": "void __bang_float2uchar_rn(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from float to unsigned char element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uchar_tz": "void __bang_float2uchar_tz(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from float to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uchar_up": "void __bang_float2uchar_up(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from float to unsigned char element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uint16_dn": "void __bang_float2uint16_dn(uint16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint16\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uint16_oz": "void __bang_float2uint16_oz(uint16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint16_dn for more details.",
    "float2uint16_rd": "void __bang_float2uint16_rd(uint16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint16_dn for more details.",
    "float2uint16_rm": "void __bang_float2uint16_rm(uint16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint16\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint16_dn for more details.",
    "float2uint16_rn": "void __bang_float2uint16_rn(uint16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint16_dn for more details.",
    "float2uint16_tz": "void __bang_float2uint16_tz(uint16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint16_dn for more details.",
    "float2uint16_up": "void __bang_float2uint16_up(uint16_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint16\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint16_dn for more details.",
    "float2uint32_dn": "void __bang_float2uint32_dn(uint32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint32\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uint32_oz": "void __bang_float2uint32_oz(uint32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint32\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint32_dn for more details.",
    "float2uint32_rd": "void __bang_float2uint32_rd(uint32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint32\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint32_dn for more details.",
    "float2uint32_rm": "void __bang_float2uint32_rm(uint32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint32\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint32_dn for more details.",
    "float2uint32_rn": "void __bang_float2uint32_rn(uint32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint32\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint32_dn for more details.",
    "float2uint32_tz": "void __bang_float2uint32_tz(uint32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint32_dn for more details.",
    "float2uint32_up": "void __bang_float2uint32_up(uint32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint32\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint32_dn for more details.",
    "float2uint8_dn": "void __bang_float2uint8_dn(uint8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint8\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2uint8_oz": "void __bang_float2uint8_oz(uint8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint8\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint8_dn for more details.",
    "float2uint8_rd": "void __bang_float2uint8_rd(uint8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint8\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint8_dn for more details.",
    "float2uint8_rm": "void __bang_float2uint8_rm(uint8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint8\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint8_dn for more details.",
    "float2uint8_rn": "void __bang_float2uint8_rn(uint8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint8\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint8_dn for more details.",
    "float2uint8_tz": "void __bang_float2uint8_tz(uint8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 300;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint8_dn for more details.",
    "float2uint8_up": "void __bang_float2uint8_up(uint8_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to uint8\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2uint8_dn for more details.",
    "half2bfloat16": "void __bang_half2bfloat16(bfloat16_t *dst, const half *src, unsigned int count)   This function converts type of <src> from half to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2bfloat16_dn": "void __bang_half2bfloat16_dn(bfloat16_t *dst, const half *src, unsigned int count)   This function converts type of <src> from half to bfloat16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2bfloat16_oz": "void __bang_half2bfloat16_oz(bfloat16_t *dst, const half *src, unsigned int count)   This function converts type of <src> from half to bfloat16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2bfloat16_rd": "void __bang_half2bfloat16_rd(bfloat16_t *dst, const half *src, unsigned int count)   This function converts type of <src> from half to bfloat16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2bfloat16_rm": "void __bang_half2bfloat16_rm(bfloat16_t *dst, const half *src, unsigned int count)   This function converts type of <src> from half to bfloat16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2bfloat16_rn": "void __bang_half2bfloat16_rn(bfloat16_t *dst, const half *src, unsigned int count)   This function converts type of <src> from half to bfloat16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2bfloat16_tz": "void __bang_half2bfloat16_tz(bfloat16_t *dst, const half *src, unsigned int count)   This function converts type of <src> from half to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2bfloat16_up": "void __bang_half2bfloat16_up(bfloat16_t *dst, const half *src, unsigned int count)   This function converts type of <src> from half to bfloat16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2float": "void __bang_half2float(float *dst, const half *src, unsigned int src_count)   void __bang_half2float(float *dst, const half *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-to-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(float), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(float) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> cannot be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "half2int16_dn": "void __bang_half2int16_dn(int16_t *dst, const half *src, unsigned int src_count, int fix_position)   This function converts type of <src> from half to int16\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "half2int16_oz": "void __bang_half2int16_oz(int16_t *dst, const half *src, unsigned int src_count, int fix_position)   This function converts type of <src> from half to int16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2int16_dn for more details.",
    "half2int16_rd": "void __bang_half2int16_rd(int16_t *dst, const half *src, unsigned int src_count, int fix_position)   This function converts type of <src> from half to int16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2int16_dn for more details.",
    "half2int16_rm": "void __bang_half2int16_rm(int16_t *dst, const half *src, unsigned int src_count, int fix_position)   This function converts type of <src> from half to int16\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_half2int16_dn for more details.",
    "half2int16_rn": "void __bang_half2int16_rn(int16_t *dst, const half *src, unsigned int src_count, int fix_position)   This function converts type of <src> from half to int16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_half2int16_dn for more details.",
    "half2int16_tz": "void __bang_half2int16_tz(int16_t *dst, const half *src, unsigned int src_count, int fix_position)   This function converts type of <src> from half to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2int16_dn for more details.",
    "half2int16_up": "void __bang_half2int16_up(int16_t *dst, const half *src, unsigned int src_count, int fix_position)   This function converts type of <src> from half to int16\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2int16_dn for more details.",
    "half2int32": "void __bang_half2int32(int32_t *dst, const half *src, unsigned int count, int fix_position)   This function converts type of <src> from half to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int32_dn": "void __bang_half2int32_dn(int32_t *dst, const half *src, unsigned int count, int fix_position)   This function converts type of <src> from half to int32\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int32_oz": "void __bang_half2int32_oz(int32_t *dst, const half *src, unsigned int count, int fix_position)   This function converts type of <src> from half to int32\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int32_rd": "void __bang_half2int32_rd(int32_t *dst, const half *src, unsigned int count, int fix_position)   This function converts type of <src> from half to int32\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int32_rm": "void __bang_half2int32_rm(int32_t *dst, const half *src, unsigned int count, int fix_position)   This function converts type of <src> from half to int32\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int32_rn": "void __bang_half2int32_rn(int32_t *dst, const half *src, unsigned int count, int fix_position)   This function converts type of <src> from half to int32\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int32_tz": "void __bang_half2int32_tz(int32_t *dst, const half *src, unsigned int count, int fix_position)   This function converts type of <src> from half to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int32_up": "void __bang_half2int32_up(int32_t *dst, const half *src, unsigned int count, int fix_position)   This function converts type of <src> from half to int32\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int4_dn": "void __bang_half2int4_dn(int4x2_t *dst, const half *src, unsigned int size, int dst_position)   This function converts type of <src> from half to int4 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int4_oz": "void __bang_half2int4_oz(int4x2_t *dst, const half *src, unsigned int size, int dst_position)   This function converts type of <src> from half to int4 element-wisely in in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int4_rd": "void __bang_half2int4_rd(int4x2_t *dst, const half *src, unsigned int size, int dst_position)   This function converts type of <src> from half to int4 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int4_rm": "void __bang_half2int4_rm(int4x2_t *dst, const half *src, unsigned int size, int dst_position)   This function converts type of <src> from half to int4 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int4_rn": "void __bang_half2int4_rn(int4x2_t *dst, const half *src, unsigned int size, int dst_position)   This function converts type of <src> from half to int4 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int4_tz": "void __bang_half2int4_tz(int4x2_t *dst, const half *src, unsigned int size, int dst_position)   This function converts type of <src> from half to int4 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int4_up": "void __bang_half2int4_up(int4x2_t *dst, const half *src, unsigned int size, int dst_position)   This function converts type of <src> from half to int4 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2int8_dn": "void __bang_half2int8_dn(int8_t *dst, const half *src, unsigned int src_count, int fix_position)   void __bang_half2int8_dn(int8_t *dst, const half *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to int8\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-down mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Fig. 3.20 The Process of Conversion with Stride Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(int8\\_t), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(int8_t) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "half2int8_oz": "void __bang_half2int8_oz(int8_t *dst, const half *src, unsigned int src_count, int fix_position)   void __bang_half2int8_oz(int8_t *dst, const half *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to int8\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-off-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(int8\\_t), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(int8_t) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2int8_dn for more details.",
    "half2int8_rd": "void __bang_half2int8_rd(int8_t *dst, const half *src, unsigned int src_count, int fix_position)   void __bang_half2int8_rd(int8_t *dst, const half *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to int8\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-nearest-off-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(int8\\_t), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(int8_t) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2int8_dn for more details.",
    "half2int8_rm": "void __bang_half2int8_rm(int8_t *dst, const half *src, unsigned int src_count, int fix_position)   void __bang_half2int8_rm(int8_t *dst, const half *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to int8\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-math mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <fix\\_position> must be in the range [-127,127];\n* <src\\_count> must be greater than zero;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(int8\\_t), and divisible by sizeof(int8_t) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_half2int8_dn for more details.",
    "half2int8_rn": "void __bang_half2int8_rn(int8_t *dst, const half *src, unsigned int src_count, int fix_position)   void __bang_half2int8_rn(int8_t *dst, const half *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to int8\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-nearest-even mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <fix\\_position> must be in the range [-127,127];\n* <src\\_count> must be greater than zero;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(int8\\_t), and divisible by sizeof(int8_t) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_half2int8_dn for more details.",
    "half2int8_tz": "void __bang_half2int8_tz(int8_t *dst, const half *src, unsigned int src_count, int fix_position)   void __bang_half2int8_tz(int8_t *dst, const half *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-to-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(int8\\_t), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(int8_t) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2int8_dn for more details.",
    "half2int8_up": "void __bang_half2int8_up(int8_t *dst, const half *src, unsigned int src_count, int fix_position)   void __bang_half2int8_up(int8_t *dst, const half *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to int8\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-up mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(int8\\_t), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(int8_t) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2int8_dn for more details.",
    "half2short_dn": "void __bang_half2short_dn(short *dst, const half *src, unsigned int src_count)   void __bang_half2short_dn(short *dst, const half *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to short element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-down mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(short), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(short) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "half2short_oz": "void __bang_half2short_oz(short *dst, const half *src, unsigned int src_count)   void __bang_half2short_oz(short *dst, const half *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to short element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-off-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(short), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(short) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2short_dn for more details.",
    "half2short_rd": "void __bang_half2short_rd(short *dst, const half *src, unsigned int src_count)   void __bang_half2short_rd(short *dst, const half *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to short element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-nearest-off-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(short), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(short) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2short_dn for more details.",
    "half2short_rm": "void __bang_half2short_rm(short *dst, const half *src, unsigned int src_count)   void __bang_half2short_rm(short *dst, const half *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to short element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-math mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(short), and divisible by sizeof(short) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2short_rn": "void __bang_half2short_rn(short *dst, const half *src, unsigned int src_count)   void __bang_half2short_rn(short *dst, const half *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to short element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-nearest-even mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(short), and divisible by sizeof(short) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_half2short_rm for more details.",
    "half2short_tz": "void __bang_half2short_tz(short *dst, const half *src, unsigned int src_count)   void __bang_half2short_tz(short *dst, const half *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to short element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-to-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(short), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(short) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2short_dn for more details.",
    "half2short_up": "void __bang_half2short_up(short *dst, const half *src, unsigned int src_count)   void __bang_half2short_up(short *dst, const half *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from half to short element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-up mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(short), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(short) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(half);\n* ( \\div sizeof(half) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_half2short_dn for more details.",
    "half2tf32": "void __bang_half2tf32(float *dst, const half *src, unsigned int count)   This function converts type of <src> from half to tf32 element-wisely and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "half2uchar_dn": "void __bang_half2uchar_dn(signed char *dst, const half *src, unsigned int src_count)   This function converts type of <src> from half to unsigned char element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_half2uchar_dn instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "half2uchar_oz": "void __bang_half2uchar_oz(unsigned char *dst, const half *src, unsigned int src_count)   This function converts type of <src> from half to unsigned char element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2uchar_rd": "void __bang_half2uchar_rd(unsigned char *dst, const half *src, unsigned int src_count)   This function converts type of <src> from half to unsigned char element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2uchar_rm": "void __bang_half2uchar_rm(unsigned char *dst, const half *src, unsigned int src_count)   This function converts type of <src> from half to unsigned char element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2uchar_rn": "void __bang_half2uchar_rn(unsigned char *dst, const half *src, unsigned int src_count)   This function converts type of <src> from half to unsigned char element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2uchar_tz": "void __bang_half2uchar_tz(unsigned char *dst, const half *src, unsigned int src_count)   This function converts type of <src> from half to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "half2uchar_up": "void __bang_half2uchar_up(unsigned char *dst, const half *src, unsigned int src_count)   This function converts type of <src> from half to unsigned char element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.2.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162bfloat16": "void __bang_int162bfloat16(bfloat16_t *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162bfloat16_dn": "void __bang_int162bfloat16_dn(bfloat16_t *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to bfloat16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162bfloat16_oz": "void __bang_int162bfloat16_oz(bfloat16_t *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to bfloat16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162bfloat16_rd": "void __bang_int162bfloat16_rd(bfloat16_t *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to bfloat16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162bfloat16_rm": "void __bang_int162bfloat16_rm(bfloat16_t *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to bfloat16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162bfloat16_rn": "void __bang_int162bfloat16_rn(bfloat16_t *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to bfloat16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162bfloat16_tz": "void __bang_int162bfloat16_tz(bfloat16_t *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162bfloat16_up": "void __bang_int162bfloat16_up(bfloat16_t *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to bfloat16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162float": "void __bang_int162float(float *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int162half": "void __bang_int162half(half *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to half element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero;\n* <src\\_count> must be divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int162half_dn": "void __bang_int162half_dn(half *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to half element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero;\n* <src\\_count> must be divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int162half_oz": "void __bang_int162half_oz(half *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to half element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero;\n* <src\\_count> must be divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int162half_rd": "void __bang_int162half_rd(half *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to half element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero;\n* <src\\_count> must be divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int162half_rm": "void __bang_int162half_rm(half *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to half element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162half_rn": "void __bang_int162half_rn(half *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to half element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162half_tz": "void __bang_int162half_tz(half *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to half element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero;\n* <src\\_count> must be divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int162half_up": "void __bang_int162half_up(half *dst, const int16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int16\\_t to half element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero;\n* <src\\_count> must be divisible by 64 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 4.1.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int162int32": "void __bang_int162int32(int32_t *dst, const int16_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc -bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162int4_dn": "void __bang_int162int4_dn(int4x2_t *dst, const int16_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int4 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162int4_oz": "void __bang_int162int4_oz(int4x2_t *dst, const int16_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int4 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162int4_rd": "void __bang_int162int4_rd(int4x2_t *dst, const int16_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int4 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162int4_rm": "void __bang_int162int4_rm(int4x2_t *dst, const int16_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int4 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162int4_rn": "void __bang_int162int4_rn(int4x2_t *dst, const int16_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int4 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162int4_tz": "void __bang_int162int4_tz(int4x2_t *dst, const int16_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int4 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162int4_up": "void __bang_int162int4_up(int4x2_t *dst, const int16_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int4 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162int8": "void __bang_int162int8(int8_t *dst, const int16_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162tf32": "void __bang_int162tf32(float *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162tf32_dn": "void __bang_int162tf32_dn(float *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to tf32 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162tf32_oz": "void __bang_int162tf32_oz(float *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to tf32 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162tf32_rd": "void __bang_int162tf32_rd(float *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to tf32 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162tf32_rm": "void __bang_int162tf32_rm(float *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to tf32 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162tf32_rn": "void __bang_int162tf32_rn(float *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to tf32 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162tf32_tz": "void __bang_int162tf32_tz(float *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162tf32_up": "void __bang_int162tf32_up(float *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to tf32 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int162uchar": "void __bang_int162uchar(unsigned char *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162uchar_dn": "void __bang_int162uchar_dn(unsigned char *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to unsigned char element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162uchar_oz": "void __bang_int162uchar_oz(unsigned char *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to unsigned char element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162uchar_rd": "void __bang_int162uchar_rd(unsigned char *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to unsigned char element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162uchar_rm": "void __bang_int162uchar_rm(unsigned char *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to unsigned char element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162uchar_rn": "void __bang_int162uchar_rn(unsigned char *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to unsigned char element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162uchar_tz": "void __bang_int162uchar_tz(unsigned char *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int162uchar_up": "void __bang_int162uchar_up(unsigned char *dst, const int16_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int16\\_t to unsigned char element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322bfloat16": "void __bang_int322bfloat16(bfloat16_t *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322bfloat16_dn": "void __bang_int322bfloat16_dn(bfloat16_t *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to bfloat16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322bfloat16_oz": "void __bang_int322bfloat16_oz(bfloat16_t *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to bfloat16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322bfloat16_rd": "void __bang_int322bfloat16_rd(bfloat16_t *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to bfloat16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322bfloat16_rm": "void __bang_int322bfloat16_rm(bfloat16_t *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to bfloat16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322bfloat16_rn": "void __bang_int322bfloat16_rn(bfloat16_t *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to bfloat16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322bfloat16_tz": "void __bang_int322bfloat16_tz(bfloat16_t *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322bfloat16_up": "void __bang_int322bfloat16_up(bfloat16_t *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to bfloat16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322float": "void __bang_int322float(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322float_dn": "void __bang_int322float_dn(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322float_oz": "void __bang_int322float_oz(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322float_rd": "void __bang_int322float_rd(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322float_rm": "void __bang_int322float_rm(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322float_rn": "void __bang_int322float_rn(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322float_tz": "void __bang_int322float_tz(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322float_up": "void __bang_int322float_up(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 4.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322half": "void __bang_int322half(half *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to half element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322half_dn": "void __bang_int322half_dn(half *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to half element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322half_oz": "void __bang_int322half_oz(half *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to half element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322half_rd": "void __bang_int322half_rd(half *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to half element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322half_rm": "void __bang_int322half_rm(half *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to half element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322half_rn": "void __bang_int322half_rn(half *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to half element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322half_tz": "void __bang_int322half_tz(half *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to half element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322half_up": "void __bang_int322half_up(half *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to half element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int16": "void __bang_int322int16(int16_t *dst, const int32_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int4_dn": "void __bang_int322int4_dn(int4x2_t *dst, const int32_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int4 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int4_oz": "void __bang_int322int4_oz(int4x2_t *dst, const int32_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int4 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int4_rd": "void __bang_int322int4_rd(int4x2_t *dst, const int32_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int4 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int4_rm": "void __bang_int322int4_rm(int4x2_t *dst, const int32_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int4 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int4_rn": "void __bang_int322int4_rn(int4x2_t *dst, const int32_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int4 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int4_tz": "void __bang_int322int4_tz(int4x2_t *dst, const int32_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int4 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int4_up": "void __bang_int322int4_up(int4x2_t *dst, const int32_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int4 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322int8": "void __bang_int322int8(int8_t *dst, const int32_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int8\\_t element-wisely round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322tf32": "void __bang_int322tf32(float *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322tf32_dn": "void __bang_int322tf32_dn(float *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to tf32 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322tf32_oz": "void __bang_int322tf32_oz(float *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to tf32 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322tf32_rd": "void __bang_int322tf32_rd(float *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to tf32 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322tf32_rm": "void __bang_int322tf32_rm(float *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to tf32 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322tf32_rn": "void __bang_int322tf32_rn(float *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to tf32 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322tf32_tz": "void __bang_int322tf32_tz(float *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322tf32_up": "void __bang_int322tf32_up(float *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to tf32 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int322uchar": "void __bang_int322uchar(unsigned char *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322uchar_dn": "void __bang_int322uchar_dn(unsigned char *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to unsigned char element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322uchar_oz": "void __bang_int322uchar_oz(unsigned char *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to unsigned char element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322uchar_rd": "void __bang_int322uchar_rd(unsigned char *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to unsigned char element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322uchar_rm": "void __bang_int322uchar_rm(unsigned char *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to unsigned char element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322uchar_rn": "void __bang_int322uchar_rn(unsigned char *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to unsigned char element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322uchar_tz": "void __bang_int322uchar_tz(unsigned char *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int322uchar_up": "void __bang_int322uchar_up(unsigned char *dst, const int32_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int32\\_t to unsigned char element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42bfloat16_dn": "void __bang_int42bfloat16_dn(bfloat16_t *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to bfloat16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42bfloat16_oz": "void __bang_int42bfloat16_oz(bfloat16_t *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to bfloat16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42bfloat16_rd": "void __bang_int42bfloat16_rd(bfloat16_t *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to bfloat16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42bfloat16_rm": "void __bang_int42bfloat16_rm(bfloat16_t *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to bfloat16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42bfloat16_rn": "void __bang_int42bfloat16_rn(bfloat16_t *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to bfloat16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42bfloat16_tz": "void __bang_int42bfloat16_tz(bfloat16_t *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42bfloat16_up": "void __bang_int42bfloat16_up(bfloat16_t *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to bfloat16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42float_dn": "void __bang_int42float_dn(float *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to float element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42float_oz": "void __bang_int42float_oz(float *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to float element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42float_rd": "void __bang_int42float_rd(float *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to float element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42float_rm": "void __bang_int42float_rm(float *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to float element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42float_rn": "void __bang_int42float_rn(float *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to float element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42float_tz": "void __bang_int42float_tz(float *dst, int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to float element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42float_up": "void __bang_int42float_up(float *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to float element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42half_dn": "void __bang_int42half_dn(half *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to half element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42half_oz": "void __bang_int42half_oz(half *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to half element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42half_rd": "void __bang_int42half_rd(half *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to half element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42half_rm": "void __bang_int42half_rm(half *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to half element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42half_rn": "void __bang_int42half_rn(half *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to half element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42half_tz": "void __bang_int42half_tz(half *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to half element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42half_up": "void __bang_int42half_up(half *dst, const int4x2_t *src, unsigned int size, int src_position)   This function converts type of <src> from int4 to half element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* <size> must be greater than zero and divisible by 2;\n* <src\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int16_dn": "void __bang_int42int16_dn(int16_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int16_oz": "void __bang_int42int16_oz(int16_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int16_rd": "void __bang_int42int16_rd(int16_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int16_rm": "void __bang_int42int16_rm(int16_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int16_rn": "void __bang_int42int16_rn(int16_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int16_tz": "void __bang_int42int16_tz(int16_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int16_up": "void __bang_int42int16_up(int16_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int32_dn": "void __bang_int42int32_dn(int32_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int32\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int32_oz": "void __bang_int42int32_oz(int32_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int32\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int32_rd": "void __bang_int42int32_rd(int32_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int32\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]; Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int32_rm": "void __bang_int42int32_rm(int32_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int32\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int32_rn": "void __bang_int42int32_rn(int32_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int32\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int32_tz": "void __bang_int42int32_tz(int32_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int32_up": "void __bang_int42int32_up(int32_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int32\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int8_dn": "void __bang_int42int8_dn(int8_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int8\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int8_oz": "void __bang_int42int8_oz(int8_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int8\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int8_rd": "void __bang_int42int8_rd(int8_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int8\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int8_rm": "void __bang_int42int8_rm(int8_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int8\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int8_rn": "void __bang_int42int8_rn(int8_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int8\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int8_tz": "void __bang_int42int8_tz(int8_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42int8_up": "void __bang_int42int8_up(int8_t *dst, const int4x2_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int4 to int8\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42tf32": "void __bang_int42tf32(float *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int42tf32_dn": "void __bang_int42tf32_dn(float *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to tf32 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int42tf32_oz": "void __bang_int42tf32_oz(float *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to tf32 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int42tf32_rd": "void __bang_int42tf32_rd(float *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to tf32 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int42tf32_rm": "void __bang_int42tf32_rm(float *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to tf32 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int42tf32_rn": "void __bang_int42tf32_rn(float *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to tf32 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int42tf32_tz": "void __bang_int42tf32_tz(float *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int42tf32_up": "void __bang_int42tf32_up(float *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to tf32 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int42uchar": "void __bang_int42uchar(unsigned char *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42uchar_dn": "void __bang_int42uchar_dn(unsigned char *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to unsigned char element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42uchar_oz": "void __bang_int42uchar_oz(unsigned char *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to unsigned char element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42uchar_rd": "void __bang_int42uchar_rd(unsigned char *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to unsigned char element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42uchar_rm": "void __bang_int42uchar_rm(unsigned char *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to unsigned char element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42uchar_rn": "void __bang_int42uchar_rn(unsigned char *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to unsigned char element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42uchar_tz": "void __bang_int42uchar_tz(unsigned char *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int42uchar_up": "void __bang_int42uchar_up(unsigned char *dst, const int4x2_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int4x2\\_t to unsigned char element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82bfloat16": "void __bang_int82bfloat16(bfloat16_t *dst, const int8_t *src, int fix_position, unsigned int count)   This function converts type of <src> from int8\\_t to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82bfloat16_dn": "void __bang_int82bfloat16_dn(bfloat16_t *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to bfloat16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82bfloat16_oz": "void __bang_int82bfloat16_oz(bfloat16_t *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to bfloat16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82bfloat16_rd": "void __bang_int82bfloat16_rd(bfloat16_t *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to bfloat16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82bfloat16_rm": "void __bang_int82bfloat16_rm(bfloat16_t *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to bfloat16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82bfloat16_rn": "void __bang_int82bfloat16_rn(bfloat16_t *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to bfloat16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82bfloat16_tz": "void __bang_int82bfloat16_tz(bfloat16_t *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82bfloat16_up": "void __bang_int82bfloat16_up(bfloat16_t *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to bfloat16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82float": "void __bang_int82float(float *dst, const int8_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int8\\_t to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int82half": "void __bang_int82half(half *dst, const int8_t *src, unsigned int src_count, int fix_position)   void __bang_int82half(half *dst, const int8_t *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from int8\\_t to half element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-to-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(int8_t);\n* ( \\div sizeof(int8\\_t) \\ge ) if <src\\_stride> is greater than zero;\n* <src> cannot be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int82int16": "void __bang_int82int16(int16_t *dst, const int8_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82int32": "void __bang_int82int32(int32_t *dst, const int8_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>;\n* <src\\_count> must be greater than zero. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82int4_dn": "void __bang_int82int4_dn(int4x2_t *dst, const int8_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int4 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82int4_oz": "void __bang_int82int4_oz(int4x2_t *dst, const int8_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int4 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82int4_rd": "void __bang_int82int4_rd(int4x2_t *dst, const int8_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int4 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82int4_rm": "void __bang_int82int4_rm(int4x2_t *dst, const int8_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int4 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82int4_rn": "void __bang_int82int4_rn(int4x2_t *dst, const int8_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int4 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82int4_tz": "void __bang_int82int4_tz(int4x2_t *dst, const int8_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int4 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82int4_up": "void __bang_int82int4_up(int4x2_t *dst, const int8_t *src, unsigned int size, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int4 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] size: The elements number of conversion.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <size> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.7.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82tf32": "void __bang_int82tf32(float *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82tf32_dn": "void __bang_int82tf32_dn(float *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to tf32 element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82tf32_oz": "void __bang_int82tf32_oz(float *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to tf32 element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82tf32_rd": "void __bang_int82tf32_rd(float *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to tf32 element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82tf32_rm": "void __bang_int82tf32_rm(float *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to tf32 element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82tf32_rn": "void __bang_int82tf32_rn(float *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to tf32 element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82tf32_tz": "void __bang_int82tf32_tz(float *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to tf32 element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82tf32_up": "void __bang_int82tf32_up(float *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to tf32 element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "int82uchar": "void __bang_int82uchar(unsigned char *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82uchar_dn": "void __bang_int82uchar_dn(unsigned char *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to unsigned char element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82uchar_oz": "void __bang_int82uchar_oz(unsigned char *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to unsigned char element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82uchar_rd": "void __bang_int82uchar_rd(unsigned char *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to unsigned char element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82uchar_rm": "void __bang_int82uchar_rm(unsigned char *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to unsigned char element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82uchar_rn": "void __bang_int82uchar_rn(unsigned char *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to unsigned char element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82uchar_tz": "void __bang_int82uchar_tz(unsigned char *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int82uchar_up": "void __bang_int82uchar_up(unsigned char *dst, const int8_t *src, unsigned int count, int fix_position)   This function converts type of <src> from int8\\_t to unsigned char element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "short2half": "void __bang_short2half(half *dst, const short *src, unsigned int src_count)   void __bang_short2half(half *dst, const short *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from short to half element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-to-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 64 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(short);\n* ( \\div sizeof(short) \\ge ) if <src\\_stride> is greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "tf322bfloat16": "void __bang_tf322bfloat16(bfloat16_t *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322bfloat16_dn": "void __bang_tf322bfloat16_dn(bfloat16_t *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to bfloat16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322bfloat16_oz": "void __bang_tf322bfloat16_oz(bfloat16_t *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to bfloat16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322bfloat16_rd": "void __bang_tf322bfloat16_rd(bfloat16_t *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to bfloat16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322bfloat16_rm": "void __bang_tf322bfloat16_rm(bfloat16_t *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to bfloat16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322bfloat16_rn": "void __bang_tf322bfloat16_rn(bfloat16_t *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to bfloat16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322bfloat16_tz": "void __bang_tf322bfloat16_tz(bfloat16_t *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to bfloat16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322bfloat16_up": "void __bang_tf322bfloat16_up(bfloat16_t *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to bfloat16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322float": "void __bang_tf322float(float *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to float element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322float_dn": "void __bang_tf322float_dn(float *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to float element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322float_oz": "void __bang_tf322float_oz(float *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to float element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322float_rd": "void __bang_tf322float_rd(float *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to float element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322float_rm": "void __bang_tf322float_rm(float *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to float element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322float_rn": "void __bang_tf322float_rn(float *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to float element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322float_tz": "void __bang_tf322float_tz(float *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to float element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322float_up": "void __bang_tf322float_up(float *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to float element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322half": "void __bang_tf322half(half *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to half element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322half_dn": "void __bang_tf322half_dn(half *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to half element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322half_oz": "void __bang_tf322half_oz(half *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to half element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322half_rd": "void __bang_tf322half_rd(half *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to half element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322half_rm": "void __bang_tf322half_rm(half *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to half element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322half_rn": "void __bang_tf322half_rn(half *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to half element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322half_tz": "void __bang_tf322half_tz(half *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to half element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322half_up": "void __bang_tf322half_up(half *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to half element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int16": "void __bang_tf322int16(int16_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int16_dn": "void __bang_tf322int16_dn(int16_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int16_oz": "void __bang_tf322int16_oz(int16_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int16_rd": "void __bang_tf322int16_rd(int16_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int16_rm": "void __bang_tf322int16_rm(int16_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int16_rn": "void __bang_tf322int16_rn(int16_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int16_tz": "void __bang_tf322int16_tz(int16_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int16_up": "void __bang_tf322int16_up(int16_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int32": "void __bang_tf322int32(int32_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int32_dn": "void __bang_tf322int32_dn(int32_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int32\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int32_oz": "void __bang_tf322int32_oz(int32_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int32\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int32_rd": "void __bang_tf322int32_rd(int32_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int32\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int32_rm": "void __bang_tf322int32_rm(int32_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int32\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int32_rn": "void __bang_tf322int32_rn(int32_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int32\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int32_tz": "void __bang_tf322int32_tz(int32_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int32_up": "void __bang_tf322int32_up(int32_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int32\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int4": "void __bang_tf322int4(int4x2_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int4x2\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int4_dn": "void __bang_tf322int4_dn(int4x2_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int4x2\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int4_oz": "void __bang_tf322int4_oz(int4x2_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int4x2\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int4_rd": "void __bang_tf322int4_rd(int4x2_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int4x2\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int4_rm": "void __bang_tf322int4_rm(int4x2_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int4x2\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int4_rn": "void __bang_tf322int4_rn(int4x2_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int4x2\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int4_tz": "void __bang_tf322int4_tz(int4x2_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int4x2\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int4_up": "void __bang_tf322int4_up(int4x2_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int4x2\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int8": "void __bang_tf322int8(int8_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int8_dn": "void __bang_tf322int8_dn(int8_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int8\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int8_oz": "void __bang_tf322int8_oz(int8_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int8\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int8_rd": "void __bang_tf322int8_rd(int8_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int8\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int8_rm": "void __bang_tf322int8_rm(int8_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int8\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int8_rn": "void __bang_tf322int8_rn(int8_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int8\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int8_tz": "void __bang_tf322int8_tz(int8_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322int8_up": "void __bang_tf322int8_up(int8_t *dst, const float *src, unsigned int count, int fix_position)   This function converts type of <src> from tf32 to int8\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322uchar": "void __bang_tf322uchar(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322uchar_dn": "void __bang_tf322uchar_dn(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to unsigned char element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322uchar_oz": "void __bang_tf322uchar_oz(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to unsigned char element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_520. Example\n```",
    "tf322uchar_rd": "void __bang_tf322uchar_rd(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to unsigned char element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322uchar_rm": "void __bang_tf322uchar_rm(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to unsigned char element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322uchar_rn": "void __bang_tf322uchar_rn(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to unsigned char element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "tf322uchar_tz": "void __bang_tf322uchar_tz(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to unsigned char element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_520. Example\n```",
    "tf322uchar_up": "void __bang_tf322uchar_up(unsigned char *dst, const float *src, unsigned int count)   This function converts type of <src> from tf32 to unsigned char element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "uchar2bfloat16": "void __bang_uchar2bfloat16(bfloat16_t *dst, const unsigned char *src, unsigned int count)   This function converts type of <src> from unsigned char to bfloat16\\_t element-wisely and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "uchar2float": "void __bang_uchar2float(float *dst, const unsigned char *src, unsigned int count)   This function converts type of <src> from unsigned char to float element-wisely and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2half": "void __bang_uchar2half(half *dst, const unsigned char *src, unsigned int src_count)   void __bang_uchar2half(half *dst, const unsigned char *src, unsigned int src_count, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from unsigned char to half element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.\nThe data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements in round-to-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(unsigned char);\n* <src> cannot be overlapped with <dst>;\n* ( \\div sizeof(unsigned char) \\ge ) if <src\\_stride> is greater than zero. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "uchar2int16": "void __bang_uchar2int16(int16_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int16_dn": "void __bang_uchar2int16_dn(int16_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int16\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int16_oz": "void __bang_uchar2int16_oz(int16_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int16\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int16_rd": "void __bang_uchar2int16_rd(int16_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int16\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int16_rm": "void __bang_uchar2int16_rm(int16_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int16\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int16_rn": "void __bang_uchar2int16_rn(int16_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int16\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int16_tz": "void __bang_uchar2int16_tz(int16_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int16_up": "void __bang_uchar2int16_up(int16_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int16\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int32": "void __bang_uchar2int32(int32_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int32_dn": "void __bang_uchar2int32_dn(int32_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int32\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int32_oz": "void __bang_uchar2int32_oz(int32_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int32\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int32_rd": "void __bang_uchar2int32_rd(int32_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int32\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int32_rm": "void __bang_uchar2int32_rm(int32_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int32\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int32_rn": "void __bang_uchar2int32_rn(int32_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int32\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int32_tz": "void __bang_uchar2int32_tz(int32_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int32_up": "void __bang_uchar2int32_up(int32_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int32\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int4": "void __bang_uchar2int4(int4x2_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int4x2\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int4_dn": "void __bang_uchar2int4_dn(int4x2_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int4x2\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int4_oz": "void __bang_uchar2int4_oz(int4x2_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int4x2\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int4_rd": "void __bang_uchar2int4_rd(int4x2_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int4x2\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int4_rm": "void __bang_uchar2int4_rm(int4x2_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int4x2\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int4_rn": "void __bang_uchar2int4_rn(int4x2_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int4x2\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int4_tz": "void __bang_uchar2int4_tz(int4x2_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int4x2\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int4_up": "void __bang_uchar2int4_up(int4x2_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int4x2\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero and divisible by 2;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int8": "void __bang_uchar2int8(int8_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\div 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int8_dn": "void __bang_uchar2int8_dn(int8_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int8\\_t element-wisely in round-down mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\div 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int8_oz": "void __bang_uchar2int8_oz(int8_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int8\\_t element-wisely in round-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\div 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int8_rd": "void __bang_uchar2int8_rd(int8_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int8\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\div 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int8_rm": "void __bang_uchar2int8_rm(int8_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int8\\_t element-wisely in round-math mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\div 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int8_rn": "void __bang_uchar2int8_rn(int8_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int8\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\div 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int8_tz": "void __bang_uchar2int8_tz(int8_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\div 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2int8_up": "void __bang_uchar2int8_up(int8_t *dst, const unsigned char *src, unsigned int count, int fix_position)   This function converts type of <src> from unsigned char to int8\\_t element-wisely in round-up mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\div 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> can be overlapped with <dst>;\n* <fix\\_position> must be in the range [-127,127]. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "uchar2tf32": "void __bang_uchar2tf32(float *dst, const unsigned char *src, unsigned int count)   This function converts type of <src> from unsigned char to tf32 element-wisely and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <count> must be greater than zero;\n* <src> cannot be overlapped with <dst>. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 520;\n* CNCC Version: cncc --version >= 4.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_50;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_5xx. Example\n```",
    "uint162float": "void __bang_uint162float(float *dst, const uint16_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from uint16\\_t to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example\n```",
    "uint322float": "void __bang_uint322float(float *dst, const uint32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from uint32\\_t to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 except 520;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx except tp\\_520. Example\n```",
    "uint82float": "void __bang_uint82float(float *dst, const uint8_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from uint8\\_t to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 4.6.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "add_const": "void __bang_add_const(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_add_const(float *dst, const float *src, float value, unsigned int elem_count)   This function adds <value> to <elem\\_count> elements of <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_add_scalar instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "avgpool": "void __bang_avgpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width)   void __bang_avgpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_avgpool(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   void __bang_avgpool(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_avgpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_avgpool(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, unsigned int in_dh, unsigned int in_dw, unsigned int out_dh, unsigned int out_dw)   void __bang_avgpool(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height)   Performs avgpooling forward propagation operation on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and calculates the average value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of input feature map.\n* [in] width: The width of input feature map.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] in\\_dh: Dilation in H direction of input.\n* [in] in\\_dw: Dilation in W direction of input.\n* [in] out\\_dh: Dilation in H direction of output.\n* [in] out\\_dw: Dilation in W direction of output. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The function with dilation is supported on (m)tp\\_3xx or higher;\n* <dst> cannot be overlapped with <src>;\n* In the function without stride, <stride\\_width> equals <kernel\\_width> and <stride\\_height> equals <kernel\\_height>;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> must be greater than 0;\n* <stride\\_height> and <stride\\_width> must be greater than 0 if specified;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16});\n* The default value for <in\\_dh>, <in\\_dw>, <out\\_dh> and <out\\_dw> is 1 which means no dilation.\n* This function was deprecated from CNCC v4.5.0. Use __bang_sumpool and __bang_cycle_mul instead on (m)tp_2xx or use __bang_sumpool and __bang_mul_scalar instead on (m)tp_3xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "avgpool_bp": "void __bang_avgpool_bp(half *dst, const half *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   void __bang_avgpool_bp(bfloat16_t *dst, const bfloat16_t *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   void __bang_avgpool_bp(float *dst, const float *src, unsigned int channel, unsigned int height, unsigned int width, unsigned int kernel_height, unsigned int kernel_width, unsigned int stride_width, unsigned int stride_height, mluPoolBPOverlap overlap = OVERLAP_ACC)   Performs avgpooling backward propagation operation on <src> [<height>, <width>, <channel>], a three-dimensional tensor, with sliding window [<kernel\\_height>, <kernel\\_width>] and stride [<stride\\_width>, <stride\\_height>], and calculates the average value in each window. <overlap> indicates the type of overlap options. <overlap> is assigned to an enumerated type called mluPoolBPOverlap that contains 2 enumerators listed in the table below. When window is slid in certain direction (H or W direction), if the left elements number doesn’t match the window size, these elements will be discarded. Table 4.1 Semantics of mluPoolBPOverlap | mluPoolBPOverlap Type | Semantic |\n| --- | --- |\n| OVERLAP\\_ACC | Accumulates the overlap parts of the output. |\n| OVERLAP\\_COVER | Covers the overlap parts of the output. | See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination tensor whose data layout is HWC.\n* [in] src: The address of source tensor whose data layout is HWC.\n* [in] channel: Input channel.\n* [in] height: The height of output feature map.\n* [in] width: The width of output feature map.\n* [in] kernel\\_height: The height of kernel.\n* [in] kernel\\_width: The width of kernel.\n* [in] stride\\_width: Stride of sliding window in W direction.\n* [in] stride\\_height: Stride of sliding window in H direction.\n* [in] overlap: The type of overlap options. Return* void. Remark* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <channel> * sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* The default mluPoolBPOverlap option is OVERLAP\\_ACC;\n* [input\\_height] and [input\\_width] of <src> must be greater than 0;\n* <channel>, <height>, <width>, <kernel\\_height>, <kernel\\_width>, <stride\\_height> and <stride\\_width> must be greater than 0;\n* ((kernel\\_height \\times kernel\\_width) \\leq 2^{16}).\n* This function was deprecated from CNCC v4.5.0. Use __bang_sumpool_bp and __bang_cycle_mul instead on (m)tp_2xx or use __bang_sumpool_bp and __bang_mul_scalar instead on (m)tp_3xx or higher. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```\n #include  __mlu_entry__ void PoolAvgBpKernel(half* output, half* input,\n                                    int channels, int out_height,\n                                    int out_width, int kernel_height,\n                                    int kernel_width, int stride_width,\n                                    int stride_height) {\n   __nram__ half a_tmp[INPUT_COUNT];\n   __nram__ half b_tmp[OUTPUT_COUNT];\n   __memcpy(b_tmp, output, OUTPUT_COUNT * sizeof(half), GDRAM2NRAM);\n   __memcpy(a_tmp, input, INPUT_COUNT * sizeof(half), GDRAM2NRAM);\n   __bang_avgpool_bp(b_tmp, a_tmp, channels, out_height, out_width,\n                     kernel_height, kernel_width, stride_width,\n                     stride_height);\n   __memcpy(output, b_tmp, OUTPUT_COUNT * sizeof(half), NRAM2GDRAM);\n} ```",
    "char2int": "void __bang_char2int(int32_t *dst, const int8_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>;\n* <src\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.0.0. Use __bang_int82int32 instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "char2short": "void __bang_char2short(int16_t *dst, const int8_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int8\\_t to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>;\n* <src\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.0.0. Use __bang_int82int16 instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "collect": "void __bang_collect(half *dst, const half *src, const half *mask, unsigned int elem_count)   void __bang_collect(float *dst, const float *src, const float *mask, unsigned int elem_count)   Selects number in one vector according to the corresponding values in another vector. The elements in <src> will be selected and stored continuously if corresponding elements in <mask> are not equal to zero. The result is the selected elements. The selected elements will be stored continuously. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] mask: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* The <src>, <mask> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> \\* sizeof(type) must be a multiple of 128 bytes on (m)tp\\_2xx;\n* The address of <src>, <mask> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* On (m)tp\\_2xx, if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;\n* On (m)tp\\_2xx, the size of <dst> cannot be smaller than the size of <src> and if the selected elements(including pad) does not fill the entire <dst> space, the remaining data in <dst> may also be changed;\n* This function was deprecated from CNCC v4.1.0. Use __bang_filter instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "collect_bitindex": "void __bang_collect_bitindex(half *dst, const half *src, const void *bitmask, unsigned int elem_count)   void __bang_collect_bitindex(float *dst, const float *src, const void *bitmask, unsigned int elem_count)   Selects the corresponding elements in <src> according to <bitmask>. The elements in <src> will be saved to <dst>, if corresponding bit in <bitmask> is 1. All selected elements will be stored continuously in <dst>. The selected elements will be stored continuously. The behavior is illustrated in the figure below, in this example, <bitmask> is 0x41100000. Fig. 4.1 The Calculation Process of Floating-point Type \\_\\_bang\\_collect\\_bitindex Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] bitmask: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* The <src>, <bitmask> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src>, <bitmask> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <elem\\_count> must be divisible by 512 on (m)tp\\_2xx, and divisible by 8 on mtp\\_372 and tp\\_322;\n* On (m)tp\\_2xx, if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;\n* On (m)tp\\_2xx, the size of <dst> cannot be smaller than the size of <src> and if the selected elements(including pad) does not fill the entire <dst> space, the remaining data in <dst> may also be changed;\n* This function was deprecated from CNCC v4.1.0. Use __bang_filter_bitindex instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "fabsmax": "void __bang_fabsmax(half *dst, const half *src, unsigned int elem_count)   void __bang_fabsmax(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_fabsmax(float *dst, const float *src, unsigned int elem_count)   This function performs calculation of the absolute value of <src> element-wisely, then finds the maximum absolute value and its position index, and saves the maximum absolute value and its index in <dst>. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* The size of <dst> for half and bfloat16\\_t type is at least 10 bytes. The first 2 bytes of <dst> are used to record the maximum absolute value, and the next 4 bytes are used to record the index of maximum absolute value in <src>, the next 4 bytes are written to zero;\n* The size of <dst> for float type is at least 12 bytes. The first 4 bytes of <dst> are used to record the maximum absolute value, the next 4 bytes are used to record the index of maximum absolute value in <src>, and the next 4 bytes are written to zero;\n* When <src> vector has multiple same maximum absolute values, the first one and its index will be stored;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.5.0. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "fabsmin": "void __bang_fabsmin(half *dst, const half *src, unsigned int elem_count)   void __bang_fabsmin(bfloat16_t *dst, const bfloat16_t *src, unsigned int elem_count)   void __bang_fabsmin(float *dst, const float *src, unsigned int elem_count)   This function performs calculation of the absolute value of <src> element-wisely, then finds the minimum absolute value and its position index, and saves the minimum absolute value and its index in <dst>. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <dst> and <src> must point to \\_\\_nram\\_\\_ address space;\n* bfloat16\\_t is supported on (m)tp\\_5xx or higher;\n* The size of <dst> for half and bfloat16\\_t type is at least 10 bytes. The first 2 bytes of <dst> are used to record the minimum absolute value, the next 4 bytes are used to record the index of minimum absolute value in <src>, and the next 4 bytes are written to zero;\n* The size of <dst> for float type is at least 12 bytes. The first 4 bytes of <dst> are used to record the minimum absolute value, the next 4 bytes are used to record the index of minimum absolute value in <src>, and the next 4 bytes are written to zero;\n* When <src> vector has multiple same minimum absolute values, the first one and its index will be stored;\n* <dst> can be overlapped with <src>;\n* <elem\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.5.0. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_fabsmax for more details.",
    "fix82half": "void __bang_fix82half(half *dst, const int8_t *src, unsigned int src_count, int fix_position)   void __bang_fix82half(half *dst, const int8_t *src, unsigned int src_count, int fix_position, unsigned int dst_stride, unsigned int src_stride, unsigned int segnum)   This function converts type of <src> from int8\\_t to half element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. The data type conversion process is illustrated by Figure The Process of Conversion with Stride. <src> includes <segnum> + 1 blocks, and each block consists of <src\\_stride> bytes. <dst> includes <segnum> + 1 blocks, and each block consists of <dst\\_stride> bytes. In each block of <src>, this function converts first <src\\_count> elements according to <fix\\_position> in round-to-zero mode, and saves the result in blocks in <dst> sequentially. If <src\\_stride> is zero, this function only converts the first block <segnum> + 1 times. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}).\n* [in] dst\\_stride: The destination stride in bytes.\n* [in] src\\_stride: The source stride in bytes.\n* [in] segnum: The number of segments minus one. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> cannot be overlapped with <dst>;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <fix\\_position> must be in the range [-127,127];\n* <dst\\_stride> must be greater than or equal to <src\\_count> \\* sizeof(half), and divisible by 64 on (m)tp\\_2xx, and divisible by sizeof(half) on (m)tp\\_3xx or higher;\n* <src\\_stride> must be divisible by sizeof(int8_t);\n* <src\\_stride> (\\div) sizeof(int8\\_t) (\\ge) <src\\_count> if <src\\_stride> is greater than zero;\n* This function was deprecated from CNCC v4.0.0. Use __bang_int82half instead. Instruction Pipeline* Execute in Move instruction pipeline if the conversion function has <src\\_stride> and <dst\\_stride>;\n* Execute in Compute instruction pipeline, otherwise. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 3.5.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "float2int_dn": "void __bang_float2int_dn(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_float2int32_dn instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "float2int_oz": "void __bang_float2int_oz(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_float2int32_oz instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int_dn for more details.",
    "float2int_rd": "void __bang_float2int_rd(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-nearest-off-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_float2int32_rd instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int_dn for more details.",
    "float2int_rm": "void __bang_float2int_rm(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-math mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_float2int32_rm instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int_dn for more details.",
    "float2int_rn": "void __bang_float2int_rn(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-nearest-even mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_float2int32_rn instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int_dn for more details.",
    "float2int_tz": "void __bang_float2int_tz(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_float2int32_tz instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int_dn for more details.",
    "float2int_up": "void __bang_float2int_up(int32_t *dst, const float *src, unsigned int src_count, int fix_position)   This function converts type of <src> from float to int32\\_t element-wisely in round-up mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_float2int32_up instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example* See the example of __bang_float2int_dn for more details.",
    "ge_const": "void __bang_ge_const(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_ge_const(float *dst, const float *src, float value, unsigned int elem_count)   This function compares <elem\\_count> elements in <src> with <value> to determine whether the elements are greater than or equal to <value> and saves the result in <dst>. If the element of <src> is greater than or equal to <value>, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of <src>. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_ge_scalar instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "half2char_dn": "void __bang_half2char_dn(signed char *dst, const half *src, unsigned int src_count)   This function converts type of <src> from half to signed char element-wisely in round-down mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements. Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <src\\_count> must be greater than zero and divisible by 128 on (m)tp\\_2xx;\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_half2uchar_dn instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "int2char": "void __bang_int2char(int8_t *dst, const int32_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int8\\_t element-wisely round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.0.0. Use __bang_int322int8 instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int2float": "void __bang_int2float(float *dst, const int32_t *src, unsigned int src_count, int fix_position)   This function converts type of <src> from int32\\_t to float element-wisely in round-to-zero mode and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The elements number of conversion.\n* [in] fix\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_count> must be greater than zero;\n* <fix\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* This function was deprecated from CNCC v4.0.0. Use __bang_int322float instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322 ;\n* CNCC Version: cncc --version >= 3.0.0 ;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30 ;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "int2short": "void __bang_int2short(int16_t *dst, const int32_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int32\\_t to int16\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.0.0. Use __bang_int322int16 instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "lock": "void __bang_lock(int lock_id_0, int lock_id_1)   Applies and seize lock_id. Parameters* [in] lock\\_id\\_0: The first lock id.\n* [in] lock\\_id\\_1: The second lock id. Return* void. Remark* This function was deprecated from CNCC v4.0.0;\n* __bang_lock is always paired with __bang_unlock;\n* For MLU Core, lock\\_id\\_0 should be equal to lock\\_id\\_1;\n* For MPU Core, lock\\_id\\_0 should be not equal to lock\\_id\\_1;\n* __bang_lock can be used before \\_\\_memcpy from to GDRAM, whose size is larger than 64KB. Instruction Pipeline* NA. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx. Example Example of __bang_lock usage in MLU Core is as follows: ```",
    "maskmove_bitindex": "void __bang_maskmove_bitindex(half *dst, const half *src, const void *bitmask, unsigned int elem_count)   void __bang_maskmove_bitindex(float *dst, const float *src, const void *bitmask, unsigned int elem_count)   Selects the corresponding elements in <src> according to <bitmask>. The elements in <src> will be saved to <dst>, if corresponding bit in <bitmask> is 1. All selected elements in <dst> will be stored continuously. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] bitmask: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* The <src>, <bitmask> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The total number of bytes of <dst> is at least 128 on (m)tp\\_2xx;\n* The address of <src>, <bitmask> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <elem\\_count> must be divisible by 1024 on (m)tp\\_2xx, and divisible by 8 on mtp\\_372 and tp\\_322;\n* This function was deprecated from CNCC v4.0.0. Use __bang_filter_bitindex instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "max": "void __bang_max(half *dst, const half *src, unsigned int elem_count)   void __bang_max(float *dst, const float *src, unsigned int elem_count)   Finds the maximum in a given vector. The result is composed of two parts. The first part is the maximum value of corresponding data type, the second part is the index of the maximum value in <src> vector, whose data type is unsigned int. The maximum value and index are stored continuously in <dst>. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The \\_\\_nram\\_\\_ address space to which <dst> points must be at least 128 bytes on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* This function was deprecated from CNCC v4.1.0. Use __bang_argmax instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example\n```",
    "min": "void __bang_min(half *dst, const half *src, unsigned int elem_count)   void __bang_min(float *dst, const float *src, unsigned int elem_count)   Finds the minimum value in <src> and stores the result in <dst>. The result consists of two parts, the first part is the minimum value of corresponding type, and the second part is the index of the minimum value, whose data type is unsigned int. The minimum value and index are stored continuously. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The \\_\\_nram\\_\\_ address space to which <dst> points must be at least 128 bytes on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst> cannot be overlapped with <src>;\n* This function was deprecated from CNCC v4.1.0. Use __bang_argmin instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "mul_const": "void __bang_mul_const(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_mul_const(float *dst, const float *src, float value, unsigned int elem_count)   This function multiplies <elem\\_count> elements of <src> by <value> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <dst> can be overlapped with <src>;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_mul_scalar instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_add_const for more details.",
    "select": "void __bang_select(half *dst, const half *src, const half *index, unsigned int elem_count)   void __bang_select(float *dst, const float *src, const float *index, unsigned int elem_count)   Selects elements in one vector according to the corresponding values in another vector. The elements in <src> will be selected if corresponding elements in <index> are not equal to zero. The result is composed of three parts. The first 4-byte is the number of selected element, whose data type is unsigned int. The next 124-byte is zero. The rest bytes are the selected elements. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] index: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* The <src>, <index> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> \\* sizeof(type) must be a multiple of 128 bytes;\n* The address of <src>, <index> and <dst> must be 64-byte aligned;\n* If the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;\n* The reserved space for selected data in <dst> cannot be smaller than the size of <src> and if the selected elements(including pad) does not fill the entire <dst> space, the remaining data in <dst> may also be changed;\n* This function was deprecated from CNCC v4.1.0. Use __bang_filter instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "select_bitindex": "void __bang_select_bitindex(half *dst, const half *src, const void *bitindex, unsigned int elem_count)   void __bang_select_bitindex(float *dst, const float *src, const void *bitindex, unsigned int elem_count)   Selects elements in <src> if the corresponding bit values in <bitindex> are not equal to zero. The result is saved to <dst>, which composes of three parts. The first 4-byte is the number of selected elements, whose data type is unsigned int. The next 124-byte is zero. The rest bytes are the selected elements. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of first source vector.\n* [in] bitindex: The address of second source vector.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <dst> can be overlapped with <src>;\n* The <src>, <bitindex> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <elem\\_count> must be divisible by 512;\n* The address of <src>, <bitindex> and <dst> must be 64-byte aligned;\n* If the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;\n* The reserved space for selected data in <dst> cannot be smaller than the size of <src> and if the selected elements(including pad) does not fill the entire <dst> space, the remaining data in <dst> may also be changed;\n* This function was deprecated from CNCC v4.1.0. Use __bang_filter_bitindex instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None.",
    "short2char": "void __bang_short2char(int8_t *dst, const int16_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int8\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> can be overlapped with <dst>;\n* <src\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.0.0. Use __bang_int162int8 instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "short2int": "void __bang_short2int(int32_t *dst, const int16_t *src, unsigned int src_count, int dst_position, int src_position)   This function converts type of <src> from int16\\_t to int32\\_t element-wisely in round-to-zero mode and saves the result in <dst>. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] src\\_count: The number of elements.\n* [in] dst\\_position: Scale factor of destination vector, i.e., ( \\times 2^{}).\n* [in] src\\_position: Scale factor of source vector, i.e., ( \\times 2^{}). Return* void. Remark* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src\\_position> and <dst\\_position> must be in the range [-127,127];\n* <src> cannot be overlapped with <dst>;\n* <src\\_count> must be greater than zero;\n* This function was deprecated from CNCC v4.0.0. Use __bang_int162int32 instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 322;\n* CNCC Version: cncc --version >= 3.0.0;\n* Cambricon BANG Compute Arch Version: cncc -bang-arch >= compute\\_30;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_3xx. Example\n```",
    "sub_const": "void __bang_sub_const(half *dst, const half *src, half value, unsigned int elem_count)   void __bang_sub_const(float *dst, const float *src, float value, unsigned int elem_count)   This function subtracts <value> from <elem\\_count> elements of <src> and saves the result in <dst>. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information. Parameters* [out] dst: The address of destination vector.\n* [in] src: The address of source vector.\n* [in] value: The source scalar.\n* [in] elem\\_count: The number of elements in source vector. Return* void. Remark* <elem\\_count> must be greater than zero;\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* <src> can be overlapped with <dst>;\n* <elem\\_count> \\* sizeof(type) must be divisible by 128 on (m)tp\\_2xx;\n* The address of <src> and <dst> must be 64-byte aligned on (m)tp\\_2xx;\n* This function was deprecated from CNCC v4.0.0. Use __bang_sub_scalar instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.8.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* See the example of __bang_add_const for more details.",
    "unlock": "void __bang_unlock(int lock_id_0, int lock_id_1)   Releases lock_id. Parameters* [in] lock\\_id\\_0: The first lock id.\n* [in] lock\\_id\\_1: The second lock id. Return* void. Remark* This function was deprecated from CNCC v4.0.0;\n* __bang_unlock is always paired with __bang_lock;\n* For MLU Core, lock\\_id\\_0 should be equal to lock\\_id\\_1;\n* For MPU Core, lock\\_id\\_0 should be not equal to lock\\_id\\_1;\n* __bang_unlock can be used after \\_\\_memcpy from to GDRAM, whose size is larger than 64KB. Instruction Pipeline* NA. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= mtp\\_2xx. Example* See the example of __bang_unlock for more detail.",
    "__memcpy_nram_to_nram": "void __memcpy_nram_to_nram(void *dst, const void *src, unsigned int size, int dst_stride, int src_stride, int segnum)   Copies <size> bytes data from <src> source address to <dst> destination address. Both <src> and <dst> are in \\_\\_nram\\_\\_ address space. We recommended this function for memory copy within \\_\\_nram\\_\\_ address space on (m)tp\\_2xx series for better performance, but it has 128-bytes alignment constraint. Parameters* [out] dst: The address of destination area.\n* [in] src: The address of source area.\n* [in] size: The number of bytes to be copied.\n* [in] dst\\_stride: Destination address stride.\n* [in] src\\_stride: Source address stride.\n* [in] segnum: The number of data blocks to be copied. Return* void. Remark* <size> must be greater than zero and divisible by 128;\n* <segnum> is in the range [1, 4096];\n* <src> and <dst> must point to \\_\\_nram\\_\\_ address space;\n* The address of <dst> and <src> must be 64-byte aligned on (m)tp\\_2xx;\n* <dst\\_stride> and <src\\_stride> must be greater than or equal to zero, and must be divisible by 64;\n* This function was deprecated from CNCC v4.0.0. Use __bang_move instead. Instruction Pipeline* Compute. Requirements* Cambricon BANG Version: \\_\\_BANG\\_ARCH\\_\\_ >= 200;\n* CNCC Version: cncc --version >= 2.12.0;\n* Cambricon BANG Compute Arch Version: cncc --bang-arch >= compute\\_20;\n* MLU Compute Arch Version: cncc --bang-mlu-arch >= (m)tp\\_2xx. Example* None."
  }