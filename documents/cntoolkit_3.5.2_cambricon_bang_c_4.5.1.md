


2. Preface
===========



2.1. Version
-------------


The following matrix indicates the supported architecture for different versions of Cambricon BANG C language, compiler, MLISA language, and assembler.




Table 2.1 Version Matrix






| Cambricon BANG C Version | CNCC Version | MLISA Version | CNAS Version | Supported Arch |
| --- | --- | --- | --- | --- |
| Cambricon BANG C-v4.2.x | CNCC-v4.2.x | MLISA-v4.2.x | CNAS-v4.2.x | mtp\_592,
tp\_520,
mtp\_372,
tp\_322,
mtp\_290,
(m)tp\_270,
(m)tp\_220 |
| Cambricon BANG C-v4.0.x | CNCC-v4.0.x | MLISA-v4.0.x | CNAS-v4.0.x | mtp\_592,
mtp\_372,
tp\_322,
mtp\_290,
(m)tp\_270,
(m)tp\_220 |
| Cambricon BANG C-v3.3.x | CNCC-v3.3.x | MLISA-v3.3.x | CNAS-v3.3.x | mtp\_372,
tp\_322,
mtp\_290,
(m)tp\_270,
(m)tp\_220 |
| Cambricon BANG C-v3.0.x | CNCC-v3.0.x | MLISA-v3.0.x | CNAS-v3.0.x | mtp\_372,
mtp\_290,
(m)tp\_270,
(m)tp\_220 |
| Cambricon BANG C-v2.16.x | CNCC-v2.16.x | MLISA-v2.16.x | CNAS-v2.16.x | mtp\_290,
(m)tp\_270,
(m)tp\_220 |
| Cambricon BANG C-v2.0.x | CNCC-v2.0.x | MLISA-v2.0.x | CNAS-v2.0.x | mtp\_270,
mtp\_220 |



Note



The Cambricon BANG C v4.X is compatible with Cambricon BANG C v3.x.




2.2. Update History
--------------------


* **V4.6.0**


**Date** : May 17, 2023


**Changes** :


	+ Added built-in functions including \_\_bang\_uint82float, \_\_bang\_float2uint8\_dn, \_\_bang\_float2uint8\_oz, \_\_bang\_float2uint8\_rd, \_\_bang\_float2uint8\_rm, \_\_bang\_float2uint8\_rn, \_\_bang\_float2uint8\_tz, \_\_bang\_float2uint8\_up, \_\_bang\_uint162float, \_\_bang\_float2uint16\_dn, \_\_bang\_float2uint16\_oz, \_\_bang\_float2uint16\_rd, \_\_bang\_float2uint16\_rm, \_\_bang\_float2uint16\_rn, \_\_bang\_float2uint16\_tz, \_\_bang\_float2uint16\_up, \_\_bang\_uint322float, \_\_bang\_float2uint32\_dn, \_\_bang\_float2uint32\_oz, \_\_bang\_float2uint32\_rd, \_\_bang\_float2uint32\_rm, \_\_bang\_float2uint32\_rn, \_\_bang\_float2uint32\_tz, \_\_bang\_float2uint32\_up.
* **V4.5.0**


**Date** : April 28, 2023


**Changes** :


	+ Added Activation Table Space for the Activation Function.
	+ Added \_\_bang\_matmul.
	+ Added `half` `bfloat16\_t` `float` `int4` `int8\_t` and `int16\_t` date types for \_\_bang\_mlp.
	+ Added `int8\_t` and `int16\_t` date types for \_\_bang\_conv.
	+ Added `int8\_t` and `int16\_t` date types for \_\_bang\_conv\_partial.
	+ Added built-in functions including \_\_bang\_atomic\_add, \_\_bang\_atomic\_inc, \_\_bang\_atomic\_dec, \_\_bang\_atomic\_max, \_\_bang\_atomic\_min, \_\_bang\_atomic\_and, \_\_bang\_atomic\_or, \_\_bang\_atomic\_xor, \_\_bang\_atomic\_exch, \_\_bang\_atomic\_add\_async, \_\_bang\_atomic\_inc\_async, \_\_bang\_atomic\_dec\_async, \_\_bang\_atomic\_max\_async, \_\_bang\_atomic\_min\_async, \_\_bang\_atomic\_and\_async, \_\_bang\_atomic\_or\_async, \_\_bang\_atomic\_xor\_async, \_\_bang\_atomic\_exch\_async, \_\_bang\_atomic\_add\_async, \_\_bang\_atomic\_and\_async, \_\_bang\_atomic\_cas\_async, \_\_bang\_atomic\_dec\_async, \_\_bang\_atomic\_exch\_async, \_\_bang\_atomic\_inc\_async, \_\_bang\_atomic\_max\_async, \_\_bang\_atomic\_min\_async, \_\_bang\_atomic\_or\_async, \_\_bang\_atomic\_xor\_async, \_\_bang\_atomic\_reduce\_add\_async, \_\_bang\_atomic\_reduce\_and\_async, \_\_bang\_atomic\_reduce\_cas\_async, \_\_bang\_atomic\_reduce\_dec\_async, \_\_bang\_atomic\_reduce\_exch\_async, \_\_bang\_atomic\_reduce\_inc\_async, \_\_bang\_atomic\_reduce\_max\_async, \_\_bang\_atomic\_reduce\_min\_async, \_\_bang\_atomic\_reduce\_or\_async, \_\_bang\_atomic\_reduce\_xor\_async.
	+ Deprecate built-in functions including \_\_bang\_fabsmax, \_\_bang\_fabsmin.
	+ Added built-in functions including \_\_bang\_atomic\_reduce\_add, \_\_bang\_atomic\_reduce\_inc, \_\_bang\_atomic\_reduce\_dec, \_\_bang\_atomic\_reduce\_max, \_\_bang\_atomic\_reduce\_min, \_\_bang\_atomic\_reduce\_and, \_\_bang\_atomic\_reduce\_or, \_\_bang\_atomic\_reduce\_xor, \_\_bang\_atomic\_reduce\_exch, \_\_bang\_atomic\_reduce\_add\_async, \_\_bang\_atomic\_reduce\_inc\_async, \_\_bang\_atomic\_reduce\_dec\_async, \_\_bang\_atomic\_reduce\_max\_async, \_\_bang\_atomic\_reduce\_min\_async, \_\_bang\_atomic\_reduce\_and\_async, \_\_bang\_atomic\_reduce\_or\_async, \_\_bang\_atomic\_reduce\_xor\_async, \_\_bang\_atomic\_reduce\_exch\_async.
	+ Added `bfloat16\_t` date types for \_\_bang\_div, \_\_bang\_cos, \_\_bang\_sin, \_\_bang\_log, \_\_bang\_pow2, \_\_bang\_recip, \_\_bang\_rsqrt, \_\_bang\_sqrt.
	+ Added built-in functions including :\_\_bang\_atomic\_nan\_max, \_\_bang\_atomic\_nan\_min, \_\_bang\_atomic\_nan\_max\_async, \_\_bang\_atomic\_nan\_min\_async, ref:bang\_atomic\_number\_max\_3datomicfunctions, \_\_bang\_atomic\_number\_min, \_\_bang\_atomic\_number\_max\_async, \_\_bang\_atomic\_number\_min\_async, \_\_bang\_atomic\_nan\_max\_async, \_\_bang\_atomic\_nan\_min\_async, \_\_bang\_atomic\_nan\_reduce\_max, \_\_bang\_atomic\_nan\_reduce\_min, \_\_bang\_atomic\_number\_max\_async, \_\_bang\_atomic\_number\_min\_async, \_\_bang\_atomic\_number\_reduce\_max, \_\_bang\_atomic\_number\_reduce\_min, \_\_bang\_discrete\_atomic\_nan\_max, \_\_bang\_discrete\_atomic\_nan\_min, \_\_bang\_discrete\_atomic\_number\_max, \_\_bang\_discrete\_atomic\_number\_min.
* **V4.4.0**


**Date** : February 28, 2023


**Changes** :


	+ Added built-in functions including \_\_bang\_nan\_argmax, \_\_bang\_nan\_argmin.
* **V4.3.0**


**Date** : December 12, 2022


**Changes** :


	+ Added built-in functions including \_\_bang\_maximum\_scalar, \_\_bang\_minimum\_scalar, \_\_bang\_nan\_maximum\_scalar, \_\_bang\_nan\_minimum\_scalar, \_\_bang\_nan\_maxpool, \_\_bang\_nan\_minpool, \_\_bang\_nan\_maxpool\_value\_index, \_\_bang\_nan\_minpool\_value\_index, \_\_bang\_nan\_maxpool\_index, \_\_bang\_nan\_minpool\_index, \_\_sync\_cluster\_wait, \_\_sync\_cluster\_arrive, \_\_sync\_all\_wait, \_\_sync\_all\_arrive, \_\_gdramset, \_\_ldramset, \_\_sramset, \_\_sramset\_async, \_\_nramset, \_\_nramset\_async.
* **V4.2.0**


**Date** : October 15, 2022


**Changes** :


	+ Added built-in functions including \_\_bang\_lut, \_\_gather, \_\_gather\_async, \_\_scatter, \_\_scatter\_async, \_\_prefetch\_smmu, \_\_bang\_discrete\_atomic\_add, \_\_bang\_discrete\_atomic\_and, \_\_bang\_discrete\_atomic\_cas, \_\_bang\_discrete\_atomic\_dec, \_\_bang\_discrete\_atomic\_exch, \_\_bang\_discrete\_atomic\_inc, \_\_bang\_discrete\_atomic\_max, \_\_bang\_discrete\_atomic\_min, \_\_bang\_discrete\_atomic\_or, \_\_bang\_discrete\_atomic\_xor, \_\_bang\_nan\_argmax, \_\_bang\_nan\_argmin.
* **V4.1.0**


**Date** : July 6, 2022


**Changes** :



	+ Added LDRAM2LDRAM direction for \_\_memcpy.
	+ Added LDRAM2WRAM, WRAM2GDRAM, WRAM2LDRAM, WRAM2NRAM, WRAM2SRAM directions for \_\_memcpy.
	+ Added LDRAM2GDRAM, LDRAM2LDRAM, LDRAM2NRAM, LDRAM2WRAM, LDRAM2SRAM, NRAM2LDRAM, WRAM2GDRAM, WRAM2LDRAM, SRAM2LDRAM directions for \_\_memcpy\_async.
	+ Added LDRAM2GDRAM, LDRAM2LDRAM, LDRAM2NRAM, LDRAM2SRAM, NRAM2LDRAM, SRAM2LDRAM, LDRAM2WRAM, WRAM2GDRAM, WRAM2LDRAM, WRAM2NRAM, WRAM2SRAM directions for \_\_memcpy\_async.
	+ Added built-in functions including \_\_bang\_uchar2int8, \_\_bang\_uchar2int8\_tz, \_\_bang\_uchar2int8\_oz, \_\_bang\_uchar2int8\_up, \_\_bang\_uchar2int8\_dn, \_\_bang\_uchar2int8\_rd, \_\_bang\_uchar2int8\_rm, \_\_bang\_uchar2int8\_rn, \_\_bang\_int82uchar, \_\_bang\_int82uchar\_tz, \_\_bang\_int82uchar\_oz, \_\_bang\_int82uchar\_up, \_\_bang\_int82uchar\_dn, \_\_bang\_int82uchar\_rd, \_\_bang\_int82uchar\_rm, \_\_bang\_int82uchar\_rn, \_\_sync\_all\_ipu\_within\_cluster, \_\_bang\_filter, \_\_bang\_filter\_bitindex, \_\_bang\_int162half\_tz, \_\_bang\_int162half\_oz, \_\_bang\_int162half\_up, \_\_bang\_int162half\_dn, \_\_bang\_int162half\_rd, \_\_bang\_int162half\_rm, \_\_bang\_int162half\_rn, \_\_load\_nram, \_\_load\_sram, \_\_load\_gdram, \_\_load\_ldram, \_\_store\_nram, \_\_store\_sram, \_\_store\_gdram, \_\_store\_ldram.
	+ Deprecated built-in functions including \_\_bang\_collect, \_\_bang\_collect\_bitindex, \_\_bang\_select, \_\_bang\_select\_bitindex, \_\_bang\_max, \_\_bang\_min.
* **V4.0.0**


**Date** : July 8, 2022


**Changes** :



	+ Added built-in functions including \_\_tf322float, \_\_tf322float\_tz, \_\_tf322float\_oz, \_\_tf322float\_up, \_\_tf322float\_dn, \_\_tf322float\_rd, \_\_tf322float\_rm, \_\_tf322float\_rn, \_\_tf322half, \_\_tf322half\_tz, \_\_tf322half\_oz, \_\_tf322half\_up, \_\_tf322half\_dn, \_\_tf322half\_rd, \_\_tf322half\_rm, \_\_tf322half\_rn, \_\_tf322short, \_\_tf322short\_tz, \_\_tf322short\_oz, \_\_tf322short\_up, \_\_tf322short\_dn, \_\_tf322short\_rd, \_\_tf322short\_rm, \_\_tf322short\_rn, \_\_tf322int, \_\_tf322int\_tz, \_\_tf322int\_oz, \_\_tf322int\_up, \_\_tf322int\_dn, \_\_tf322int\_rd, \_\_tf322int\_rm, \_\_tf322int\_rn, \_\_tf322char, \_\_tf322char\_tz, \_\_tf322char\_oz, \_\_tf322char\_up, \_\_tf322char\_dn, \_\_tf322char\_rd, \_\_tf322char\_rm, \_\_tf322char\_rn, \_\_tf322bfloat16, \_\_tf322bfloat16\_tz, \_\_tf322bfloat16\_oz, \_\_tf322bfloat16\_up, \_\_tf322bfloat16\_dn, \_\_tf322bfloat16\_rd, \_\_tf322bfloat16\_rm, \_\_tf322bfloat16\_rn, \_\_bfloat162float, \_\_bfloat162float\_tz, \_\_bfloat162float\_oz, \_\_bfloat162float\_up, \_\_bfloat162float\_dn, \_\_bfloat162float\_rd, \_\_bfloat162float\_rm, \_\_bfloat162float\_rn, \_\_bfloat162half, \_\_bfloat162half\_tz, \_\_bfloat162half\_oz, \_\_bfloat162half\_up, \_\_bfloat162half\_dn, \_\_bfloat162half\_rd, \_\_bfloat162half\_rm, \_\_bfloat162half\_rn, \_\_bfloat162short, \_\_bfloat162short\_tz, \_\_bfloat162short\_oz, \_\_bfloat162short\_up, \_\_bfloat162short\_dn, \_\_bfloat162short\_rd, \_\_bfloat162short\_rm, \_\_bfloat162short\_rn, \_\_bfloat162int, \_\_bfloat162int\_tz, \_\_bfloat162int\_oz, \_\_bfloat162int\_up, \_\_bfloat162int\_dn, \_\_bfloat162int\_rd, \_\_bfloat162int\_rm, \_\_bfloat162int\_rn, \_\_bfloat162char, \_\_bfloat162char\_tz, \_\_bfloat162char\_oz, \_\_bfloat162char\_up, \_\_bfloat162char\_dn, \_\_bfloat162char\_rd, \_\_bfloat162char\_rm, \_\_bfloat162char\_rn, \_\_bfloat162tf32, \_\_bfloat162tf32\_tz, \_\_bfloat162tf32\_oz, \_\_bfloat162tf32\_up, \_\_bfloat162tf32\_dn, \_\_bfloat162tf32\_rd, \_\_bfloat162tf32\_rm, \_\_bfloat162tf32\_rn, \_\_half2tf32, \_\_half2tf32\_tz, \_\_half2tf32\_oz, \_\_half2tf32\_up, \_\_half2tf32\_dn, \_\_half2tf32\_rd, \_\_half2tf32\_rm, \_\_half2tf32\_rn, \_\_float2tf32, \_\_float2tf32\_tz, \_\_float2tf32\_oz, \_\_float2tf32\_up, \_\_float2tf32\_dn, \_\_float2tf32\_rd, \_\_float2tf32\_rm, \_\_float2tf32\_rn, \_\_short2tf32, \_\_short2tf32\_tz, \_\_short2tf32\_oz, \_\_short2tf32\_up, \_\_short2tf32\_dn, \_\_short2tf32\_rd, \_\_short2tf32\_rm, \_\_short2tf32\_rn, \_\_ushort2tf32, \_\_ushort2tf32\_tz, \_\_ushort2tf32\_oz, \_\_ushort2tf32\_up, \_\_ushort2tf32\_dn, \_\_ushort2tf32\_rd, \_\_ushort2tf32\_rm, \_\_ushort2tf32\_rn, \_\_int2tf32, \_\_int2tf32\_tz, \_\_int2tf32\_oz, \_\_int2tf32\_up, \_\_int2tf32\_dn, \_\_int2tf32\_rd, \_\_int2tf32\_rm, \_\_int2tf32\_rn, \_\_uint2tf32, \_\_uint2tf32\_tz, \_\_uint2tf32\_oz, \_\_uint2tf32\_up, \_\_uint2tf32\_dn, \_\_uint2tf32\_rd, \_\_uint2tf32\_rm, \_\_uint2tf32\_rn, \_\_char2tf32, \_\_uchar2tf32, \_\_half2bfloat16, \_\_half2bfloat16\_tz, \_\_half2bfloat16\_oz, \_\_half2bfloat16\_up, \_\_half2bfloat16\_dn, \_\_half2bfloat16\_rd, \_\_half2bfloat16\_rm, \_\_half2bfloat16\_rn, \_\_float2bfloat16, \_\_float2bfloat16\_tz, \_\_float2bfloat16\_oz, \_\_float2bfloat16\_up, \_\_float2bfloat16\_dn, \_\_float2bfloat16\_rd, \_\_float2bfloat16\_rm, \_\_float2bfloat16\_rn, \_\_short2bfloat16, \_\_short2bfloat16\_tz, \_\_short2bfloat16\_oz, \_\_short2bfloat16\_up, \_\_short2bfloat16\_dn, \_\_short2bfloat16\_rd, \_\_short2bfloat16\_rm, \_\_short2bfloat16\_rn, \_\_ushort2bfloat16, \_\_ushort2bfloat16\_tz, \_\_ushort2bfloat16\_oz, \_\_ushort2bfloat16\_up, \_\_ushort2bfloat16\_dn, \_\_ushort2bfloat16\_rd, \_\_ushort2bfloat16\_rm, \_\_ushort2bfloat16\_rn, \_\_int2bfloat16, \_\_int2bfloat16\_tz, \_\_int2bfloat16\_oz, \_\_int2bfloat16\_up, \_\_int2bfloat16\_dn, \_\_int2bfloat16\_rd, \_\_int2bfloat16\_rm, \_\_int2bfloat16\_rn, \_\_uint2bfloat16, \_\_uint2bfloat16\_tz, \_\_uint2bfloat16\_oz, \_\_uint2bfloat16\_up, \_\_uint2bfloat16\_dn, \_\_uint2bfloat16\_rd, \_\_uint2bfloat16\_rm, \_\_uint2bfloat16\_rn, \_\_char2bfloat16, \_\_uchar2bfloat16, \_\_bang\_half2bfloat16, \_\_bang\_half2bfloat16\_tz, \_\_bang\_half2bfloat16\_oz, \_\_bang\_half2bfloat16\_up, \_\_bang\_half2bfloat16\_dn, \_\_bang\_half2bfloat16\_rd, \_\_bang\_half2bfloat16\_rm, \_\_bang\_half2bfloat16\_rn, \_\_bang\_bfloat162half, \_\_bang\_bfloat162half\_tz, \_\_bang\_bfloat162half\_oz, \_\_bang\_bfloat162half\_up, \_\_bang\_bfloat162half\_dn, \_\_bang\_bfloat162half\_rd, \_\_bang\_bfloat162half\_rm, \_\_bang\_bfloat162half\_rn, \_\_bang\_int82bfloat16, \_\_bang\_int82bfloat16\_tz, \_\_bang\_int82bfloat16\_oz, \_\_bang\_int82bfloat16\_up, \_\_bang\_int82bfloat16\_dn, \_\_bang\_int82bfloat16\_rd, \_\_bang\_int82bfloat16\_rm, \_\_bang\_int82bfloat16\_rn, \_\_bang\_bfloat162int8, \_\_bang\_bfloat162int8\_tz, \_\_bang\_bfloat162int8\_oz, \_\_bang\_bfloat162int8\_up, \_\_bang\_bfloat162int8\_dn, \_\_bang\_bfloat162int8\_rd, \_\_bang\_bfloat162int8\_rm, \_\_bang\_bfloat162int8\_rn, \_\_bang\_int162bfloat16, \_\_bang\_int162bfloat16\_tz, \_\_bang\_int162bfloat16\_oz, \_\_bang\_int162bfloat16\_up, \_\_bang\_int162bfloat16\_dn, \_\_bang\_int162bfloat16\_rd, \_\_bang\_int162bfloat16\_rm, \_\_bang\_int162bfloat16\_rn, \_\_bang\_bfloat162int16, \_\_bang\_bfloat162int16\_tz, \_\_bang\_bfloat162int16\_oz, \_\_bang\_bfloat162int16\_up, \_\_bang\_bfloat162int16\_dn, \_\_bang\_bfloat162int16\_rd, \_\_bang\_bfloat162int16\_rm, \_\_bang\_bfloat162int16\_rn, \_\_bang\_int322bfloat16, \_\_bang\_int322bfloat16\_tz, \_\_bang\_int322bfloat16\_oz, \_\_bang\_int322bfloat16\_up, \_\_bang\_int322bfloat16\_dn, \_\_bang\_int322bfloat16\_rd, \_\_bang\_int322bfloat16\_rm, \_\_bang\_int322bfloat16\_rn, \_\_bang\_bfloat162int32, \_\_bang\_bfloat162int32\_tz, \_\_bang\_bfloat162int32\_oz, \_\_bang\_bfloat162int32\_up, \_\_bang\_bfloat162int32\_dn, \_\_bang\_bfloat162int32\_rd, \_\_bang\_bfloat162int32\_rm, \_\_bang\_bfloat162int32\_rn, \_\_bang\_uchar2bfloat16, \_\_bang\_bfloat162uchar, \_\_bang\_bfloat162uchar\_tz, \_\_bang\_bfloat162uchar\_oz, \_\_bang\_bfloat162uchar\_up, \_\_bang\_bfloat162uchar\_dn, \_\_bang\_bfloat162uchar\_rd, \_\_bang\_bfloat162uchar\_rm, \_\_bang\_bfloat162uchar\_rn, \_\_bang\_uchar2float, \_\_bang\_float2uchar, \_\_bang\_float2uchar\_tz, \_\_bang\_float2uchar\_oz, \_\_bang\_float2uchar\_up, \_\_bang\_float2uchar\_dn, \_\_bang\_float2uchar\_rd, \_\_bang\_float2uchar\_rm, \_\_bang\_float2uchar\_rn, \_\_bang\_uchar2int4, \_\_bang\_uchar2int4\_tz, \_\_bang\_uchar2int4\_oz, \_\_bang\_uchar2int4\_up, \_\_bang\_uchar2int4\_dn, \_\_bang\_uchar2int4\_rd, \_\_bang\_uchar2int4\_rm, \_\_bang\_uchar2int4\_rn, \_\_bang\_int42uchar, \_\_bang\_int42uchar\_tz, \_\_bang\_int42uchar\_oz, \_\_bang\_int42uchar\_up, \_\_bang\_int42uchar\_dn, \_\_bang\_int42uchar\_rd, \_\_bang\_int42uchar\_rm, \_\_bang\_int42uchar\_rn, \_\_bang\_uchar2int16, \_\_bang\_uchar2int16\_tz, \_\_bang\_uchar2int16\_oz, \_\_bang\_uchar2int16\_up, \_\_bang\_uchar2int16\_dn, \_\_bang\_uchar2int16\_rd, \_\_bang\_uchar2int16\_rm, \_\_bang\_uchar2int16\_rn, \_\_bang\_int162uchar, \_\_bang\_int162uchar\_tz, \_\_bang\_int162uchar\_oz, \_\_bang\_int162uchar\_up, \_\_bang\_int162uchar\_dn, \_\_bang\_int162uchar\_rd, \_\_bang\_int162uchar\_rm, \_\_bang\_int162uchar\_rn, \_\_bang\_uchar2int32, \_\_bang\_uchar2int32\_tz, \_\_bang\_uchar2int32\_oz, \_\_bang\_uchar2int32\_up, \_\_bang\_uchar2int32\_dn, \_\_bang\_uchar2int32\_rd, \_\_bang\_uchar2int32\_rm, \_\_bang\_uchar2int32\_rn, \_\_bang\_int322uchar, \_\_bang\_int322uchar\_tz, \_\_bang\_int322uchar\_oz, \_\_bang\_int322uchar\_up, \_\_bang\_int322uchar\_dn, \_\_bang\_int322uchar\_rd, \_\_bang\_int322uchar\_rm, \_\_bang\_int322uchar\_rn, \_\_bang\_half2int32, \_\_bang\_half2int32\_tz, \_\_bang\_half2int32\_oz, \_\_bang\_half2int32\_up, \_\_bang\_half2int32\_dn, \_\_bang\_half2int32\_rd, \_\_bang\_half2int32\_rm, \_\_bang\_half2int32\_rn, \_\_bang\_int322half, \_\_bang\_int322half\_tz, \_\_bang\_int322half\_oz, \_\_bang\_int322half\_up, \_\_bang\_int322half\_dn, \_\_bang\_int322half\_rd, \_\_bang\_int322half\_rm, \_\_bang\_int322half\_rn, \_\_bang\_float2tf32, \_\_bang\_float2tf32\_tz, \_\_bang\_float2tf32\_oz, \_\_bang\_float2tf32\_up, \_\_bang\_float2tf32\_dn, \_\_bang\_float2tf32\_rd, \_\_bang\_float2tf32\_rm, \_\_bang\_float2tf32\_rn, \_\_bang\_tf322float, \_\_bang\_tf322float\_tz, \_\_bang\_tf322float\_oz, \_\_bang\_tf322float\_up, \_\_bang\_tf322float\_dn, \_\_bang\_tf322float\_rd, \_\_bang\_tf322float\_rm, \_\_bang\_tf322float\_rn, \_\_bang\_half2tf32, \_\_bang\_tf322half, \_\_bang\_tf322half\_tz, \_\_bang\_tf322half\_oz, \_\_bang\_tf322half\_up, \_\_bang\_tf322half\_dn, \_\_bang\_tf322half\_rd, \_\_bang\_tf322half\_rm, \_\_bang\_tf322half\_rn, \_\_bang\_bfloat162tf32, \_\_bang\_tf322bfloat16, \_\_bang\_tf322bfloat16\_tz, \_\_bang\_tf322bfloat16\_oz, \_\_bang\_tf322bfloat16\_up, \_\_bang\_tf322bfloat16\_dn, \_\_bang\_tf322bfloat16\_rd, \_\_bang\_tf322bfloat16\_rm, \_\_bang\_tf322bfloat16\_rn, \_\_bang\_int42tf32, \_\_bang\_int42tf32\_tz, \_\_bang\_int42tf32\_oz, \_\_bang\_int42tf32\_up, \_\_bang\_int42tf32\_dn, \_\_bang\_int42tf32\_rd, \_\_bang\_int42tf32\_rm, \_\_bang\_int42tf32\_rn, \_\_bang\_tf322int4, \_\_bang\_tf322int4\_tz, \_\_bang\_tf322int4\_oz, \_\_bang\_tf322int4\_up, \_\_bang\_tf322int4\_dn, \_\_bang\_tf322int4\_rd, \_\_bang\_tf322int4\_rm, \_\_bang\_tf322int4\_rn, \_\_bang\_int82tf32, \_\_bang\_int82tf32\_tz, \_\_bang\_int82tf32\_oz, \_\_bang\_int82tf32\_up, \_\_bang\_int82tf32\_dn, \_\_bang\_int82tf32\_rd, \_\_bang\_int82tf32\_rm, \_\_bang\_int82tf32\_rn, \_\_bang\_tf322int8, \_\_bang\_tf322int8\_tz, \_\_bang\_tf322int8\_oz, \_\_bang\_tf322int8\_up, \_\_bang\_tf322int8\_dn, \_\_bang\_tf322int8\_rd, \_\_bang\_tf322int8\_rm, \_\_bang\_tf322int8\_rn, \_\_bang\_int162tf32, \_\_bang\_int162tf32\_tz, \_\_bang\_int162tf32\_oz, \_\_bang\_int162tf32\_up, \_\_bang\_int162tf32\_dn, \_\_bang\_int162tf32\_rd, \_\_bang\_int162tf32\_rm, \_\_bang\_int162tf32\_rn, \_\_bang\_tf322int16, \_\_bang\_tf322int16\_tz, \_\_bang\_tf322int16\_oz, \_\_bang\_tf322int16\_up, \_\_bang\_tf322int16\_dn, \_\_bang\_tf322int16\_rd, \_\_bang\_tf322int16\_rm, \_\_bang\_tf322int16\_rn, \_\_bang\_int322tf32, \_\_bang\_int322tf32\_tz, \_\_bang\_int322tf32\_oz, \_\_bang\_int322tf32\_up, \_\_bang\_int322tf32\_dn, \_\_bang\_int322tf32\_rd, \_\_bang\_int322tf32\_rm, \_\_bang\_int322tf32\_rn, \_\_bang\_tf322int32, \_\_bang\_tf322int32\_tz, \_\_bang\_tf322int32\_oz, \_\_bang\_tf322int32\_up, \_\_bang\_tf322int32\_dn, \_\_bang\_tf322int32\_rd, \_\_bang\_tf322int32\_rm, \_\_bang\_tf322int32\_rn, \_\_bang\_uchar2tf32, \_\_bang\_tf322uchar, \_\_bang\_tf322uchar\_tz, \_\_bang\_tf322uchar\_oz, \_\_bang\_tf322uchar\_up, \_\_bang\_tf322uchar\_dn, \_\_bang\_tf322uchar\_rd, \_\_bang\_tf322uchar\_rm, \_\_bang\_tf322uchar\_rn, \_\_ushort2half, \_\_bang\_sum, \_\_bang\_float2half\_sr, \_\_bang\_float2tf32\_sr, \_\_bang\_breduce, \_\_bang\_bexpand, \_\_bang\_bexpand, \_\_bang\_breduce, \_\_bang\_conv\_sparse, \_\_bang\_ssparse\_filter\_index, \_\_bang\_ssparse\_filter\_sparse\_index, \_\_bang\_ssparse\_filter\_union, \_\_bang\_ssparse\_filter\_union\_index, \_\_bang\_abs, \_\_bang\_conv\_tf32, \_\_bang\_conv\_partial\_tf32, \_\_bang\_move, \_\_bang\_equ, \_\_bang\_neu, \_\_bang\_geu, \_\_bang\_gtu, \_\_bang\_leu, \_\_bang\_ltu, \_\_bang\_cycle\_equ, \_\_bang\_cycle\_neu, \_\_bang\_cycle\_geu, \_\_bang\_cycle\_gtu, \_\_bang\_cycle\_leu, \_\_bang\_cycle\_ltu, \_\_bang\_equ\_bitindex, \_\_bang\_neu\_bitindex, \_\_bang\_geu\_bitindex, \_\_bang\_gtu\_bitindex, \_\_bang\_leu\_bitindex, \_\_bang\_ltu\_bitindex, \_\_bang\_equ\_scalar, \_\_bang\_neu\_scalar, \_\_bang\_geu\_scalar, \_\_bang\_gtu\_scalar, \_\_bang\_leu\_scalar, \_\_bang\_ltu\_scalar, \_\_bang\_int322float, \_\_bang\_int322float\_tz, \_\_bang\_int322float\_oz, \_\_bang\_int322float\_up, \_\_bang\_int322float\_dn, \_\_bang\_int322float\_rd, \_\_bang\_int322float\_rn, \_\_bang\_int322float\_rm, \_\_bang\_float2int32, \_\_bang\_float2int32\_tz, \_\_bang\_float2int32\_oz, \_\_bang\_float2int32\_up, \_\_bang\_float2int32\_dn, \_\_bang\_float2int32\_rd, \_\_bang\_float2int32\_rn, \_\_bang\_float2int32\_rm, \_\_bang\_int82int32, \_\_bang\_int82int16, \_\_bang\_int322int8, \_\_bang\_int322int16, \_\_bang\_int162int32, \_\_bang\_int162int8, \_\_bang\_nearbyint.
	+ Added `bfloat16\_t` data type for \_\_bang\_add, \_\_bang\_sub, \_\_bang\_mul, \_\_bang\_add\_scalar, \_\_bang\_sub\_scalar, \_\_bang\_cycle\_add, \_\_bang\_cycle\_sub, \_\_bang\_cycle\_mul, \_\_bang\_count, \_\_bang\_count\_bitindex, \_\_bang\_square, \_\_bang\_findfirst1, \_\_bang\_findlast1, \_\_bang\_relu, \_\_bang\_relun, \_\_bang\_eq\_scalar, \_\_bang\_ne\_scalar, \_\_bang\_le\_scalar, \_\_bang\_lt\_scalar, \_\_bang\_ge\_scalar, \_\_bang\_gt\_scalar, \_\_bang\_and\_scalar, \_\_bang\_or\_scalar, \_\_bang\_xor\_scalar, \_\_bang\_and, \_\_bang\_or, \_\_bang\_not, \_\_bang\_xor, \_\_bang\_cycle\_and, \_\_bang\_cycle\_or, \_\_bang\_cycle\_xor, \_\_bang\_band\_scalar, \_\_bang\_bor\_scalar, \_\_bang\_bxor\_scalar, \_\_bang\_fusion, \_\_bang\_fabsmax, \_\_bang\_fabsmin, \_\_bang\_fcmpfilter, \_\_bang\_eq, \_\_bang\_ne, \_\_bang\_gt, \_\_bang\_ge, \_\_bang\_le, \_\_bang\_lt, \_\_bang\_eq\_bitindex, \_\_bang\_ne\_bitindex, \_\_bang\_lt\_bitindex, \_\_bang\_le\_bitindex, \_\_bang\_gt\_bitindex, \_\_bang\_ge\_bitindex, \_\_bang\_argmax, \_\_bang\_argmin, \_\_bang\_maxequal, \_\_bang\_minequal, \_\_bang\_cycle\_maxequal, \_\_bang\_cycle\_minequal, \_\_bang\_cycle\_eq, \_\_bang\_cycle\_ne, \_\_bang\_cycle\_lt, \_\_bang\_cycle\_le, \_\_bang\_cycle\_gt, \_\_bang\_cycle\_ge, \_\_bang\_sumpool, \_\_bang\_unpool, \_\_bang\_maxpool, \_\_bang\_maxpool\_index, \_\_bang\_maxpool\_value\_index, \_\_bang\_minpool, \_\_bang\_minpool\_index, \_\_bang\_minpool\_value\_index, \_\_bang\_avgpool, \_\_bang\_avgpool\_bp, \_\_bang\_maxpool\_bp, \_\_bang\_atomic\_add, \_\_bang\_atomic\_max, \_\_bang\_atomic\_min, \_\_bang\_atomic\_exch, \_\_bang\_atomic\_reduce\_max, \_\_bang\_atomic\_reduce\_min, \_\_bang\_atomic\_reduce\_cas, \_\_bang\_atomic\_reduce\_exch, \_\_bang\_atomic\_add, \_\_bang\_atomic\_max, \_\_bang\_atomic\_min, \_\_bang\_atomic\_exch, \_\_bang\_atomic\_reduce\_add, \_\_bang\_atomic\_reduce\_max, \_\_bang\_atomic\_reduce\_min, \_\_bang\_atomic\_reduce\_exch, \_\_bang\_write\_value, \_\_memset\_nram, \_\_bang\_write\_value, \_\_nramset.
	+ Added return value for \_\_bang\_count, \_\_bang\_count\_bitindex, \_\_bang\_findfirst1, \_\_bang\_findlast1.
	+ Added `void` for \_\_bang\_maskmove.
	+ Deprecate built-in functions including \_\_bang\_fix82half, \_\_bang\_add\_const, \_\_bang\_sub\_const, \_\_bang\_mul\_const, \_\_bang\_ge\_const, \_\_bang\_bor, \_\_bang\_band, \_\_bang\_bxor, \_\_bang\_bnot, \_\_bang\_cycle\_bxor, \_\_bang\_cycle\_bor, \_\_bang\_cycle\_band, \_\_bang\_maskmove\_bitindex, \_\_bang\_maskmove, \_\_bang\_count, \_\_bang\_count\_bitindex, \_\_bang\_findfirst1, \_\_bang\_findlast1, \_\_bang\_maximum, \_\_bang\_lock, \_\_bang\_unlock, \_\_nramset\_float, \_\_nramset\_half, \_\_nramset\_int, \_\_nramset\_unsigned\_int, \_\_nramset\_short, \_\_nramset\_unsigned\_short, \_\_nramset, \_\_bang\_div, \_\_bang\_half2uchar\_dn, \_\_bang\_pad, \_\_bang\_int2float, \_\_bang\_float2int\_dn, \_\_bang\_float2int\_tz, \_\_bang\_float2int\_oz, \_\_bang\_float2int\_up, \_\_bang\_float2int\_rd, \_\_bang\_float2int\_rn, \_\_bang\_float2int\_rm, \_\_bang\_char2int, \_\_bang\_char2short, \_\_bang\_int2char, \_\_bang\_int2short, \_\_bang\_short2char, \_\_bang\_short2int, \_\_bang\_half2char\_dn.
* **V3.8.0**


**Date** : December 20, 2021


**Changes** :



	+ Added built-in functions including \_\_bang\_abs, \_\_bang\_square, \_\_bang\_relu, \_\_bang\_sra, \_\_bang\_sll, \_\_bang\_srl, \_\_bang\_neg, \_\_bang\_nsa, \_\_bang\_ror, \_\_bang\_rol, \_\_nramset, \_\_sramset, \_\_ldramset, \_\_gdramset, \_\_bang\_adds, \_\_bang\_subs, \_\_bang\_muls, \_\_bang\_mulh, \_\_bang\_set0in32, \_\_bang\_set1in32, \_\_bang\_adds\_scalar, \_\_bang\_subs\_scalar, \_\_bang\_muls\_scalar, \_\_bang\_mulh\_scalar, \_\_bang\_cycle\_adds, \_\_bang\_cycle\_subs, \_\_bang\_cycle\_muls, \_\_bang\_cycle\_mulh.
	+ Added `int8`, `int16` and `int32` data types for \_\_bang\_or, \_\_bang\_and, \_\_bang\_xor, \_\_bang\_not, \_\_bang\_band, \_\_bang\_bor, \_\_bang\_bxor, \_\_bang\_bnot.
* **V3.7.0**


**Date** : December 15, 2021


**Changes** :



	+ Added built-in functions: Atomic Reduce Functions.
	+ Added `int4` and `fix4` date types for \_\_bang\_conv, \_\_bang\_conv\_partial.
	+ Added `int4` date type for Vector Type Conversion Functions.
	+ Supported GDRAM2GDRAM and GDRAM2LDRAM direction in \_\_memcpy\_async interface.
	+ Supported negative `src\_stride` for 2D memcpy, and support negative `dim0 stride` for 3D memcpy.
* **V3.6.0**


**Update Data** : November 18, 2021


**Changes** :



	+ Internal update.
* **V3.5.0**


**Update Data** : August 30, 2021


**Changes** :



	+ Internal update.
* **V3.4.0**


**Date** : July 20, 2021


**Changes** :



	+ Supported GDRAM2WRAM direction in \_\_memcpy\_async interface.
	+ Added built-in functions: \_\_bang\_rem, \_\_is\_nram, \_\_is\_wram, \_\_is\_sram, \_\_is\_ipu, \_\_is\_mpu, \_\_popcnt, \_\_bang\_popcnt.
* **V3.3.0**


**Date** : June 26, 2021


**Changes** :



	+ Supported `tp\_322` architecture.
	+ Added built-in functions on all targets: \_\_sync\_all\_ipu, \_\_sync\_all\_mpu, \_\_sync\_cluster, \_\_sync\_all.
	+ Added `int16`, `half` and `float` data types for built-in function: \_\_bang\_histogram.
* **V3.2.0**


**Date** : April 26, 2021


**Changes** :



	+ Added built-in functions: \_\_memcpy\_async, \_\_bang\_write\_value, \_\_bang\_integral, \_\_bang\_lut\_s16, \_\_bang\_lut\_s32.
	+ Added `<indilation\_x>`, `<indilation\_y>`, `<outdilation\_x>` and `<outdilation\_y>` parameters for built-in functions \_\_bang\_conv or \_\_bang\_conv\_partial .
	+ Added built-in functions on `(m)tp\_3xx` : \_\_bang\_taylor3\_sin, \_\_bang\_taylor4\_sin, \_\_bang\_taylor3\_cos, \_\_bang\_taylor4\_cos, \_\_bang\_taylor3\_tanh, \_\_bang\_taylor4\_tanh, \_\_bang\_taylor3\_sigmoid, \_\_bang\_taylor4\_sigmoid, \_\_bang\_taylor3\_softplus, \_\_bang\_taylor4\_softplus.
* **V3.1.0**


**Update Data** : March 24, 2021


**Changes** :



	+ Added built-in functions: \_\_bang\_argmax, \_\_bang\_argmin.
	+ Added built-in functions on `(m)tp\_3xx` : \_\_bang\_active\_abs, \_\_bang\_active\_cos, \_\_bang\_active\_exp, \_\_bang\_active\_exphp, \_\_bang\_active\_exp\_less\_0, \_\_bang\_active\_gelu, \_\_bang\_active\_gelup, \_\_bang\_active\_log, \_\_bang\_active\_loghp, \_\_bang\_active\_pow2, \_\_bang\_active\_recip, \_\_bang\_active\_recip\_greater\_1, \_\_bang\_active\_reciphp, \_\_bang\_active\_relu, \_\_bang\_active\_rsqrt, \_\_bang\_active\_rsqrthp, \_\_bang\_active\_sigmoid, \_\_bang\_active\_sign, \_\_bang\_active\_sin, \_\_bang\_active\_sqrt, \_\_bang\_active\_sqrthp, \_\_bang\_active\_tanh, \_\_bang\_rand.
	+ Added `bfloat16\_t` data type for built-in functions: \_\_bang\_conv, \_\_bang\_conv\_partial, \_\_bang\_float2bfloat16\_rn, \_\_bang\_float2bfloat16\_rm, \_\_bang\_float2bfloat16\_rd, \_\_bang\_float2bfloat16\_up, \_\_bang\_float2bfloat16\_oz, \_\_bang\_float2bfloat16\_dn, \_\_bang\_float2bfloat16\_tz, \_\_bang\_bfloat162float.
* **V3.0.0**


**Date** : March 8, 2021


**Changes** :



	+ Added built-in functions supported on `mtp\_372` : \_\_bang\_sin, \_\_bang\_cos, \_\_bang\_log, \_\_bang\_pow2, \_\_bang\_sqrt, \_\_bang\_recip, \_\_bang\_rsqrt, \_\_bang\_fusion, \_\_bang\_fcmpfilter, \_\_bang\_fabsmax, \_\_bang\_fabsmin, \_\_bang\_relu, \_\_bang\_relun, \_\_bang\_int2float, \_\_memcpy , \_\_bang\_float2half\_rm, \_\_bang\_float2half\_rn, \_\_bang\_float2int16\_rm, \_\_bang\_float2int16\_rn, \_\_bang\_float2int8\_rm, \_\_bang\_float2int8\_rn, \_\_bang\_half2int16\_rm, \_\_bang\_half2int16\_rn, \_\_bang\_half2int8\_rm, \_\_bang\_half2int8\_rn, \_\_bang\_half2short\_rm, \_\_bang\_half2short\_rn, \_\_bang\_float2int\_dn, \_\_bang\_float2int\_tz, \_\_bang\_float2int\_oz, \_\_bang\_float2int\_up, \_\_bang\_float2int\_rd, \_\_bang\_float2int\_rn, \_\_bang\_float2int\_rm, \_\_bang\_maxpool\_value\_index, \_\_bang\_minpool\_value\_index.
* **V2.16.0**


**Date** : March 2, 2021


**Changes** :



	+ Supported \_\_memcpy\_async with stride.
* **V2.15.0**


**Date** : February 3, 2021


**Changes** :



	+ Added new direction NRAM2WRAM for \_\_memcpy with stride.
	+ Updated input dilation parameter for \_\_bang\_conv\_partial on `mtp\_270` and `mtp\_290`.

**Date** : January 21, 2021


**Changes** :



	+ Added build-in function: \_\_memset\_nram .
* **V2.8.0**


**Date** : August 11, 2020


**Changes** :



	+ Added build-in function: \_\_bang\_ge\_const, \_\_bang\_taylor3\_sin, \_\_bang\_taylor4\_sin, \_\_bang\_taylor3\_cos, \_\_bang\_taylor4\_cos, \_\_bang\_taylor3\_tanh, \_\_bang\_taylor4\_tanh, \_\_bang\_taylor3\_sigmoid, \_\_bang\_taylor4\_sigmoid, \_\_bang\_taylor3\_softplus, \_\_bang\_taylor4\_softplus.
	+ Added example for \_\_memcpy .
	+ Deleted `<fix\_position>` of \_\_bang\_uchar2half .
	+ Updated example of \_\_bang\_maxpool\_bp .
	+ Updated align of \_\_bang\_mul, \_\_bang\_sub, \_\_bang\_add, \_\_bang\_mul\_const, \_\_bang\_rotate90, \_\_bang\_rotate180, \_\_bang\_rotate270 .
	+ Updated parameters of \_\_bang\_avgpool\_bp, \_\_bang\_maxpool\_bp, \_\_bang\_histogram, \_\_bang\_mirror .
	+ Updated homologous operand of \_\_bang\_mul, \_\_bang\_add\_const, \_\_bang\_avgpool, \_\_bang\_collect, \_\_bang\_collect\_bitindex, \_\_bang\_conv, \_\_bang\_conv\_partial, \_\_bang\_count, \_\_bang\_count\_bitindex, \_\_bang\_cycle\_add, \_\_bang\_cycle\_ne, \_\_bang\_cycle\_le, \_\_bang\_cycle\_gt, \_\_bang\_cycle\_mul, \_\_bang\_cycle\_sub, \_\_bang\_div, \_\_bang\_findfirst1, \_\_bang\_findlast1, \_\_bang\_count, \_\_bang\_maskmove\_bitindex, \_\_bang\_maximum, \_\_bang\_maxpool, \_\_bang\_maxpool\_index, \_\_bang\_minpool\_index, \_\_bang\_mlp, \_\_bang\_mul\_const, \_\_bang\_pad, \_\_bang\_reduce\_sum, \_\_bang\_select, \_\_bang\_select\_bitindex, \_\_bang\_square, \_\_bang\_sub\_const, \_\_bang\_sumpool, \_\_bang\_tiling\_2d\_b128, \_\_bang\_tiling\_2d\_b16, \_\_bang\_tiling\_2d\_b256, \_\_bang\_tiling\_2d\_b32, \_\_bang\_tiling\_2d\_b64, \_\_bang\_tiling\_2d\_b8, \_\_bang\_tiling\_3d\_b1024, \_\_bang\_transpose, \_\_bang\_unpool, \_\_bang\_reshape\_filter, \_\_bang\_reshape\_nhwc2nchw, \_\_bang\_reshape\_nchw2nhwc, \_\_bang\_cycle\_eq, \_\_bang\_eq\_bitindex, \_\_bang\_ge, \_\_bang\_ge\_bitindex, \_\_bang\_gt, \_\_bang\_gt\_bitindex, \_\_bang\_le, \_\_bang\_le\_bitindex, \_\_bang\_lt, \_\_bang\_lt\_bitindex, \_\_bang\_ne, \_\_bang\_ne\_bitindex, \_\_bang\_and, \_\_bang\_band, \_\_bang\_bnot, \_\_bang\_bor, \_\_bang\_bxor, \_\_bang\_cycle\_and, \_\_bang\_cycle\_band, \_\_bang\_cycle\_bor, \_\_bang\_cycle\_bxor, \_\_bang\_cycle\_maxequal, \_\_bang\_cycle\_minequal, \_\_bang\_cycle\_or, \_\_bang\_cycle\_xor, \_\_bang\_max, \_\_bang\_maxequal, \_\_bang\_min, \_\_bang\_minequal, \_\_bang\_or, \_\_bang\_xor.
* **V2.6.0**


**Date** : May 27, 2020


**Changes** :



	+ Updated high precision active interface.








3.1. 1D Memcpy Functions
=========================



3.1.1. \_\_bang\_move
----------------------




void `__bang_move`(void \**dst*, *const* void \**src*, unsigned int *size*)  

Copies `<size>` bytes data from source address `<src>` to destination address `<dst>`.



**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes to be copied.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<size>` must be divisible by 128 on `(m)tp\_2xx` ;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx` .
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src1\_nram[512];
  \_\_nram\_\_ int8\_t src2\_nram[512];
  \_\_memcpy(src1\_nram, src, 512, GDRAM2NRAM);
  \_\_bang\_move(src2\_nram, src1\_nram, 512);
  \_\_memcpy(dst, src2\_nram, 512, NRAM2GDRAM);
}

```













3.1.2. \_\_memcpy
------------------




void `__memcpy`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*)  




void `__memcpy`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*, unsigned int *id\_dst\_cluster*)  

Copies `<size>` bytes data from source address `<src>` to destination address `<dst>`. The copy direction is specified by `<dir>`.



**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes to be copied.
* `[in] dir`: Copy direction.
* `[in] id\_dst\_cluster`: Destination cluster ID.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `\_\_memcpy` with `<id\_dst\_cluster>` is not supported on `(m)tp\_5xx` or higher;
* The address of `\_\_nram\_\_` address space, to which `<src>` or `<dst>` points, must be 64-byte aligned, when `<dir>` is NRAM2NRAM on `(m)tp\_2xx`;
* `<id\_dst\_cluster>` is necessarily used when `<dir>` is SRAM2SRAM and data is copied across different clusters. When there is no `<id\_dst\_cluster>`, it means copy within cluster;
* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on `tp\_322` and `(m)tp\_372`, and is 0 on other targets;
* The alignment constraints of address of `<dst>` or `<src>` in `\_\_memcpy` are shown in the table Alignment Constraints of Address Space in \_\_memcpy;




Table 3.1 Alignment Constraints of Address Space in `\_\_memcpy`








| Address Space | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM | 8B | 8B | 8B | 8B | 8B | 8B |


* The supported copy directions of `\_\_memcpy` on different targets are shown in the table Direction Constraints of \_\_memcpy;




Table 3.2 Direction Constraints of `\_\_memcpy`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2SRAM | N | Y | N | Y | Y | N |
| GDRAM2NRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2WRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2SRAM | N | Y | N | Y | Y | N |
| LDRAM2NRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2WRAM | Y | Y | Y | Y | Y | Y |
| SRAM2GDRAM | N | Y | N | Y | Y | N |
| SRAM2LDRAM | N | Y | N | Y | Y | N |
| SRAM2SRAM | N | Y | N | Y | Y | N |
| SRAM2NRAM | N | Y | N | Y | Y | N |
| SRAM2WRAM | N | Y | N | Y | Y | N |
| NRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| NRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| NRAM2SRAM | N | Y | N | Y | Y | N |
| NRAM2NRAM | Y | Y | Y | Y | Y | Y |
| NRAM2WRAM | Y | Y | Y | Y | Y | Y |
| WRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| WRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| WRAM2SRAM | N | Y | N | Y | Y | N |
| WRAM2NRAM | Y | Y | Y | Y | Y | Y |
| WRAM2WRAM | N | N | N | N | N | N |


* The alignment constraints of `<size>` in `\_\_memcpy` are shown in the table Alignment Constraints of size in \_\_memcpy;




Table 3.3 Alignment Constraints of `size` in `\_\_memcpy`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| GDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2WRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| LDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| LDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2WRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| SRAM2GDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2LDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2NRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2WRAM | NA | 64B | NA | 16B | 16B | NA |
| NRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2NRAM | 128B | 128B | 1B | 1B | 1B | 1B |
| NRAM2WRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| WRAM2GDRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| WRAM2LDRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| WRAM2SRAM | NA | 64B | NA | 16B | 16B | NA |
| WRAM2NRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| WRAM2WRAM | NA | NA | NA | NA | NA | NA |









**Instruction Pipeline*** If `<dir>` is NRAM2NRAM, execute in Compute instruction pipeline;
* If either `<src>` or `<dst>` is `off-chip address`, execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;
* If `<dir>` is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
if (clusterId == 0) {
  // Step1. load data from GDRAM to cluster0's SRAM
  // auto running on MPU, no need to specify coreId == 0x80
  \_\_memcpy(S, src, size \* coreDim, GDRAM2SRAM);
  \_\_sync\_cluster();

  // Step2. test inside cluster0
  \_\_memcpy(A, S + offset, size, SRAM2NRAM);
  \_\_memcpy(C, A, size, NRAM2NRAM);
  \_\_memcpy(S + offset, C, size, NRAM2SRAM);
  \_\_sync\_cluster();

  // Step3. push S from Cluster0 to Cluster1
  \_\_memcpy(S, S, size \* coreDim, SRAM2SRAM, clusterId + 1);
}

```













3.1.3. \_\_memcpy\_async
-------------------------




void `__memcpy_async`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*)  

Copies `<size>` bytes data from source address `<src>` to destination address `<dst>` asynchronously. The copy direction is specified by `<dir>`.



**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes to be copied.
* `[in] dir`: Copy direction.



**Return*** `void`.






**Remark*** `<size>` must be a greater than zero;
* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on `tp\_322` and `(m)tp\_372`, and is 0 on other targets;
* The alignment constraints of address of `<dst>` or `<src>` in `\_\_memcpy\_async` are shown in the table Alignment Constraints of Address Space in \_\_memcpy;
* The supported copy directions of `\_\_memcpy\_async` on different targets are shown in the table Direction Constraints of \_\_memcpy\_async;




Table 3.4 Direction Constraints of `\_\_memcpy\_async`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2SRAM | N | Y | N | Y | Y | N |
| GDRAM2NRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2WRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2SRAM | N | Y | N | Y | Y | N |
| LDRAM2NRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2WRAM | Y | Y | Y | Y | Y | Y |
| SRAM2GDRAM | N | Y | N | Y | Y | N |
| SRAM2LDRAM | N | Y | N | Y | Y | N |
| SRAM2SRAM | N | Y | N | Y | Y | N |
| SRAM2NRAM | N | Y | N | Y | Y | N |
| SRAM2WRAM | N | Y | N | Y | Y | N |
| NRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| NRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| NRAM2SRAM | N | Y | N | Y | Y | N |
| NRAM2NRAM | Y | Y | Y | Y | Y | Y |
| NRAM2WRAM | Y | Y | Y | Y | Y | Y |
| WRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| WRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| WRAM2SRAM | N | Y | N | Y | Y | N |
| WRAM2NRAM | Y | Y | Y | Y | Y | Y |
| WRAM2WRAM | N | N | N | N | N | N |


* The alignment constraints of `<size>` in `\_\_memcpy\_async` are shown in the table Alignment Constraints of size in \_\_memcpy\_async;




Table 3.5 Alignment Constraints of `size` in `\_\_memcpy\_async`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| GDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2WRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| LDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| LDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2WRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| SRAM2GDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2LDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2NRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2WRAM | NA | 64B | NA | 16B | 16B | NA |
| NRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2NRAM | 128B | 128B | 1B | 1B | 1B | 1B |
| NRAM2WRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| WRAM2GDRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| WRAM2LDRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| WRAM2SRAM | NA | 64B | NA | 16B | 16B | NA |
| WRAM2NRAM | 64B | 64B | 16B | 16B | 16B | 16B |
| WRAM2WRAM | NA | NA | NA | NA | NA | NA |









**Instruction Pipeline*** If `<dir>` is NRAM2NRAM, execute in Compute instruction pipeline;
* If either `<src>` or `<dst>` is `off-chip address`, execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;
* If `<dir>` is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.

















3.2. 1D Memset Functions
=========================



3.2.1. \_\_bang\_write\_value
------------------------------




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, char *value*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, int *value*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, short *value*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, float *value*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, half *value*)  

Sets a vector in the `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: The value to be set to `<dst>`.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count> \* sizeof(type)` must be divisible by 64 `(m)tp\_2xx`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` ;
* CNCC Version: `cncc --version >= 3.2.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx` .






**Example*** None.













3.2.2. \_\_bang\_write\_zero
-----------------------------




void `__bang_write_zero`(bfloat16\_t \**dst*, unsigned int *elem\_count*)  




void `__bang_write_zero`(signed char \**dst*, unsigned int *elem\_count*)  




void `__bang_write_zero`(unsigned char \**dst*, unsigned int *elem\_count*)  




void `__bang_write_zero`(short \**dst*, unsigned int *elem\_count*)  




void `__bang_write_zero`(unsigned short \**dst*, unsigned int *elem\_count*)  




void `__bang_write_zero`(int \**dst*, unsigned int *elem\_count*)  




void `__bang_write_zero`(unsigned int \**dst*, unsigned int *elem\_count*)  




void `__bang_write_zero`(half \**dst*, unsigned int *elem\_count*)  




void `__bang_write_zero`(float \**dst*, unsigned int *elem\_count*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to zero.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements in destination vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.2.3. \_\_gdramset
--------------------




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, char *value*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, short *value*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, half *value*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, float *value*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, int *value*)  

Sets a vector in `\_\_mlu\_device\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.2.4. \_\_ldramset
--------------------




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, char *value*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, short *value*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, half *value*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, float *value*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, int *value*)  

Sets a vector in `\_\_ldram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` must point to `\_\_ldram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.2.5. \_\_memset\_nram
------------------------




void `__memset_nram`(void \**dst*, unsigned int *elem\_count*, char *value*)  




void `__memset_nram`(void \**dst*, unsigned int *elem\_count*, short *value*)  




void `__memset_nram`(void \**dst*, unsigned int *elem\_count*, half *value*)  




void `__memset_nram`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*)  




void `__memset_nram`(void \**dst*, unsigned int *elem\_count*, float *value*)  




void `__memset_nram`(void \**dst*, unsigned int *elem\_count*, int *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.16.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.2.6. \_\_memset\_nram\_async
-------------------------------




void `__memset_nram_async`(void \**dst*, unsigned int *elem\_count*, char *value*)  




void `__memset_nram_async`(void \**dst*, unsigned int *elem\_count*, short *value*)  




void `__memset_nram_async`(void \**dst*, unsigned int *elem\_count*, half *value*)  




void `__memset_nram_async`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*)  




void `__memset_nram_async`(void \**dst*, unsigned int *elem\_count*, float *value*)  




void `__memset_nram_async`(void \**dst*, unsigned int *elem\_count*, int *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>` asynchronously.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.2.7. \_\_sramset
-------------------




void `__sramset`(void \**dst*, unsigned int *elem\_count*, char *value*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, half *value*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, short *value*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, float *value*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, int *value*)  

Sets a vector in `\_\_mlu\_shared\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` must point to `\_\_mlu\_shared\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move instruction pipeline of MPU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.2.8. \_\_sramset\_async
--------------------------




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, char *value*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, half *value*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, short *value*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, float *value*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, int *value*)  

Sets a vector in `\_\_mlu\_shared\_\_` address space pointed by `<dst>` to the specified `<value>` asynchronously.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` must point to `\_\_mlu\_shared\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move instruction pipeline of MPU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.

















3.3. 2D Memcpy Functions
=========================



3.3.1. \_\_bang\_move
----------------------




void `__bang_move`(void \**dst*, *const* void \**src*, unsigned int *size*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

Copies `<size>` bytes data from `<src>` source address to `<dst>` destination address.


As shown in Figure Memory Copy Function with Stride , the blue background indicates the data to be copied.









**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes of one data segment.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of data segment minus one.



**Return*** `void`.






**Remark*** When `<segnum>` is 0, it means that it is copied once. The real segment number is the given value plus one;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<size>` must be divisible by 128 on `(m)tp\_2xx` and `mtp\_372`;
* `<dst\_stride>` must be greater than or equal to `<size>` ;
* `<dst\_stride>` must be divisible by 64 on `(m)tp\_2xx` ;
* `<src\_stride>` must be greater than or equal to zero;
* `<src\_stride>` must be divisible by 64 on `(m)tp\_2xx` ;
* `<dst>` cannot be overlapped with `<src>` on `(m)tp\_2xx` and `mtp\_370`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Example**
```
#include <bang.h>

#define LEN 64
#define DST\_STRIDE 512
#define SRC\_STRIDE 128
#define SEGNUM 7

\_\_mlu\_entry\_\_ void kernel2D(int8\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src1\_nram[512];
  \_\_nram\_\_ int8\_t src2\_nram[512];
  \_\_memcpy(src1\_nram, src, 512, GDRAM2NRAM);
  \_\_bang\_move(src2\_nram, src1\_nram, LEN, DST\_STRIDE, SRC\_STRIDE, SEGNUM);
  \_\_memcpy(dst, src2\_nram, 512, NRAM2GDRAM);
}

```













3.3.2. \_\_memcpy
------------------




void `__memcpy`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*, unsigned int *dst\_stride*, int *src\_stride*, unsigned int *segnum*)  




void `__memcpy`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*, unsigned int *dst\_stride*, int *src\_stride*, unsigned int *segnum*, unsigned int *id\_dst\_cluster*)  

Copies `<size>` bytes data from source address `<src>` to destination address `<dst>`. The copy direction is specified by `<dir>`.




![../_images/11.6.png](../_images/11.6.png)

Fig. 3.1 Memory Copy Function with Stride





As shown in Figure Memory Copy Function with Stride , each cell represents 64 bytes and the cells with blue background indicate the data to be copied which is 128 bytes in each segment. There are 3 segments in source area and in each segment only the first 128 bytes of every 256 bytes are copied to destination area. Please note that `<segnum>` is the real segment number minus one, that is, `<segnum> = 2` in this case.









**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes of one segment.
* `[in] dir`: Copy direction.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.
* `[in] id\_dst\_cluster`: Destination cluster ID.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* The range of `<segnum>` is [0, 65535];
* When the segment number is 0, it means that it is copied once. The real segment number value is the given value plus one;
* `<dst\_stride>` must be greater than or equal to `<size>`;
* `\_\_memcpy` with `<id\_dst\_cluster>` is not supported on `(m)tp\_5xx` or higher;
* `<id\_dst\_cluster>` is necessarily used when `<dir>` is SRAM2SRAM and data is copied across different clusters. When there is no `<id\_dst\_cluster>`, it means copy within cluster;
* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on `tp\_322` and `(m)tp\_372`, and is 0 on other targets;
* The alignment constraints of address of `<dst>` or `<src>` in `\_\_memcpy` are shown in the table Alignment Constraints of Address Space in \_\_memcpy;




Table 3.6 Alignment Constraints of Address Space in `\_\_memcpy`








| Address Space | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM | 8B | 8B | 8B | 8B | 8B | 8B |


* The supported copy directions of `\_\_memcpy` on different targets are shown in the table Direction Constraints of \_\_memcpy;




Table 3.7 Direction Constraints of `\_\_memcpy`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2SRAM | N | Y | N | Y | Y | N |
| GDRAM2NRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2WRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2SRAM | N | Y | N | Y | Y | N |
| LDRAM2NRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2WRAM | Y | Y | Y | Y | Y | Y |
| SRAM2GDRAM | N | Y | N | Y | Y | N |
| SRAM2LDRAM | N | Y | N | Y | Y | N |
| SRAM2SRAM | N | Y | N | Y | Y | N |
| SRAM2NRAM | N | Y | N | Y | Y | N |
| SRAM2WRAM | N | Y | N | Y | Y | N |
| NRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| NRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| NRAM2SRAM | N | Y | N | Y | Y | N |
| NRAM2NRAM | Y | Y | Y | Y | Y | Y |
| NRAM2WRAM | Y | Y | Y | Y | Y | Y |
| WRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| WRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| WRAM2SRAM | N | Y | N | Y | Y | N |
| WRAM2NRAM | Y | Y | Y | Y | Y | Y |
| WRAM2WRAM | N | N | N | N | N | N |


* The alignment constraints of `<size>` in `\_\_memcpy` are shown in the table Alignment Constraints of size in \_\_memcpy .




Table 3.8 Alignment Constraints of `size` in `\_\_memcpy`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| GDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| LDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| SRAM2GDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2LDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2NRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2WRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| WRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2WRAM | NA | NA | NA | NA | NA | NA |


* The alignment constraints of `<dst\_stride>` in `\_\_memcpy` are shown in the table Alignment Constraints of dst\_stride in \_\_memcpy;




Table 3.9 Alignment Constraints of `dst\_stride` in `\_\_memcpy`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| GDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2WRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| LDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| LDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2WRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| SRAM2GDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2LDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2NRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2WRAM | NA | 8B | NA | 8B | 8B | NA |
| NRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2WRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| WRAM2GDRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| WRAM2LDRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| WRAM2SRAM | NA | 8B | NA | 8B | 8B | NA |
| WRAM2NRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| WRAM2WRAM | NA | NA | NA | NA | NA | NA |


* The alignment constraints of `<src\_stride>` in `\_\_memcpy` are shown in the table Alignment Constraints of src\_stride in \_\_memcpy .




Table 3.10 Alignment Constraints of `src\_stride` in `\_\_memcpy`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| GDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| LDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| SRAM2GDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2LDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2NRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2WRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| WRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2WRAM | NA | NA | NA | NA | NA | NA |









**Instruction Pipeline*** If either `<src>` or `<dst>` is `off-chip address`, execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;
* If `<dir>` is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.3.3. \_\_memcpy\_async
-------------------------




void `__memcpy_async`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*, unsigned int *dst\_stride*, int *src\_stride*, unsigned int *segnum*)  

Copies `<size>` bytes data from source address `<src>` to destination address `<dst>` asynchronously. The copy direction is specified by `<dir>`.




![../_images/11.61.png](../_images/11.61.png)

Fig. 3.2 Asynchronous Memory Copy Function with Stride





As shown in Figure Asynchronous Memory Copy Function with Stride , each cell represents 64 bytes and the cells with blue background indicate the data to be copied which is 128 bytes in each segment. There are 3 segments in source area and in each segment only the first 128 bytes of every 256 bytes are copied to destination area. Please note that `<segnum>` is the real segment number minus one, that is, `<segnum> = 2` in this case.









**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes to be copied.
* `[in] dir`: Copy direction.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* The range of `<segnum>` is [0, 65535];
* When the segment number is 0, it means that it is copied once. The real segment number value is the given value plus one;
* `<dst\_stride>` must be greater than or equal to `<size>`;
* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on `tp\_322` and `(m)tp\_372`, and is 0 on other targets;
* The alignment constraints of address of `<dst>` or `<src>` in `\_\_memcpy\_async` are shown in the table Alignment Constraints of Address Space in \_\_memcpy;
* The supported copy directions of `\_\_memcpy\_async` on different targets are shown in the table Direction Constraints of \_\_memcpy\_async;




Table 3.11 Direction Constraints of `\_\_memcpy\_async`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2SRAM | N | Y | N | Y | Y | N |
| GDRAM2NRAM | Y | Y | Y | Y | Y | Y |
| GDRAM2WRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2SRAM | N | Y | N | Y | Y | N |
| LDRAM2NRAM | Y | Y | Y | Y | Y | Y |
| LDRAM2WRAM | Y | Y | Y | Y | Y | Y |
| SRAM2GDRAM | N | Y | N | Y | Y | N |
| SRAM2LDRAM | N | Y | N | Y | Y | N |
| SRAM2SRAM | N | Y | N | Y | Y | N |
| SRAM2NRAM | N | Y | N | Y | Y | N |
| SRAM2WRAM | N | Y | N | Y | Y | N |
| NRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| NRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| NRAM2SRAM | N | Y | N | Y | Y | N |
| NRAM2NRAM | Y | Y | Y | Y | Y | Y |
| NRAM2WRAM | Y | Y | Y | Y | Y | Y |
| WRAM2GDRAM | Y | Y | Y | Y | Y | Y |
| WRAM2LDRAM | Y | Y | Y | Y | Y | Y |
| WRAM2SRAM | N | Y | N | Y | Y | N |
| WRAM2NRAM | Y | Y | Y | Y | Y | Y |
| WRAM2WRAM | N | N | N | N | N | N |


* The alignment constraints of `<size>` in `\_\_memcpy\_async` are shown in the table Alignment Constraints of size in \_\_memcpy\_async;




Table 3.12 Alignment Constraints of `size` in `\_\_memcpy\_async`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| GDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| LDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| SRAM2GDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2LDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2NRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2WRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| WRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2WRAM | NA | NA | NA | NA | NA | NA |


* The alignment constraints of `<dst\_stride>` in `\_\_memcpy\_async` are shown in the table Alignment Constraints of dst\_stride in \_\_memcpy\_async;




Table 3.13 Alignment Constraints of `dst\_stride` in `\_\_memcpy\_async`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| GDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2WRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| LDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| LDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2WRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| SRAM2GDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2LDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2NRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2WRAM | NA | 8B | NA | 8B | 8B | NA |
| NRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2WRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| WRAM2GDRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| WRAM2LDRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| WRAM2SRAM | NA | 8B | NA | 8B | 8B | NA |
| WRAM2NRAM | 8B | 8B | 8B | 8B | 8B | 8B |
| WRAM2WRAM | NA | NA | NA | NA | NA | NA |


* The alignment constraints of `<src\_stride>` in `\_\_memcpy\_async` are shown in the table Alignment Constraints of src\_stride in \_\_memcpy\_async;




Table 3.14 Alignment Constraints of `src\_stride` in `\_\_memcpy\_async`








| Direction | tp\_220
tp\_270 | mtp\_220
mtp\_270
mtp\_290 | tp\_322 | mtp\_372 | mtp\_592 | tp\_520 |
| --- | --- | --- | --- | --- | --- | --- |
| GDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| GDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| GDRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| LDRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| LDRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| SRAM2GDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2LDRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2NRAM | NA | 1B | NA | 1B | 1B | NA |
| SRAM2WRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| NRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| NRAM2WRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2GDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2LDRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2SRAM | NA | 1B | NA | 1B | 1B | NA |
| WRAM2NRAM | 1B | 1B | 1B | 1B | 1B | 1B |
| WRAM2WRAM | NA | NA | NA | NA | NA | NA |









**Instruction Pipeline*** If either `<src>` or `<dst>` is `off-chip address`, execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;
* If `<dir>` is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.

















3.4. 2D Memset Functions
=========================



3.4.1. \_\_gdramset
--------------------




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride*, unsigned int *segnum*)  

Sets the specified `<value>` to a two-dimensional block in the `\_\_mlu\_device\_\_` address space pointed by `<dst>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum> + 1` times through the `<stride>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride`: The destination address stride(bytes).
* `[in] segnum`: The destination segment number.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride>` must be greater than or equal to `<elem\_count> \* sizeof(type)`;
* When `<segnum>` is 0, it represents 1, and when `<segnum>` is 1, it represents 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.4.2. \_\_ldramset
--------------------




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride*, unsigned int *segnum*)  

Sets the specified `<value>` to a two-dimensional block in the `\_\_ldram\_\_` address space pointed by `<dst>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum> + 1` times through the `<stride>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride`: The destination address stride(bytes).
* `[in] segnum`: The destination segment number.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_ldram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride>` must be greater than or equal to `<elem\_count> \* sizeof(type)`;
* When `<segnum>` is 0, it represents 1, and when `<segnum>` is 1, it represents 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.4.3. \_\_nramset
-------------------




void `__nramset`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride*, unsigned int *segnum*)  

Sets the specified `<value>` to a two-dimensional block in the `\_\_nram\_\_` address space pointed by `<dst>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum> + 1` times through the `<stride>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride`: The destination address stride(bytes).
* `[in] segnum`: The destination segment number.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride>` must be greater than or equal to `<elem\_count> \* sizeof(type)`;
* When `<segnum>` is 0, it represents 1, and when `<segnum>` is 1, it represents 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.4.4. \_\_nramset\_async
--------------------------




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride*, unsigned int *segnum*)  

Sets the specified `<value>` to a two-dimensional block in the `\_\_nram\_\_` address space pointed by `<dst>` asynchronously. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum> + 1` times through the `<stride>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride`: The destination address stride(bytes).
* `[in] segnum`: The destination segment number.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride>` must be greater than or equal to `<elem\_count> \* sizeof(type)`;
* When `<segnum>` is 0, it represents 1, and when `<segnum>` is 1, it represents 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.4.5. \_\_sramset
-------------------




void `__sramset`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride*, unsigned int *segnum*)  

Sets the specified `<value>` to a two-dimensional block in the `\_\_mlu\_shared\_\_` address space pointed by `<dst>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum> + 1` times through the `<stride>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride`: The destination address stride(bytes).
* `[in] segnum`: The destination segment number.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_mlu\_shared\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride>` must be greater than or equal to `<elem\_count> \* sizeof(type)`;
* When `<segnum>` is 0, it represents 1, and when `<segnum>` is 1, it represents 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move instruction pipeline of MPU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.4.6. \_\_sramset\_async
--------------------------




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride*, unsigned int *segnum*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride*, unsigned int *segnum*)  

Sets the specified `<value>` to a two-dimensional block in the `\_\_mlu\_shared\_\_` address space pointed by `<dst>` asynchronously. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum> + 1` times through the `<stride>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride`: The destination address stride(bytes).
* `[in] segnum`: The destination segment number.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_mlu\_shared\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride>` must be greater than or equal to `<elem\_count> \* sizeof(type)`;
* When `<segnum>` is 0, it represents 1, and when `<segnum>` is 1, it represents 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move instruction pipeline of MPU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_322` and `tp\_520`.






**Example*** None.

















3.5. 3D Atomic Functions
=========================



3.5.1. \_\_bang\_atomic\_add
-----------------------------




void `__bang_atomic_add`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_add`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_add`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_add`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_add`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Copies `<src0>` to `<dst>`, adds `<src1>` to `<src0>` element-wisely. That is: `<dst>` = `<src0>`; `<src0>` = `<src0>` + `<src1>`. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel() {
  \_\_nram\_\_ short v[128];
  \_\_mlu\_device\_\_ short src0[128];
  \_\_nram\_\_ short src1[128];
  \_\_bang\_atomic\_add(v, src0, src1, 16, 0, 0, 16, 16, 16, 16, 16, 16);
}

```













3.5.2. \_\_bang\_atomic\_add\_async
------------------------------------




void `__bang_atomic_add_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_add_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_add_async`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_add_async`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_add_async`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously copies `<src0>` to `<dst>`, adds `<src1>` to `<src0>` element-wisely. That is: `<dst>` = `<src0>`; `<src0>` = `<src0>` + `<src1>`. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel() {
  \_\_nram\_\_ short v[128];
  \_\_mlu\_device\_\_ short src0[128];
  \_\_nram\_\_ short src1[128];
  \_\_bang\_atomic\_add\_async(v, src0, src1, 16, 0, 0, 16, 16, 16, 16, 16, 16);
}

```













3.5.3. \_\_bang\_atomic\_and
-----------------------------




void `__bang_atomic_and`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_and`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Applies bitwise AND operation to the vector `<src0>` and `<src1>`, stores the result in `<src0>`, and stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = `<src0>` & `<src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.4. \_\_bang\_atomic\_and\_async
------------------------------------




void `__bang_atomic_and_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_and_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously applies bitwise AND operation to the vector `<src0>` and `<src1>`, stores the result in `<src0>`, and stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = `<src0>` & `<src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.5. \_\_bang\_atomic\_dec
-----------------------------




void `__bang_atomic_dec`(unsigned short \**dst*, unsigned short \**src0*, unsigned short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_dec`(unsigned int \**dst*, unsigned int \**src0*, unsigned int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_dec`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_dec`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Compares vector `<src0>` and `<src1>` element-wisely. If `<src0>` is larger than `<src1>`, or the value of `<src0>` is 0, stores the int value `<src1>` in `<src0>`; otherwise, subtracts `<src0>` by 1. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` == 0 || `<src0>` > `<src1>`) ? `<src1>` : (`<src0>` - 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.6. \_\_bang\_atomic\_dec\_async
------------------------------------




void `__bang_atomic_dec_async`(unsigned short \**dst*, unsigned short \**src0*, unsigned short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_dec_async`(unsigned int \**dst*, unsigned int \**src0*, unsigned int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_dec_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_dec_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously compares vector `<src0>` and `<src1>` element-wisely. If `<src0>` is larger than `<src1>`, or the value of `<src0>` is 0, stores the int value `<src1>` in `<src0>`; otherwise, subtracts `<src0>` by 1. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` == 0 || `<src0>` > `<src1>`) ? `<src1>` : (`<src0>` - 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.7. \_\_bang\_atomic\_exch
------------------------------




void `__bang_atomic_exch`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_exch`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_exch`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_exch`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_exch`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Stores vector `<src0>` in `<dst>`. Stores `<src1>` in `<src0>`. That is: `<dst>` = `<src0>`; `<src0>` = `<src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.8. \_\_bang\_atomic\_exch\_async
-------------------------------------




void `__bang_atomic_exch_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_exch_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_exch_async`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_exch_async`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_exch_async`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Stores vector `<src0>` in `<dst>` asynchronously. Stores `<src1>` in `<src0>` asynchronously. That is: `<dst>` = `<src0>`; `<src0>` = `<src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.9. \_\_bang\_atomic\_inc
-----------------------------




void `__bang_atomic_inc`(unsigned short \**dst*, unsigned short \**src0*, unsigned short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_inc`(unsigned int \**dst*, unsigned int \**src0*, unsigned int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_inc`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_inc`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Compares vector `<src0>` and `<src1>` element-wisely. If `<src0>` is smaller than `<src1>`, increases `<src0>` by 1; otherwise, sets `<src0>` to 0. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` >= `<src1>`) ? 0 : (`<src0>` + 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.10. \_\_bang\_atomic\_inc\_async
-------------------------------------




void `__bang_atomic_inc_async`(unsigned short \**dst*, unsigned short \**src0*, unsigned short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_inc_async`(unsigned int \**dst*, unsigned int \**src0*, unsigned int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_inc_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_inc_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously compares vector `<src0>` and `<src1>` element-wisely. If `<src0>` is smaller than `<src1>`, increases `<src0>` by 1; otherwise, sets `<src0>` to 0. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` >= `<src1>`) ? 0 : (`<src0>` + 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.11. \_\_bang\_atomic\_max
------------------------------




void `__bang_atomic_max`(unsigned short \**dst*, unsigned short \**src0*, unsigned short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max`(unsigned int \**dst*, unsigned int \**src0*, unsigned int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

element-wisely stores the larger value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` > `<src1>`) ? `<src0>` : `<src1>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.12. \_\_bang\_atomic\_max\_async
-------------------------------------




void `__bang_atomic_max_async`(unsigned short \**dst*, unsigned short \**src0*, unsigned short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max_async`(unsigned int \**dst*, unsigned int \**src0*, unsigned int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max_async`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_max_async`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously and element-wisely stores the larger value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` > `<src1>`) ? `<src0>` : `<src1>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.13. \_\_bang\_atomic\_min
------------------------------




void `__bang_atomic_min`(unsigned short \**dst*, unsigned short \**src0*, unsigned short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min`(unsigned int \**dst*, unsigned int \**src0*, unsigned int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

element-wisely stores the smaller value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` < `<src1>`) ? `<src0>` : `<src1>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.14. \_\_bang\_atomic\_min\_async
-------------------------------------




void `__bang_atomic_min_async`(unsigned short \**dst*, unsigned short \**src0*, unsigned short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min_async`(unsigned int \**dst*, unsigned int \**src0*, unsigned int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min_async`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_min_async`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously and element-wisely stores the smaller value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` < `<src1>`) ? `<src0>` : `<src1>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.15. \_\_bang\_atomic\_nan\_max
-----------------------------------




void `__bang_atomic_nan_max`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_nan_max`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_nan_max`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

element-wisely stores the larger value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` > `<src1>`) ? `<src0>` : `<src1>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.16. \_\_bang\_atomic\_nan\_max\_async
------------------------------------------




void `__bang_atomic_nan_max_async`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_nan_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_nan_max_async`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously and element-wisely stores the larger value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` > `<src1>`) ? `<src0>` : `<src1>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.17. \_\_bang\_atomic\_nan\_min
-----------------------------------




void `__bang_atomic_nan_min`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_nan_min`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_nan_min`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

element-wisely stores the smaller value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` < `<src1>`) ? `<src0>` : `<src1>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.18. \_\_bang\_atomic\_nan\_min\_async
------------------------------------------




void `__bang_atomic_nan_min_async`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_nan_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_nan_min_async`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously and element-wisely stores the smaller value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` < `<src1>`) ? `<src0>` : `<src1>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.19. \_\_bang\_atomic\_number\_max
--------------------------------------




void `__bang_atomic_number_max`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_number_max`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_number_max`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

element-wisely stores the larger value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` > `<src1>`) ? `<src0>` : `<src1>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.20. \_\_bang\_atomic\_number\_max\_async
---------------------------------------------




void `__bang_atomic_number_max_async`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_number_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_number_max_async`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously and element-wisely stores the larger value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` > `<src1>`) ? `<src0>` : `<src1>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.21. \_\_bang\_atomic\_number\_min
--------------------------------------




void `__bang_atomic_number_min`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_number_min`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_number_min`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

element-wisely stores the smaller value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` < `<src1>`) ? `<src0>` : `<src1>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.22. \_\_bang\_atomic\_number\_min\_async
---------------------------------------------




void `__bang_atomic_number_min_async`(half \**dst*, half \**src0*, half \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_number_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src0*, bfloat16\_t \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_number_min_async`(float \**dst*, float \**src0*, float \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously and element-wisely stores the smaller value of vector `<src0>` and `<src1>` in `<src0>`. Stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = (`<src0>` < `<src1>`) ? `<src0>` : `<src1>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.23. \_\_bang\_atomic\_or
-----------------------------




void `__bang_atomic_or`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_or`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Applies bitwise OR operation to the vector `<src0>` and `<src1>`, stores the result in `<src0>`, and stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = `<src0>` | `<src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.24. \_\_bang\_atomic\_or\_async
------------------------------------




void `__bang_atomic_or_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_or_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously applies bitwise OR operation to the vector `<src0>` and `<src1>`, stores the result in `<src0>`, and stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = `<src0>` | `<src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.25. \_\_bang\_atomic\_xor
------------------------------




void `__bang_atomic_xor`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_xor`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Applies bitwise XOR operation to the vector `<src0>` and `<src1>`, stores the result in `<src0>`, and stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = `<src0>` ^ `<src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.5.26. \_\_bang\_atomic\_xor\_async
-------------------------------------




void `__bang_atomic_xor_async`(short \**dst*, short \**src0*, short \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  




void `__bang_atomic_xor_async`(int \**dst*, int \**src0*, int \**src1*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src0\_stride0*, unsigned int *src0\_stride1*, unsigned int *src1\_stride0*, unsigned int *src1\_stride1*)  

Asynchronously applies bitwise XOR operation to the vector `<src0>` and `<src1>`, stores the result in `<src0>`, and stores the original value of `<src0>` in `<dst>`. That is: `<dst>` = `<src0>`; `<src0>` = `<src0>` ^ `<src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] size`: The first dimension iteration count.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src0\_stride0`: The first dimension stride(bytes) of `<src0>`.
* `[in] src0\_stride1`: The second dimension stride(bytes) of `<src0>`.
* `[in] src1\_stride0`: The first dimension stride(bytes) of `<src1>`.
* `[in] src1\_stride1`: The second dimension stride(bytes) of `<src1>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src1>`;
* The address of `<src0>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src0>` must point to `\_\_mlu\_device\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src0\_stride0>` and `<dst\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<src0\_stride1>` must be greater than or equal to `<src0\_stride0> \* (<segnum1> + 1)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0> \* (<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.

















3.6. 3D Atomic Reduce Functions
================================



3.6.1. \_\_bang\_atomic\_nan\_reduce\_max
------------------------------------------




void `__bang_atomic_nan_reduce_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_nan_reduce_max`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_nan_reduce_max`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

element-wisely stores the larger value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` > `<src>`) ? `<dst>` : `<src>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.2. \_\_bang\_atomic\_nan\_reduce\_max\_async
-------------------------------------------------




void `__bang_atomic_nan_reduce_max_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_nan_reduce_max_async`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_nan_reduce_max_async`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously element-wisely stores the larger value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` > `<src>`) ? `<dst>` : `<src>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.3. \_\_bang\_atomic\_nan\_reduce\_min
------------------------------------------




void `__bang_atomic_nan_reduce_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_nan_reduce_min`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_nan_reduce_min`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

element-wisely stores the smaller value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` < `<src>`) ? `<dst>` : `<src>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.4. \_\_bang\_atomic\_nan\_reduce\_min\_async
-------------------------------------------------




void `__bang_atomic_nan_reduce_min_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_nan_reduce_min_async`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_nan_reduce_min_async`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously element-wisely stores the smaller value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` < `<src>`) ? `<dst>` : `<src>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.5. \_\_bang\_atomic\_number\_reduce\_max
---------------------------------------------




void `__bang_atomic_number_reduce_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_number_reduce_max`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_number_reduce_max`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

element-wisely stores the larger value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` > `<src>`) ? `<dst>` : `<src>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.6. \_\_bang\_atomic\_number\_reduce\_max\_async
----------------------------------------------------




void `__bang_atomic_number_reduce_max_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_number_reduce_max_async`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_number_reduce_max_async`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously element-wisely stores the larger value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` > `<src>`) ? `<dst>` : `<src>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.7. \_\_bang\_atomic\_number\_reduce\_min
---------------------------------------------




void `__bang_atomic_number_reduce_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_number_reduce_min`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_number_reduce_min`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

element-wisely stores the smaller value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` < `<src>`) ? `<dst>` : `<src>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.8. \_\_bang\_atomic\_number\_reduce\_min\_async
----------------------------------------------------




void `__bang_atomic_number_reduce_min_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_number_reduce_min_async`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_number_reduce_min_async`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously element-wisely stores the smaller value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` < `<src>`) ? `<dst>` : `<src>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.9. \_\_bang\_atomic\_reduce\_add
-------------------------------------




void `__bang_atomic_reduce_add`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_add`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_add`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_add`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Adds `<src>` to `<dst>` element-wisely. That is: `<dst>` = `<dst>` + `<src>`. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel() {
  \_\_mlu\_device\_\_ short dst[128];
  \_\_nram\_\_ short src[128];
  \_\_bang\_atomic\_reduce\_add(dst, src, 16, 0, 0, 16, 16, 16, 16);
}

```













3.6.10. \_\_bang\_atomic\_reduce\_add\_async
---------------------------------------------




void `__bang_atomic_reduce_add_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_add_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_add_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_add_async`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_add_async`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously adds `<src>` to `<dst>` element-wisely. That is: `<dst>` = `<dst>` + `<src>`. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel() {
  \_\_mlu\_device\_\_ short dst[128];
  \_\_nram\_\_ short src[128];
  \_\_bang\_atomic\_reduce\_add\_async(dst, src, 16, 0, 0, 16, 16, 16, 16);
}

```













3.6.11. \_\_bang\_atomic\_reduce\_and
--------------------------------------




void `__bang_atomic_reduce_and`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_and`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Applies bitwise AND operation to the vector `<dst>` and `<src>`, stores the result in `<dst>`. That is: `<dst>` = `<dst>` & `<src>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.12. \_\_bang\_atomic\_reduce\_and\_async
---------------------------------------------




void `__bang_atomic_reduce_and_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_and_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously applies bitwise AND operation to the vector `<dst>` and `<src>`, stores the result in `<dst>`. That is: `<dst>` = `<dst>` & `<src>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.13. \_\_bang\_atomic\_reduce\_dec
--------------------------------------




void `__bang_atomic_reduce_dec`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_dec`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_dec`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_dec`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Compares vector `<dst>` and `<src>` element-wisely. If `<dst>` is larger than `<src>`, or the value of `<dst>` is 0, stores the int value `<src>` in `<dst>`; otherwise, subtracts `<dst>` by 1. That is: `<dst>` = (`<dst>` == 0 || `<dst>` > `<src>`) ? `<src>` : (`<dst>` - 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.14. \_\_bang\_atomic\_reduce\_dec\_async
---------------------------------------------




void `__bang_atomic_reduce_dec_async`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_dec_async`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_dec_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_dec_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously compares vector `<dst>` and `<src>` element-wisely. If `<dst>` is larger than `<src>`, or the value of `<dst>` is 0, stores the int value `<src>` in `<dst>`; otherwise, subtracts `<dst>` by 1. That is: `<dst>` = (`<dst>` == 0 || `<dst>` > `<src>`) ? `<src>` : (`<dst>` - 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.15. \_\_bang\_atomic\_reduce\_exch
---------------------------------------




void `__bang_atomic_reduce_exch`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_exch`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_exch`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_exch`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_exch`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Stores `<src>` in `<dst>`. That is: `<dst>` = `<src>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.16. \_\_bang\_atomic\_reduce\_exch\_async
----------------------------------------------




void `__bang_atomic_reduce_exch_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_exch_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_exch_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_exch_async`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_exch_async`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously stores `<src>` in `<dst>`. That is: `<dst>` = `<src>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.17. \_\_bang\_atomic\_reduce\_inc
--------------------------------------




void `__bang_atomic_reduce_inc`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_inc`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_inc`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_inc`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Compares vector `<dst>` and `<src>` element-wisely. If `<dst>` is smaller than `<src>`, increases `<dst>` by 1; otherwise, sets `<dst>` to 0. That is: `<dst>` = (`<dst>` >= `<src>`) ? 0 : (`<dst>` + 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.18. \_\_bang\_atomic\_reduce\_inc\_async
---------------------------------------------




void `__bang_atomic_reduce_inc_async`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_inc_async`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_inc_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_inc_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously compares vector `<dst>` and `<src>` element-wisely. If `<dst>` is smaller than `<src>`, increases `<dst>` by 1; otherwise, sets `<dst>` to 0. That is: `<dst>` = (`<dst>` >= `<src>`) ? 0 : (`<dst>` + 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.19. \_\_bang\_atomic\_reduce\_max
--------------------------------------




void `__bang_atomic_reduce_max`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

element-wisely stores the larger value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` > `<src>`) ? `<dst>` : `<src>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.20. \_\_bang\_atomic\_reduce\_max\_async
---------------------------------------------




void `__bang_atomic_reduce_max_async`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max_async`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max_async`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_max_async`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously element-wisely stores the larger value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` > `<src>`) ? `<dst>` : `<src>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.21. \_\_bang\_atomic\_reduce\_min
--------------------------------------




void `__bang_atomic_reduce_min`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

element-wisely stores the smaller value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` < `<src>`) ? `<dst>` : `<src>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.22. \_\_bang\_atomic\_reduce\_min\_async
---------------------------------------------




void `__bang_atomic_reduce_min_async`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min_async`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min_async`(half \**dst*, *const* half \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_min_async`(float \**dst*, *const* float \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously element-wisely stores the smaller value of vector `<dst>` and `<src>` in `<dst>`. That is: `<dst>` = (`<dst>` < `<src>`) ? `<dst>` : `<src>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of second source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.23. \_\_bang\_atomic\_reduce\_or
-------------------------------------




void `__bang_atomic_reduce_or`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_or`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Applies bitwise OR operation to the vector `<dst>` and `<src>`, stores the result in `<dst>`. That is: `<dst>` = `<dst>` | `<src>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.24. \_\_bang\_atomic\_reduce\_or\_async
--------------------------------------------




void `__bang_atomic_reduce_or_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_or_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously applies bitwise OR operation to the vector `<dst>` and `<src>`, stores the result in `<dst>`. That is: `<dst>` = `<dst>` | `<src>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.25. \_\_bang\_atomic\_reduce\_xor
--------------------------------------




void `__bang_atomic_reduce_xor`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_xor`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Applies bitwise XOR operation to the vector `<dst>` and `<src>`, stores the result in `<dst>`. That is: `<dst>` = `<dst>` ^ `<src>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.













3.6.26. \_\_bang\_atomic\_reduce\_xor\_async
---------------------------------------------




void `__bang_atomic_reduce_xor_async`(short \**dst*, *const* short \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  




void `__bang_atomic_reduce_xor_async`(int \**dst*, *const* int \**src*, unsigned int *size*, unsigned int *segnum1*, unsigned int *segnum2*, unsigned int *dst\_stride0*, unsigned int *dst\_stride1*, unsigned int *src\_stride0*, unsigned int *src\_stride1*)  

Asynchronously applies bitwise XOR operation to the vector `<dst>` and `<src>`, stores the result in `<dst>`. That is: `<dst>` = `<dst>` ^ `<src>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The number of elements in the first dimension of the source vector.
* `[in] segnum1`: The second dimension iteration count minus 1.
* `[in] segnum2`: The third dimension iteration count minus 1.
* `[in] dst\_stride0`: The first dimension stride(bytes) of `<dst>`.
* `[in] dst\_stride1`: The second dimension stride(bytes) of `<dst>`.
* `[in] src\_stride0`: The first dimension stride(bytes) of `<src>`.
* `[in] src\_stride1`: The second dimension stride(bytes) of `<src>`.



**Return*** `void`.






**Remark*** The address of `<dst>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<src>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<src\_stride0>` must be greater than or equal to `<size> \* sizeof(type)`;
* `<dst\_stride1>` must be greater than or equal to `<dst\_stride0>` \* `(<segnum1> + 1)`;
* `<src\_stride1>` must be greater than or equal to `<src\_stride0>` \* `(<segnum1> + 1)`.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 500` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_5xx` except `tp\_520`.






**Example*** None.

















3.7. 3D Memcpy Functions
=========================



3.7.1. \_\_bang\_move
----------------------




void `__bang_move`(void \**dst*, *const* void \**src*, unsigned int *size*, unsigned int *dst\_stride0*, unsigned int *dst\_segnum1*, unsigned int *dst\_stride1*, unsigned int *dst\_segnum2*, unsigned int *src\_stride0*, unsigned int *src\_segnum1*, unsigned int *src\_stride1*, unsigned int *src\_segnum2*)  

Copies data from `<src>` to `<dst>` in 3 dimensions.


As shown in Figure 3D Memory Copy Function with Stride , the cells with blue background indicate `<size>` of data to be copied in each segment. In this case, there are 3 segments in the first dimension. In each segment, `<src\_stride0>` of data are copied to destination area `<src\_segnum1>` times. There are 2 segments in the second dimension. In each segment, `<src\_stride1>` of data are copied to destination area `<src\_segnum2>` times. Then, copy the data into corresponding segments and dimensions of `<dst>`. Please note that `<src\_segnum1>`, `<dst\_segnum1>`, `<src\_segnum2>` and `<dst\_segnum2>` are the real segment number minus one.









**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes of one segment.
* `[in] dst\_stride0`: The destination address stride(bytes) in the first dimension.
* `[in] dst\_segnum1`: The destination segment number in the first dimension.
* `[in] dst\_stride1`: The destination address stride(bytes) in the second dimension.
* `[in] dst\_segnum2`: The destination segment number in the second dimension.
* `[in] src\_stride0`: The source address stride(bytes) in the first dimension.
* `[in] src\_segnum1`: The source segment number in the first dimension.
* `[in] src\_stride1`: The source address stride(bytes) in the second dimension.
* `[in] src\_segnum2`: The source segment number in the second dimension.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<dst\_stride0>` and `<dst\_stride1>` must be greater than or equal to `<size>`;
* `<src\_stride0>` and `<src\_stride1>` must be greater than or equal to 0;
* The total number of iterations at the source must be equal to the total number of iterations at the destination, i.e., (`<dst\_segnum1>` + 1) \* (`<dst\_segnum2>` + 1) = (`<src\_segnum1>` + 1) \* (`<src\_segnum2>` + 1);
* When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372`.






**Example**
```
#include <bang.h>

#define LEN 7
#define IN\_STRIDE\_0 11
#define IN\_STRIDE\_1 103
#define IN\_SEGNUM\_1 7
#define IN\_SEGNUM\_2 2
#define OUT\_STRIDE\_0 9
#define OUT\_STRIDE\_1 67
#define OUT\_SEGNUM\_1 5
#define OUT\_SEGNUM\_2 3
#define SIZE (LEN \* (IN\_SEGNUM\_1 + 1) \* (IN\_SEGNUM\_2 + 1))
#define SIZE\_IN (IN\_STRIDE\_1 \* (IN\_SEGNUM\_2 + 1))
#define SIZE\_OUT (OUT\_STRIDE\_1 \* (OUT\_SEGNUM\_2 + 1))

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src1\_nram[512];
  \_\_nram\_\_ int8\_t src2\_nram[512];
  \_\_memcpy(src1\_nram, src, 512, GDRAM2NRAM);
  \_\_bang\_move(src2\_nram, src1\_nram, LEN, OUT\_STRIDE\_0, OUT\_SEGNUM\_1,
              OUT\_STRIDE\_1, OUT\_SEGNUM\_2, IN\_STRIDE\_0, IN\_SEGNUM\_1,
              IN\_STRIDE\_1, IN\_SEGNUM\_2);
  \_\_memcpy(dst, src2\_nram, 512, NRAM2GDRAM);
}

```













3.7.2. \_\_memcpy
------------------




void `__memcpy`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*, int *dst\_stride0*, unsigned int *dst\_segnum1*, int *dst\_stride1*, unsigned int *dst\_segnum2*, int *src\_stride0*, unsigned int *src\_segnum1*, int *src\_stride1*, unsigned int *src\_segnum2*, unsigned int *id\_dst\_cluster*)  




void `__memcpy`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*, int *dst\_stride0*, unsigned int *dst\_segnum1*, int *dst\_stride1*, unsigned int *dst\_segnum2*, int *src\_stride0*, unsigned int *src\_segnum1*, int *src\_stride1*, unsigned int *src\_segnum2*)  

Copies data from the `<src>` address space to the `<dst>` address space in three dimensions.


As shown in Figure 3D Memory Copy Function with Stride , the cells with blue background indicate `<size>` of data to be copied in each segment. In this case, there are 3 segments in the first dimension. `<src\_stride0>` of data in each segment are copied to destination area `<src\_segnum1> +1` times. There are 2 segments in the second dimension. `<src\_stride1>` of data in each segment are copied to destination area `<src\_segnum2> +1` times. Then, copy the data into corresponding segments and dimensions of `<dst>`.



![../_images/3d_memcpy_stride.png](../_images/3d_memcpy_stride.png)

Fig. 3.3 3D Memory Copy Function with Stride












**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes of one segment.
* `[in] dir`: Copy direction.
* `[in] dst\_stride0`: The destination stride(bytes) in the first dimension.
* `[in] dst\_segnum1`: The destination segment number minus one in the first dimension.
* `[in] dst\_stride1`: The destination stride(bytes) in the second dimension.
* `[in] dst\_segnum2`: The destination segment number minus one in the second dimension.
* `[in] src\_stride0`: The source stride(bytes) in the first dimension.
* `[in] src\_segnum1`: The source segment number minus one in the first dimension.
* `[in] src\_stride1`: The source stride(bytes) in the second dimension.
* `[in] src\_segnum2`: The source segment number minus one in the second dimension.
* `[in] id\_dst\_cluster`: Destination cluster ID.



**Return*** `void`.






**Remark*** When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;
* The total number of iterations at the source must be equal to the total number of iterations at the destination. That is, the segment numbers need to satisfy: (`<dst\_segnum1>` + 1) \* (`<dst\_segnum2>` + 1) = (`<src\_segnum1>` + 1) \* (`<src\_segnum2>` + 1);
* The `<size>` must be greater than zero, and the absolute value of `<dst\_stride0>` must be greater than or equal to `<size>` unless the value of `<dst\_stride0>` and `<dst\_segnum1>` are equal to zero. The absolute value of `<dst\_stride1>` must be greater than or equal to `<size>` unless the value of `<dst\_stride1>` and `<dst\_segnum2>` are equal to zero;
* `<id\_dst\_cluster>` is necessarily used when `<dir>` is SRAM2SRAM and data is copied across different clusters on `mtp\_2xx` and `mtp\_3xx`;
* When `<dir>` is SRAM2SRAM, copy data across different clusters is not supported on `(m)tp\_5xx` or higher;
* When `<dir>` is SRAM2SRAM, and there is no `<id\_dst\_cluster>`, it means copy data within cluster;
* This function supports transferring data within NRAM, WRAM, SRAM, LDRAM and GDRAM except for WRAM2WRAM;
* When `<dst>` address space is WRAM, `<dst\_stride0>` and `<dst\_stride1>` must be divisible by 8;
* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on `tp\_322` and `(m)tp\_372`, and is 0 on other targets;
* When `<dir>` is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM, LDRAM2SRAM, SRAM2NRAM, NRAM2SRAM, SRAM2WRAM or WRAM2SRAM, it is not supported on `tp\_322` and `tp\_520`.






**Instruction Pipeline*** If either `<src>` or `<dst>` is `off-chip address`, execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;
* If `<dir>` is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example**
```
#include <bang.h>

#define LEN 7
#define IN\_STRIDE\_0 11
#define IN\_STRIDE\_1 103
#define IN\_SEGNUM\_1 7
#define IN\_SEGNUM\_2 2
#define OUT\_STRIDE\_0 9
#define OUT\_STRIDE\_1 67
#define OUT\_SEGNUM\_1 5
#define OUT\_SEGNUM\_2 3
#define SIZE (LEN \* (IN\_SEGNUM\_1 + 1) \* (IN\_SEGNUM\_2 + 1))
#define SIZE\_IN (IN\_STRIDE\_1 \* (IN\_SEGNUM\_2 + 1))
#define SIZE\_OUT (OUT\_STRIDE\_1 \* (OUT\_SEGNUM\_2 + 1))

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, unsigned char \*src) {
  \_\_memcpy(dst, src, LEN, GDRAM2GDRAM, OUT\_STRIDE\_0, OUT\_SEGNUM\_1,
           OUT\_STRIDE\_1, OUT\_SEGNUM\_2, IN\_STRIDE\_0, IN\_SEGNUM\_1,
           IN\_STRIDE\_1, IN\_SEGNUM\_2);
}

```













3.7.3. \_\_memcpy\_async
-------------------------




void `__memcpy_async`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*, int *dst\_stride0*, unsigned int *dst\_segnum1*, int *dst\_stride1*, unsigned int *dst\_segnum2*, int *src\_stride0*, unsigned int *src\_segnum1*, int *src\_stride1*, unsigned int *src\_segnum2*, unsigned int *id\_dst\_cluster*)  




void `__memcpy_async`(void \**dst*, *const* void \**src*, unsigned int *size*, mluMemcpyDirection\_t *dir*, int *dst\_stride0*, unsigned int *dst\_segnum1*, int *dst\_stride1*, unsigned int *dst\_segnum2*, int *src\_stride0*, unsigned int *src\_segnum1*, int *src\_stride1*, unsigned int *src\_segnum2*)  

Copies data from the `<src>` address space to the `<dst>` address space in three dimensions asynchronously. Data operation in the source space is: take the `<size>` of the data, operate the `<src\_segnum1>` times through the `<src\_stride0>`, and then take the `<src\_stride1>` size to iterate the number of `<src\_segnum2>`. Data operation in the destination space is: take the `<size>` of the data, operate the `<dst\_segnum1>` times through the `<dst\_stride0>`, and then take the `<dst\_stride1>` size to iterate the number of `<dst\_segnum2>`.



**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes of one segment.
* `[in] dir`: Copy direction.
* `[in] dst\_stride0`: The destination stride(bytes) in the first dimension.
* `[in] dst\_segnum1`: The destination segment number minus one in the first dimension.
* `[in] dst\_stride1`: The destination stride(bytes) in the second dimension.
* `[in] dst\_segnum2`: The destination segment number minus one in the second dimension.
* `[in] src\_stride0`: The source stride(bytes) in the first dimension.
* `[in] src\_segnum1`: The source segment number minus one in the first dimension.
* `[in] src\_stride1`: The source stride(bytes) in the second dimension.
* `[in] src\_segnum2`: The source segment number minus one in the second dimension.
* `[in] id\_dst\_cluster`: Destination cluster ID.



**Return*** `void`.






**Remark*** When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;
* The total number of iterations at the source must be equal to the total number of iterations at the destination. That is, the segment numbers need to satisfy: (`<dst\_segnum1>` + 1) \* (`<dst\_segnum2>` + 1) = (`<src\_segnum1>` + 1) \* (`<src\_segnum2>` + 1);
* The `<size>` must be greater than zero, and the absolute value of `<dst\_stride0>` must be greater than or equal to `<size>` unless the value of `<dst\_stride0>` and `<dst\_segnum1>` are equal to zero. The absolute value of `<dst\_stride1>` must be greater than or equal to `<size>` unless the value of `<dst\_stride1>` and `<dst\_segnum2>` are equal to zero;
* `<id\_dst\_cluster>` is necessarily used when `<dir>` is SRAM2SRAM and data is copied across different clusters on `mtp\_2xx`, `mtp\_3xx`;
* When `<dir>` is SRAM2SRAM, copy data across different clusters is not supported on `(m)tp\_5xx` or higher;
* When `<dir>` is SRAM2SRAM, and there is no `<id\_dst\_cluster>`, it means copy data within cluster;
* This function supports transferring data within NRAM, WRAM, SRAM, LDRAM and GDRAM except for WRAM2WRAM;
* When `<dst>` address space is WRAM, `<dst\_stride0>` and `<dst\_stride1>` must be divisible by 8;
* If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on `tp\_322` and `(m)tp\_372`, and is 0 on other targets.
* `\_\_memcpy\_async` with `<id\_dst\_cluster>` is not supported on `(m)tp\_5xx` or higher;
* When `<dir>` is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM, LDRAM2SRAM, SRAM2NRAM, NRAM2SRAM, SRAM2WRAM or WRAM2SRAM, it is not supported on `tp\_322` and `tp\_520`.






**Instruction Pipeline*** If either `<src>` or `<dst>` is `off-chip address`, execute in IO instruction pipeline, otherwise, execute in Move instruction pipeline;
* If `<dir>` is SRAM2SRAM, SRAM2GDRAM, GDRAM2SRAM, SRAM2LDRAM or LDRAM2SRAM, execute on MPU core, otherwise, execute on MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.2.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example**
```
#include <bang.h>

#define LEN 7
#define IN\_STRIDE\_0 11
#define IN\_STRIDE\_1 103
#define IN\_SEGNUM\_1 7
#define IN\_SEGNUM\_2 2
#define OUT\_STRIDE\_0 9
#define OUT\_STRIDE\_1 67
#define OUT\_SEGNUM\_1 5
#define OUT\_SEGNUM\_2 3
#define SIZE (LEN \* (IN\_SEGNUM\_1 + 1) \* (IN\_SEGNUM\_2 + 1))
#define SIZE\_IN (IN\_STRIDE\_1 \* (IN\_SEGNUM\_2 + 1))
#define SIZE\_OUT (OUT\_STRIDE\_1 \* (OUT\_SEGNUM\_2 + 1))

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, unsigned char \*src) {
  \_\_memcpy\_async(dst, src, LEN, GDRAM2GDRAM, OUT\_STRIDE\_0, OUT\_SEGNUM\_1,
                 OUT\_STRIDE\_1, OUT\_SEGNUM\_2, IN\_STRIDE\_0, IN\_SEGNUM\_1,
                 IN\_STRIDE\_1, IN\_SEGNUM\_2);
}

```

















3.8. 3D Memset Functions
=========================



3.8.1. \_\_bang\_write\_value
------------------------------




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__bang_write_value`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  

Sets a three-dimensional block in the `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum1> + 1` times through the `<stride0>`, and then take the `<stride1>` size to iterate the number of `<segnum2> + 1`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride0`: The destination address stride(bytes) in the first dimension.
* `[in] segnum1`: The destination segment number in the first dimension.
* `[in] stride1`: The destination address stride(bytes) in the second dimension.
* `[in] segnum2`: The destination segment number in the second dimension.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride0>` must be greater than or equal to `<elem\_count> \* sizeof(type)`, and `<stride1>` must be greater than or equal to `<stride0> \* (<segnum1> + 1)`;
* When the value of `<segnum1>` and `<segnum2>` is 0, it represents 1, and when the value is 1, it represents 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.2.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example*** None.













3.8.2. \_\_gdramset
--------------------




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__gdramset`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  

Sets the specified `<value>` to a three-dimensional block in the `\_\_mlu\_device\_\_` address space pointed by `<dst>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum1> + 1` times through the `<stride0>`, and then takes the `<stride1>` size to iterate the number of `<segnum2> + 1`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride0`: The destination address stride(bytes) in the first dimension.
* `[in] segnum1`: The destination segment number in the first dimension.
* `[in] stride1`: The destination address stride(bytes) in the second dimension.
* `[in] segnum2`: The destination segment number in the second dimension.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride0>` must be greater than or equal to `<elem\_count> \* sizeof(type)`, and `<stride1>` must be greater than or equal to `<stride0> \* (<segnum1> + 1)`;
* When `<segnum1>` and `<segnum2>` are 0, they represent 1, and when `<segnum1>` and `<segnum2>` are 1, they represent 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.8.3. \_\_ldramset
--------------------




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__ldramset`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  

Sets the specified `<value>` to a three-dimensional block in the `\_\_ldram\_\_` address space pointed by `<dst>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum1> + 1` times through the `<stride0>`, and then takes the `<stride1>` size to iterate the number of `<segnum2> + 1`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride0`: The destination address stride(bytes) in the first dimension.
* `[in] segnum1`: The destination segment number in the first dimension.
* `[in] stride1`: The destination address stride(bytes) in the second dimension.
* `[in] segnum2`: The destination segment number in the second dimension.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_ldram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride0>` must be greater than or equal to `<elem\_count> \* sizeof(type)`, and `<stride1>` must be greater than or equal to `<stride0> \* (<segnum1> + 1)`;
* When `<segnum1>` and `<segnum2>` are 0, they represent 1, and when `<segnum1>` and `<segnum2>` are 1, they represent 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.8.4. \_\_nramset
-------------------




void `__nramset`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  

Sets the specified `<value>` to a three-dimensional block in the `\_\_nram\_\_` address space pointed by `<dst>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum1> + 1` times through the `<stride0>`, and then takes the `<stride1>` size to iterate the number of `<segnum2> + 1`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride0`: The destination address stride(bytes) in the first dimension.
* `[in] segnum1`: The destination segment number in the first dimension.
* `[in] stride1`: The destination address stride(bytes) in the second dimension.
* `[in] segnum2`: The destination segment number in the second dimension.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride0>` must be greater than or equal to `<elem\_count> \* sizeof(type)`, and `<stride1>` must be greater than or equal to `<stride0> \* (<segnum1> + 1)`;
* When `<segnum1>` and `<segnum2>` are 0, they represent 1, and when `<segnum1>` and `<segnum2>` are 1, they represent 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.8.5. \_\_nramset\_async
--------------------------




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__nramset_async`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  

Sets the specified `<value>` to a three-dimensional block in the `\_\_nram\_\_` address space pointed by `<dst>` asynchronously. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum1> + 1` times through the `<stride0>`, and then takes the `<stride1>` size to iterate the number of `<segnum2> + 1`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride0`: The destination address stride(bytes) in the first dimension.
* `[in] segnum1`: The destination segment number in the first dimension.
* `[in] stride1`: The destination address stride(bytes) in the second dimension.
* `[in] segnum2`: The destination segment number in the second dimension.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride0>` must be greater than or equal to `<elem\_count> \* sizeof(type)`, and `<stride1>` must be greater than or equal to `<stride0> \* (<segnum1> + 1)`;
* When `<segnum1>` and `<segnum2>` are 0, they represent 1, and when `<segnum1>` and `<segnum2>` are 1, they represent 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.8.6. \_\_sramset
-------------------




void `__sramset`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  

Sets the specified `<value>` to a three-dimensional block in the `\_\_mlu\_shared\_\_` address space pointed by `<dst>`. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum1> + 1` times through the `<stride0>`, and then takes the `<stride1>` size to iterate the number of `<segnum2> + 1`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride0`: The destination address stride(bytes) in the first dimension.
* `[in] segnum1`: The destination segment number in the first dimension.
* `[in] stride1`: The destination address stride(bytes) in the second dimension.
* `[in] segnum2`: The destination segment number in the second dimension.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_mlu\_shared\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride0>` must be greater than or equal to `<elem\_count> \* sizeof(type)`, and `<stride1>` must be greater than or equal to `<stride0> \* (<segnum1> + 1)`;
* When `<segnum1>` and `<segnum2>` are 0, they represent 1, and when `<segnum1>` and `<segnum2>` are 1, they represent 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move instruction pipeline of MPU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.8.7. \_\_sramset\_async
--------------------------




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, char *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, half *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, bfloat16\_t *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, short *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, float *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  




void `__sramset_async`(void \**dst*, unsigned int *elem\_count*, int *value*, unsigned int *stride0*, unsigned int *segnum1*, unsigned int *stride1*, unsigned int *segnum2*)  

Sets the specified `<value>` to a three-dimensional block in the `\_\_mlu\_shared\_\_` address space pointed by `<dst>` asynchronously. The way of setting `<value>` is that takes the `<elem\_count>` of the data, operates the `<segnum1> + 1` times through the `<stride0>`, and then takes the `<stride1>` size to iterate the number of `<segnum2> + 1`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements of one segment.
* `[in] value`: The value to be set to `<dst>`.
* `[in] stride0`: The destination address stride(bytes) in the first dimension.
* `[in] segnum1`: The destination segment number in the first dimension.
* `[in] stride1`: The destination address stride(bytes) in the second dimension.
* `[in] segnum2`: The destination segment number in the second dimension.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_mlu\_shared\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<stride0>` must be greater than or equal to `<elem\_count> \* sizeof(type)`, and `<stride1>` must be greater than or equal to `<stride0> \* (<segnum1> + 1)`;
* When `<segnum1>` and `<segnum2>` are 0, they represent 1, and when `<segnum1>` and `<segnum2>` are 1, they represent 2, and so on;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move instruction pipeline of MPU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_322` and `tp\_520`.






**Example*** None.

















3.9. Address Space Predicate Functions
=======================================



3.9.1. \_\_is\_dram
--------------------




bool `__is_dram`(*const* void \**ptr*)  

Returns `true` if `<ptr>` points to `\_\_mlu\_device\_\_` or `\_\_ldram\_\_` address space.



**Parameters*** `[in] ptr`: The input pointer.



**Return*** `bool`.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.9.2. \_\_is\_nram
--------------------




bool `__is_nram`(*const* void \**ptr*)  

Returns `true` if `<ptr>` points to `\_\_nram\_\_` address space.



**Parameters*** `[in] ptr`: The input pointer.



**Return*** `bool`.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.4.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.9.3. \_\_is\_sram
--------------------




bool `__is_sram`(*const* void \**ptr*)  

Returns `true` if `<ptr>` points to `\_\_mlu\_shared\_\_` address space.



**Parameters*** `[in] ptr`: The input pointer.



**Return*** `bool`.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.4.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.9.4. \_\_is\_wram
--------------------




bool `__is_wram`(*const* void \**ptr*)  

Returns `true` if `<ptr>` points to `\_\_wram\_\_` address space.



**Parameters*** `[in] ptr`: The input pointer.



**Return*** `bool`.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.4.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.

















3.10. Address Space Specified Scalar Load Functions
====================================================



3.10.1. \_\_load\_gdram
------------------------




int32\_t `__load_gdram`(*const* int32\_t \**src*)  




int8\_t `__load_gdram`(*const* int8\_t \**src*)  




int16\_t `__load_gdram`(*const* int16\_t \**src*)  




uint32\_t `__load_gdram`(*const* uint32\_t \**src*)  




uint8\_t `__load_gdram`(*const* uint8\_t \**src*)  




uint16\_t `__load_gdram`(*const* uint16\_t \**src*)  




float `__load_gdram`(*const* float \**src*)  




half `__load_gdram`(*const* half \**src*)  




bfloat16\_t `__load_gdram`(*const* bfloat16\_t \**src*)  

This function loads data from `<src>` of GDRAM.



**Parameters*** `[in] src`: The address to load the data.



**Return*** The data in memory address `<src>`.






**Remark*** `<src>` must point to `\_\_mlu\_device\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst) {
  \_\_mlu\_device\_\_ int32\_t x = 1;
  int32\_t y  = \_\_load\_gdram(&x);
  \*dst = y;
}

```













3.10.2. \_\_load\_ldram
------------------------




int32\_t `__load_ldram`(*const* int32\_t \**src*)  




int8\_t `__load_ldram`(*const* int8\_t \**src*)  




int16\_t `__load_ldram`(*const* int16\_t \**src*)  




uint32\_t `__load_ldram`(*const* uint32\_t \**src*)  




uint8\_t `__load_ldram`(*const* uint8\_t \**src*)  




uint16\_t `__load_ldram`(*const* uint16\_t \**src*)  




float `__load_ldram`(*const* float \**src*)  




half `__load_ldram`(*const* half \**src*)  




bfloat16\_t `__load_ldram`(*const* bfloat16\_t \**src*)  

This function loads data from `<src>` of LDRAM.



**Parameters*** `[in] src`: The address to load the data.



**Return*** The data in memory address `<src>`.






**Remark*** `<src>` must point to `\_\_ldram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst) {
  \_\_ldram\_\_ int32\_t x = 1;
  int32\_t y  = \_\_load\_ldram(&x);
  \*dst = y;
}

```













3.10.3. \_\_load\_nram
-----------------------




int32\_t `__load_nram`(*const* int32\_t \**src*)  




int8\_t `__load_nram`(*const* int8\_t \**src*)  




int16\_t `__load_nram`(*const* int16\_t \**src*)  




uint32\_t `__load_nram`(*const* uint32\_t \**src*)  




uint8\_t `__load_nram`(*const* uint8\_t \**src*)  




uint16\_t `__load_nram`(*const* uint16\_t \**src*)  




float `__load_nram`(*const* float \**src*)  




half `__load_nram`(*const* half \**src*)  




bfloat16\_t `__load_nram`(*const* bfloat16\_t \**src*)  

This function loads data from `<src>` of NRAM.



**Parameters*** `[in] src`: The address to load the data.



**Return*** The data in memory address `<src>`.






**Remark*** `<src>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst) {
  \_\_nram\_\_ int32\_t x = 1;
  int32\_t y  = \_\_load\_nram(&x);
  \*dst = y;
}

```













3.10.4. \_\_load\_sram
-----------------------




int32\_t `__load_sram`(*const* int32\_t \**src*)  




int8\_t `__load_sram`(*const* int8\_t \**src*)  




int16\_t `__load_sram`(*const* int16\_t \**src*)  




uint32\_t `__load_sram`(*const* uint32\_t \**src*)  




uint8\_t `__load_sram`(*const* uint8\_t \**src*)  




uint16\_t `__load_sram`(*const* uint16\_t \**src*)  




float `__load_sram`(*const* float \**src*)  




half `__load_sram`(*const* half \**src*)  




bfloat16\_t `__load_sram`(*const* bfloat16\_t \**src*)  

This function loads data from `<src>` of SRAM.



**Parameters*** `[in] src`: The address to load the data.



**Return*** The data in memory address `<src>`.






**Remark*** `<src>` must point to `\_\_mlu\_shared\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst) {
  \_\_mlu\_shared\_\_ int32\_t x = 1;
  int32\_t y  = \_\_load\_sram(&x);
  \*dst = y;
}

```

















3.11. Address Space Specified Scalar Store Functions
=====================================================



3.11.1. \_\_store\_gdram
-------------------------




void `__store_gdram`(int32\_t \**dst*, int32\_t *value*)  




void `__store_gdram`(int8\_t \**dst*, int8\_t *value*)  




void `__store_gdram`(int16\_t \**dst*, int16\_t *value*)  




void `__store_gdram`(uint32\_t \**dst*, uint32\_t *value*)  




void `__store_gdram`(uint8\_t \**dst*, uint8\_t *value*)  




void `__store_gdram`(uint16\_t \**dst*, uint16\_t *value*)  




void `__store_gdram`(float \**dst*, float *value*)  




void `__store_gdram`(half \**dst*, half *value*)  




void `__store_gdram`(bfloat16\_t \**dst*, bfloat16\_t *value*)  

Stores `<value>` into `<dst>` of GDRAM.



**Parameters*** `[out] dst`: The address to store the data.
* `[in] value`: The source value to be stored.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst) {
  \_\_mlu\_device\_\_ int32\_t x;
  int32\_t y = \*dst;
  \_\_store\_gdram(&x, y);
}

```













3.11.2. \_\_store\_ldram
-------------------------




void `__store_ldram`(int32\_t \**dst*, int32\_t *value*)  




void `__store_ldram`(int8\_t \**dst*, int8\_t *value*)  




void `__store_ldram`(int16\_t \**dst*, int16\_t *value*)  




void `__store_ldram`(uint32\_t \**dst*, uint32\_t *value*)  




void `__store_ldram`(uint8\_t \**dst*, uint8\_t *value*)  




void `__store_ldram`(uint16\_t \**dst*, uint16\_t *value*)  




void `__store_ldram`(float \**dst*, float *value*)  




void `__store_ldram`(half \**dst*, half *value*)  




void `__store_ldram`(bfloat16\_t \**dst*, bfloat16\_t *value*)  

Stores `<value>` into `<dst>` of LDRAM.



**Parameters*** `[out] dst`: The address to store the data.
* `[in] value`: The source value to be stored.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_ldram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst) {
  \_\_ldram\_\_ int32\_t x;
  int32\_t y = \*dst;
  \_\_store\_ldram(&x, y);
}

```













3.11.3. \_\_store\_nram
------------------------




void `__store_nram`(int32\_t \**dst*, int32\_t *value*)  




void `__store_nram`(int8\_t \**dst*, int8\_t *value*)  




void `__store_nram`(int16\_t \**dst*, int16\_t *value*)  




void `__store_nram`(uint32\_t \**dst*, uint32\_t *value*)  




void `__store_nram`(uint8\_t \**dst*, uint8\_t *value*)  




void `__store_nram`(uint16\_t \**dst*, uint16\_t *value*)  




void `__store_nram`(float \**dst*, float *value*)  




void `__store_nram`(half \**dst*, half *value*)  




void `__store_nram`(bfloat16\_t \**dst*, bfloat16\_t *value*)  

Stores `<value>` into `<dst>` of NRAM.



**Parameters*** `[out] dst`: The address to store the data.
* `[in] value`: The source value to be stored.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst) {
  \_\_nram\_\_ int32\_t x;
  int32\_t y = \*dst;
  \_\_store\_nram(&x, y);
}

```













3.11.4. \_\_store\_sram
------------------------




void `__store_sram`(int32\_t \**dst*, int32\_t *value*)  




void `__store_sram`(int8\_t \**dst*, int8\_t *value*)  




void `__store_sram`(int16\_t \**dst*, int16\_t *value*)  




void `__store_sram`(uint32\_t \**dst*, uint32\_t *value*)  




void `__store_sram`(uint8\_t \**dst*, uint8\_t *value*)  




void `__store_sram`(uint16\_t \**dst*, uint16\_t *value*)  




void `__store_sram`(float \**dst*, float *value*)  




void `__store_sram`(half \**dst*, half *value*)  




void `__store_sram`(bfloat16\_t \**dst*, bfloat16\_t *value*)  

Stores `<value>` into `<dst>` of SRAM.



**Parameters*** `[out] dst`: The address to store the data.
* `[in] value`: The source value to be stored.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_mlu\_shared\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Move.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst) {
  \_\_mlu\_shared\_\_ int32\_t x;
  int32\_t y = \*dst;
  \_\_store\_sram(&x, y);
}

```

















3.12. Artificial Intelligence Functions
========================================



3.12.1. \_\_bang\_bexpand
--------------------------




void `__bang_bexpand`(char \**dst*, *const* void \**src*, unsigned int *dst\_dim\_n*, unsigned int *dst\_dim\_h*, unsigned int *dst\_dim\_w*, unsigned int *dst\_dim\_c*)  




void `__bang_bexpand`(short \**dst*, *const* void \**src*, unsigned int *dst\_dim\_n*, unsigned int *dst\_dim\_h*, unsigned int *dst\_dim\_w*, unsigned int *dst\_dim\_c*)  




void `__bang_bexpand`(int \**dst*, *const* void \**src*, unsigned int *dst\_dim\_n*, unsigned int *dst\_dim\_h*, unsigned int *dst\_dim\_w*, unsigned int *dst\_dim\_c*)  

This function converts each binary bit in `<src>` to value of specified data type and saves the result in `<dst>` . The bit `1` and `0` will be converted to value `1` and `0` of corresponding data type. For example, if the data type of `<dst>` is `char` and `<src>` is `0b11001101` , the `<dst>` will be `0b 00000001 00000001 00000000 00000000 00000001 00000001 00000000 00000001` .



**Parameters*** `[out] dst`: The address of destination tensor.
* `[in] src`: The address of source binary vector.
* `[in] dst\_dim\_n`: The dimension N of destination tensor.
* `[in] dst\_dim\_h`: The dimension H of destination tensor.
* `[in] dst\_dim\_w`: The dimension W of destination tensor.
* `[in] dst\_dim\_c`: The dimension C of destination tensor.



**Return*** `void`. \*






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<dst\_dim\_c>` must be divisible by 8;
* `<dst\_dim\_n>`, `<dst\_dim\_h>`, `<dst\_dim\_w>` and `<dst\_dim\_c>` must be greater than 0 and less than 65536.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592` .






**Example**
```
#include "bang.h"
#define N 1
#define H 2
#define W 8
#define C 32
#define DST\_NUM (N \* H \* W \* C)
#define SRC\_NUM (DST\_NUM / 8)
\_\_mlu\_entry\_\_ void kernel(int\* dst, unsigned char\* src) {
  \_\_nram\_\_ unsigned char src\_tmp[SRC\_NUM];
  \_\_nram\_\_ int dst\_tmp[DST\_NUM];
  \_\_memcpy(src\_tmp, src, SRC\_NUM \* sizeof(unsigned char), GDRAM2NRAM);
  \_\_bang\_bexpand(dst\_tmp, src\_tmp, N, H, W, C);
  \_\_memcpy(dst, dst\_tmp, DST\_NUM \* sizeof(int), NRAM2GDRAM);
}

```













3.12.2. \_\_bang\_breduce
--------------------------




void `__bang_breduce`(void \**dst*, *const* char \**src*, unsigned int *src\_dim\_n*, unsigned int *src\_dim\_h*, unsigned int *src\_dim\_w*, unsigned int *src\_dim\_c*)  




void `__bang_breduce`(void \**dst*, *const* short \**src*, unsigned int *src\_dim\_n*, unsigned int *src\_dim\_h*, unsigned int *src\_dim\_w*, unsigned int *src\_dim\_c*)  




void `__bang_breduce`(char \**dst*, *const* int \**src*, unsigned int *src\_dim\_n*, unsigned int *src\_dim\_h*, unsigned int *src\_dim\_w*, unsigned int *src\_dim\_c*)  

This function converts each value in `<src>` to binary bit and saves the result in `<dst>` . Value `0` will be converted to bit `0` and other value will be converted to bit 1. For example, if the data type of `<src>` is `char` and `<src>` is `0b 00000001 10000001 00000000 00000000 11111111 01000000 00000000 11000000` , the `<dst>` will be `0b11001101` .



**Parameters*** `[out] dst`: The address of destination binary vector.
* `[in] src`: The address of source tensor.
* `[in] src\_dim\_n`: The dimension N of source tensor.
* `[in] src\_dim\_h`: The dimension H of source tensor.
* `[in] src\_dim\_w`: The dimension W of source tensor.
* `[in] src\_dim\_c`: The dimension C of source tensor.



**Return*** `void`. \*






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<src\_dim\_c>` must be divisible by 8;
* `<src\_dim\_n>`, `<src\_dim\_h>`, `<src\_dim\_w>` and `<src\_dim\_c>` must be greater than zero and less than 65536.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592` .






**Example**
```
#include "bang.h"
#define N 1
#define H 2
#define W 8
#define C 32
#define SRC\_NUM (N \* H \* W \* C)
#define DST\_NUM (SRC\_NUM / 8)
\_\_mlu\_entry\_\_ void kernel(unsigned char\* dst, int\* src) {
  \_\_nram\_\_ int src\_tmp[SRC\_NUM];
  \_\_nram\_\_ char dst\_tmp[DST\_NUM];
  \_\_memcpy(src\_tmp, src, SRC\_NUM \* sizeof(int), GDRAM2NRAM);
  \_\_bang\_breduce(dst\_tmp, src\_tmp, N, H, W, C);
  \_\_memcpy(dst, dst\_tmp, DST\_NUM \* sizeof(char), NRAM2GDRAM);
}

```













3.12.3. \_\_bang\_conv
-----------------------




void `__bang_conv`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* int16\_t \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* int16\_t \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(int16\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(int16\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* int16\_t \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(int16\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* int16\_t \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *dilation\_width*, unsigned int *dilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *dilation\_width*, unsigned int *dilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *out\_dilation\_width*, unsigned int *out\_dilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *dilation\_width*, unsigned int *dilation\_height*, unsigned int *out\_dilation\_width*, unsigned int *out\_dilation\_height*)  




void `__bang_conv`(int16\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* int16\_t \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* int16\_t \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* float \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv`(float \**dst*, *const* half \**src*, *const* half \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv`(float \**dst*, *const* float \**src*, *const* half \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv`(float \**dst*, *const* half \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv`(float \**dst*, *const* bfloat16\_t \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv`(float \**dst*, *const* float \**src*, *const* bfloat16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv`(float \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv`(float \**dst*, *const* float \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* half \**src*, *const* half \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* half \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* float \**src*, *const* half \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* float \**src*, *const* bfloat16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* bfloat16\_t \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, int *fix\_position*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**bias*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv`(float \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  

In `\_\_nram\_\_` address space, uses the four-dimensional convolution kernel `<kernel>[<channel\_output>, <kernel\_height>, <kernel\_width>, <channel\_input>]` to perform a convolution operation on the three-dimensional tensor `<src>[<height>, <width>, <channel\_input>]` with an interactive step size of `[<stride\_width>, <stride\_height>]`, and stores the result in the three-dimensional tensor `<dst>[<dst\_height>, <dst\_width>, <channel\_output>]`.


See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination tensor which has \(NH\_oW\_oC\_o\) data layout.
* `[in] src`: The address of source tensor which has \(NH\_iW\_iC\_i\) data layout.
* `[in] kernel`: The address of filter tensor which has \(C\_oH\_kW\_kC\_i\) data layout.
* `[in] bias`: The address of bias tensor which has \([C\_o]\) shape.
* `[in] channel\_input`: Number of input channels.
* `[in] height`: The height of source tensor.
* `[in] width`: The width of source tensor.
* `[in] kernel\_height`: The height of filter tensor.
* `[in] kernel\_width`: The width of filter tensor.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] channel\_output`: Number of output channels.
* `[in] fix\_position`: Sum of the scale factor of `<src>` and `<kernel>`.
* `[in] indilation\_width`: Input dilation in W direction.
* `[in] indilation\_height`: Input dilation in H direction.
* `[in] outdilation\_width`: Output dilation in W direction.
* `[in] outdilation\_height`: Output dilation in H direction.



**Return*** `void`.






**Remark*** `<src>`, `<dst>` and `<bias>` must point to `\_\_nram\_\_` address space;
* `<kernel>` must point to `\_\_wram\_\_` address space;
* `<fix\_position>` is the sum of the scale factor of `<src>` and `<kernel>`;
* `<fix\_position>` must be in the range `[-127, 127]`;
* The address of `<dst>`, `<src>` and `<bias>` must be 64-byte aligned on `(m)tp\_2xx`;
* The address of `<kernel>` must be 32-byte aligned;
* `<channel\_input> \* sizeof(typeof<src>)` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel\_output>` must be divisible by 64 on `(m)tp\_2xx`;
* `<channel\_output> \* sizeof(typeof<dst>)` must be 64-byte aligned on `(m)tp\_2xx`;
* The byte size of `<kernel>` must be 64-byte aligned; otherwise, the non-aligned part of `<kernel>` will be random numbers on `mtp\_372` and `tp\_322`, and zero on other architecture;






* On `(m)tp\_3xx` and higher, there is no alignment constraint for parameter `<channel\_input>`, but when allocating memory, the `ci` dimension of the memory space of `<kernel>` must satisfy the following alignment constraints:


	+ If the types of `<src>` and `<kernel>` are both floating point:
	
	
		- If `sizeof(typeof<src>) / sizeof(typeof<kernel>) == 2`, \(C\_i\) \* `sizeof(typeof<kernel>)` must be 32-byte aligned;
		- Otherwise, \(C\_i\) \* `sizeof(typeof<kernel>)` must be 64-byte aligned;
	+ If the types of `<src>` and `<kernel>` are both integer:
	
	
		- If `--wram-align 64` or `#pragma bang walign(64)`, see the table Conv w64 Alignment for more information about alignment constraints;
		- If `--wram-align 16` or `#pragma bang walign(16)`, see the table Conv w16 Alignment for more information about alignment constraints;









* On `(m)tp\_3xx` and higher, there is no alignment constraint for parameter `<channel\_output>`, but when allocating memory, the `co` dimension of memory space of `<kernel>` must be 64 aligned;
* The space size of `<bias>` is identical to `<channel\_output>`;
* `<kernel\_height>`, `<kernel\_width>`, `<channel\_input>` and `<channel\_output>` must be greater than 0;
* `<stride\_width>` and `<stride\_height>` must be in range [1, 1023];
* `<indilation\_width>`, `<indilation\_height>`, `<outdilation\_width>` and `<outdilation\_height>` must be in range [1, 1023], and 1 means no dilation;
* If `<indilation\_height>` is used, `(<height> - ((<kernel\_height> - 1) \* <indilation\_height> + 1)) / <stride\_height> + 1` must be greater than 0; otherwise, `(<height> - <kernel\_height>) / <stride\_height> + 1` must be greater than 0;
* If `<indilation\_width>` is used, `(<width> - ((<kernel\_width> - 1) \* <indilation\_width> + 1)) / <stride\_width> + 1` must be greater than 0; otherwise, `(<width> - <kernel\_width>) / <stride\_width> + 1` must be greater than 0;
* On target `(m)tp\_322` , if use `<indilation\_height>` , `(<height> - ((<kernel\_height> - 1) \* <indilation\_height> + 1)) / <stride\_height> + 1` must be in the range `[1, 1024]` ;
* On target `(m)tp\_322` , if use `<dilation\_height>` , `(<height> - ((<kernel\_height> - 1) \* <dilation\_height> + 1)) / <stride\_height> + 1` must be in the range `[1, 1024]` ;
* On target `(m)tp\_322` , if neither `<dilation\_height>` nor `<indilation\_height>` are used, `(<height> - <kernel\_height>) / <stride\_height> + 1` must be in range `[1, 1024]` ;
* `<dst>` cannot be overlapped with `<src>`;
* `<dst>` cannot be overlapped with `<bias>`.






**Compatibility between Various Architectures**



Table 3.15 Conv Data Types Supported on `(m)tp\_2xx`





| Src Type | Kernel Type | Dst Type | Bias Type |
| --- | --- | --- | --- |
| int4 | int4 | half | none |
| int4 | int4 | float | none |
| int8\_t | int4 | half | none |
| int8\_t | int4 | float | none |
| int8\_t | int8\_t | half | none |
| int8\_t | int8\_t | float | none |
| int8\_t | int8\_t | int16\_t | none |
| int16\_t | int4 | half | none |
| int16\_t | int4 | float | none |
| int16\_t | int8\_t | half | none |
| int16\_t | int8\_t | float | none |
| int16\_t | int8\_t | int16\_t | none |
| int16\_t | int16\_t | half | none |
| int16\_t | int16\_t | float | none |
| int16\_t | int16\_t | int16\_t | none |
| int4 | int4 | half | half |
| int4 | int4 | float | float |
| int8\_t | int4 | half | half |
| int8\_t | int4 | float | float |
| int8\_t | int8\_t | half | half |
| int8\_t | int8\_t | float | float |
| int8\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int4 | half | half |
| int16\_t | int4 | float | float |
| int16\_t | int8\_t | half | half |
| int16\_t | int8\_t | float | float |
| int16\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | half | half |
| int16\_t | int16\_t | float | float |
| int16\_t | int16\_t | int16\_t | int16\_t |




Table 3.16 Conv Data Types Supported on `mtp\_372`





| Src Type | Kernel Type | Dst Type | Bias Type |
| --- | --- | --- | --- |
| int8\_t | int16\_t | half | none |
| int8\_t | int16\_t | float | none |
| int8\_t | int8\_t | half | none |
| int8\_t | int8\_t | float | none |
| int8\_t | int8\_t | int16\_t | none |
| int16\_t | int8\_t | half | none |
| int16\_t | int8\_t | float | none |
| int16\_t | int8\_t | int16\_t | none |
| int16\_t | int16\_t | half | none |
| int16\_t | int16\_t | float | none |
| int16\_t | int16\_t | int16\_t | none |
| int8\_t | int16\_t | half | half |
| int8\_t | int16\_t | float | float |
| int8\_t | int8\_t | half | half |
| int8\_t | int8\_t | float | float |
| int8\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int8\_t | half | half |
| int16\_t | int8\_t | float | float |
| int16\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | half | half |
| int16\_t | int16\_t | float | float |
| int16\_t | int16\_t | int16\_t | int16\_t |
| float | float | float | none |
| half | half | float | none |
| float | half | float | none |
| half | float | float | none |
| bfloat16\_t | bfloat16\_t | float | none |
| float | bfloat16\_t | float | none |
| bfloat16\_t | float | float | none |
| int4 | int4 | float | none |
| int4 | int8\_t | float | none |
| int4 | int16\_t | float | none |
| int8\_t | int4 | float | none |
| int16\_t | int4 | float | none |
| int4 | int4 | half | none |
| int4 | int8\_t | half | none |
| int4 | int16\_t | half | none |
| int8\_t | int4 | half | none |
| int16\_t | int4 | half | none |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int16\_t | int4 | float | float |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int16\_t | int4 | half | half |




Table 3.17 Conv Data Types Supported on `mtp\_592`





| Src Type | Kernel Type | Dst Type | Bias Type |
| --- | --- | --- | --- |
| int8\_t | int16\_t | half | none |
| int8\_t | int16\_t | float | none |
| int8\_t | int8\_t | half | none |
| int8\_t | int8\_t | float | none |
| int8\_t | int8\_t | int16\_t | none |
| int16\_t | int8\_t | half | none |
| int16\_t | int8\_t | float | none |
| int16\_t | int8\_t | int16\_t | none |
| int16\_t | int16\_t | half | none |
| int16\_t | int16\_t | float | none |
| int16\_t | int16\_t | int16\_t | none |
| int8\_t | int16\_t | half | half |
| int8\_t | int16\_t | float | float |
| int8\_t | int8\_t | half | half |
| int8\_t | int8\_t | float | float |
| int8\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int8\_t | half | half |
| int16\_t | int8\_t | float | float |
| int16\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | half | half |
| int16\_t | int16\_t | float | float |
| int16\_t | int16\_t | int16\_t | int16\_t |
| float | float | float | none |
| half | half | float | none |
| bfloat16\_t | bfloat16\_t | float | none |
| int4 | int4 | float | none |
| int4 | int8\_t | float | none |
| int4 | int16\_t | float | none |
| int8\_t | int4 | float | none |
| int16\_t | int4 | float | none |
| int4 | int4 | half | none |
| int4 | int8\_t | half | none |
| int4 | int16\_t | half | none |
| int8\_t | int4 | half | none |
| int16\_t | int4 | half | none |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int16\_t | int4 | float | float |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int16\_t | int4 | half | half |




Table 3.18 Conv Data Types Supported on `tp\_322` and `tp\_520`





| Src Type | Kernel Type | Dst Type | Bias Type |
| --- | --- | --- | --- |
| int8\_t | int16\_t | half | none |
| int8\_t | int16\_t | float | none |
| int8\_t | int8\_t | half | none |
| int8\_t | int8\_t | float | none |
| int8\_t | int8\_t | int16\_t | none |
| int16\_t | int8\_t | half | none |
| int16\_t | int8\_t | float | none |
| int16\_t | int8\_t | int16\_t | none |
| int16\_t | int16\_t | half | none |
| int16\_t | int16\_t | float | none |
| int16\_t | int16\_t | int16\_t | none |
| int8\_t | int16\_t | half | half |
| int8\_t | int16\_t | float | float |
| int8\_t | int8\_t | half | half |
| int8\_t | int8\_t | float | float |
| int8\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int8\_t | half | half |
| int16\_t | int8\_t | float | float |
| int16\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | half | half |
| int16\_t | int16\_t | float | float |
| int16\_t | int16\_t | int16\_t | int16\_t |
| int4 | int4 | float | none |
| int4 | int8\_t | float | none |
| int4 | int16\_t | float | none |
| int8\_t | int4 | float | none |
| int16\_t | int4 | float | none |
| int4 | int4 | half | none |
| int4 | int8\_t | half | none |
| int4 | int16\_t | half | none |
| int8\_t | int4 | half | none |
| int16\_t | int4 | half | none |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int16\_t | int4 | float | float |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int16\_t | int4 | half | half |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_conv\_partial for more details.













3.12.4. \_\_bang\_conv\_partial
--------------------------------




void `__bang_conv_partial`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *in\_dilation\_width*, unsigned int *in\_dilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *in\_dilation\_width*, unsigned int *in\_dilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* half \**src*, *const* half \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_partial`(float \**dst*, *const* half \**src*, *const* float \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_partial`(float \**dst*, *const* float \**src*, *const* half \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_partial`(float \**dst*, *const* float \**src*, *const* float \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_partial`(float \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_partial`(float \**dst*, *const* bfloat16\_t \**src*, *const* float \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_partial`(float \**dst*, *const* float \**src*, *const* bfloat16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_partial`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *in\_dilation\_width*, unsigned int *in\_dilation\_height*, unsigned int *out\_dilation\_width*, unsigned int *out\_dilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *in\_dilation\_width*, unsigned int *in\_dilation\_height*, unsigned int *out\_dilation\_width*, unsigned int *out\_dilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* half \**src*, *const* half \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* float \**src*, *const* float \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* float \**src*, *const* half \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* half \**src*, *const* float \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* float \**src*, *const* bfloat16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* half \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  




void `__bang_conv_partial`(float \**dst*, *const* bfloat16\_t \**src*, *const* float \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  

In `\_\_nram\_\_` address space, uses the four-dimensional convolution kernel `<kernel>[<channel\_output>, <kernel\_height>, <kernel\_width>, <channel\_input>]` to perform a partial convolution operation on the three-dimensional tensor `<src>[<height>, <width>, <channel\_input>]` with an interactive step size of `[<stride\_width>, <stride\_height>]`, then adds the three-dimensional tensor `<partial>[<dst\_height>, <dst\_width>, <channel\_output>]`, and stores the result in the three-dimensional tensor `<dst>[<dst\_height>, <dst\_width>, <channel\_output>]`.


See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination tensor which has \(NH\_oW\_oC\_o\) data layout.
* `[in] src`: The address of source tensor which has \(NH\_iW\_iC\_i\) data layout.
* `[in] kernel`: The address of filter tensor which has \(C\_oH\_kW\_kC\_i\) data layout.
* `[in] partial`: The address of partial\_sum tensor which has \(NH\_oW\_oC\_o\) data layout.
* `[in] channel\_input`: Number of input channels.
* `[in] height`: The height of source tensor.
* `[in] width`: The width of source tensor.
* `[in] kernel\_height`: The height of filter tensor.
* `[in] kernel\_width`: The width of filter tensor.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] channel\_output`: Number of output channels.
* `[in] fix\_position`: Scale Sum of the scale of `<src>` and `<kernel>`.
* `[in] indilation\_width`: Input dilation in W direction.
* `[in] indilation\_height`: Input dilation in H direction.
* `[in] outdilation\_width`: Output dilation in W direction.
* `[in] outdilation\_height`: Output dilation in H direction.



**Return*** `void`






**Remark*** `<src>`, `<dst>` and `<partial>` must point to `\_\_nram\_\_` address space;
* `<kernel>` must point to `\_\_wram\_\_` address space;
* `<fix\_position>` is the sum of the scale factor of `<src>` and `<kernel>`;
* `<fix\_position>` must be in the range [-127, 127];
* The address of `<dst>`, `<src>` or `<partial>` must be 64-byte aligned on `(m)tp\_2xx`;
* The address of `<kernel>` must be 32-byte aligned;
* `<channel\_input> \* sizeof(typeof<src>)` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel\_output>` must be divisible by 64 on `(m)tp\_2xx`;
* `<channel\_output> \* sizeof(typeof<dst>)` must be 64-byte aligned on `(m)tp\_2xx`;
* The byte size of `<kernel>` must be 64-byte aligned; otherwise, the non-aligned part of `<kernel>` will be random numbers on `mtp\_372` and `tp\_322`, and zero on other architecture;






* On `(m)tp\_3xx` and higher, there is no alignment constraint for parameter `<channel\_input>`, but when allocating memory, the `ci` dimension of the memory space of `<kernel>` must satisfy the following alignment constraints:


	+ If the types of `<src>` and `<kernel>` are both floating point:
	
	
		- If `sizeof(typeof<src>) / sizeof(typeof<kernel>) == 2`, \(C\_i\) \* `sizeof(typeof<kernel>)` must be 32-byte aligned;
		- Otherwise, \(C\_i\) \* `sizeof(typeof<kernel>)` must be 64-byte aligned;
	+ If the types of `<src>` and `<kernel>` are both integer:
	
	
		- If `--wram-align 64` or `#pragma bang walign(64)`, see the table Conv w64 Alignment for more information about alignment constraints;
		- If `--wram-align 16` or `#pragma bang walign(16)`, see the table Conv w16 Alignment for more information about alignment constraints;









* On `(m)tp\_3xx` and higher, there is no alignment constraint for parameter `<channel\_output>`, but when allocating memory, the `co` dimension of memory space of `<kernel>` must be 64 aligned;
* The difference between \_\_bang\_conv\_partial and \_\_bang\_conv with bias version is: the parameter `<partial>` of \_\_bang\_conv\_partial is a tensor with the same shape as the `<dst>`; and the parameter `<bias>` of \_\_bang\_conv is a vector whose length is the same with the numbers of channels of `<dst>`;
* `<kernel\_height>`, `<kernel\_width>`, `<channel\_input>` and `<channel\_output>` must be greater than 0;
* `<stride\_width>` and `<stride\_height>` must be in range [1, 1023];
* `<indilation\_width>`, `<indilation\_height>`, `<outdilation\_width>` and `<outdilation\_height>` must be in range [1, 1023], and 1 means no dilation;
* If `<indilation\_height>` is used, `(<height> - ((<kernel\_height> - 1) \* <indilation\_height> + 1)) / <stride\_height> + 1` must be greater than 0; otherwise, `(<height> - <kernel\_height>) / <stride\_height> + 1` must be greater than 0;
* If `<indilation\_width>` is used, `(<width> - ((<kernel\_width> - 1) \* <indilation\_width> + 1)) / <stride\_width> + 1` must be greater than 0; otherwise, `(<width> - <kernel\_width>) / <stride\_width> + 1` must be greater than 0;
* On target `(m)tp\_322` , `<kernel>` must be `int4`, `int8\_t` or `int16\_t`;
* On target `(m)tp\_322` , if use `<indilation\_height>` , `(<height> - ((<kernel\_height> - 1) \* <indilation\_height> + 1)) / <stride\_height> + 1` must be in the range `[1, 1024]` ;
* On target `(m)tp\_322` , if use `<dilation\_height>` , `(<height> - ((<kernel\_height> - 1) \* <dilation\_height> + 1)) / <stride\_height> + 1` must be in the range `[1, 1024]` ;
* On target `(m)tp\_322` , if neither `<dilation\_height>` nor `<indilation\_height>` are used, `(<height> - <kernel\_height>) / <stride\_height> + 1` must be in the range `[1, 1024]` ;
* `<dst>` cannot be overlapped with `<src>`;
* `<dst>` can be overlapped with `<partial>`;
* `float`, `half`, and `bfloat16\_t` for `src` are not supported on `tp\_322` and `tp\_520`.






**Compatibility between Various Architectures**



Table 3.19 Conv Partial Data Types Supported on `(m)tp\_2xx`





| Src Type | Kernel Type | Dst Type | Partial Type |
| --- | --- | --- | --- |
| int16\_t | int8\_t | float | float |
| int8\_t | int8\_t | float | float |
| int16\_t | int16\_t | float | float |
| int4 | int4 | float | float |
| int8\_t | int4 | float | float |
| int16\_t | int4 | float | float |
| int16\_t | int16\_t | half | half |
| int16\_t | int8\_t | half | half |
| int8\_t | int8\_t | half | half |
| int4 | int4 | half | half |
| int8\_t | int4 | half | half |
| int16\_t | int4 | half | half |




Table 3.20 Conv Partial Data Types Supported on `mtp\_372`





| Src Type | Kernel Type | Dst Type | Partial Type |
| --- | --- | --- | --- |
| int16\_t | int8\_t | float | float |
| int8\_t | int8\_t | float | float |
| int8\_t | int16\_t | float | float |
| int16\_t | int16\_t | float | float |
| int16\_t | int16\_t | half | half |
| int16\_t | int8\_t | half | half |
| int8\_t | int8\_t | half | half |
| int8\_t | int16\_t | half | half |
| float | float | float | float |
| float | half | float | float |
| half | float | float | float |
| half | half | float | float |
| float | bfloat16\_t | float | float |
| bfloat16\_t | float | float | float |
| bfloat16\_t | bfloat16\_t | float | float |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int16\_t | int4 | float | float |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int16\_t | int4 | half | half |




Table 3.21 Conv Partial Data Types Supported on `mtp\_592`





| Src Type | Kernel Type | Dst Type | Partial Type |
| --- | --- | --- | --- |
| int16\_t | int8\_t | float | float |
| int8\_t | int8\_t | float | float |
| int8\_t | int16\_t | float | float |
| int16\_t | int16\_t | float | float |
| int16\_t | int16\_t | half | half |
| int16\_t | int8\_t | half | half |
| int8\_t | int8\_t | half | half |
| int8\_t | int16\_t | half | half |
| float | float | float | float |
| half | half | float | float |
| bfloat16\_t | bfloat16\_t | float | float |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int16\_t | int4 | float | float |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int16\_t | int4 | half | half |




Table 3.22 Conv Partial Data Types Supported on `tp\_322` and `tp\_520`





| Src Type | Kernel Type | Dst Type | Partial Type |
| --- | --- | --- | --- |
| int16\_t | int8\_t | float | float |
| int8\_t | int8\_t | float | float |
| int8\_t | int16\_t | float | float |
| int16\_t | int16\_t | float | float |
| int16\_t | int16\_t | half | half |
| int16\_t | int8\_t | half | half |
| int8\_t | int8\_t | half | half |
| int8\_t | int16\_t | half | half |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int16\_t | int4 | float | float |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int16\_t | int4 | half | half |




Table 3.23 Conv w64 Alignment






| Src Type | Kernel Type | ci align(B) | `ci \* <kernel\_width>` align(B) | `ci \* <kernel\_width> \* <kernel\_height>` align(B) |
| --- | --- | --- | --- | --- |
| int4 | int4 | 32 | 32 | 64 |
| int4 | int8\_t | 64 | 64 | 64 |
| int4 | int16\_t | 64 | 64 | 64 |
| int8\_t | int4 | 32 | 32 | 64 |
| int8\_t | int8\_t | 64 | 64 | 64 |
| int8\_t | int16\_t | 64 | 64 | 64 |
| int16\_t | int4 | 16 | 16 | 64 |
| int16\_t | int8\_t | 32 | 32 | 64 |
| int16\_t | int16\_t | 64 | 64 | 64 |




Table 3.24 Conv w16 Alignment






| Src Type | Kernel Type | ci align(B) | `ci \* <kernel\_width>` align(B) | `ci \* <kernel\_width> \* <kernel\_height>` align(B) |
| --- | --- | --- | --- | --- |
| int4 | int4 | 32 | 32 | 32 |
| int4 | int8\_t | 64 | 64 | 64 |
| int4 | int16\_t | 64 | 64 | 64 |
| int8\_t | int4 | 32 | 32 | 32 |
| int8\_t | int8\_t | 64 | 64 | 64 |
| int8\_t | int16\_t | 64 | 64 | 64 |
| int16\_t | int4 | 16 | 16 | 32 |
| int16\_t | int8\_t | 32 | 32 | 32 |
| int16\_t | int16\_t | 64 | 64 | 64 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= tp\_2xx`.






**Example**
```
#include <bang.h>

#define IN\_CHANNEL 128
#define IN\_HEIGHT 9
#define IN\_WIDTH 8
#define FILTER\_HEIGHT 2
#define FILTER\_WIDTH 3
#define STRIDE\_HEIGHT 4
#define STRIDE\_WIDTH 3
#define OUT\_CHANNEL 64
#define POS 2
#define DILATION\_HEIGHT 4
#define DILATION\_WIDTH 2

#define NEW\_FILTER\_HEIGHT ((FILTER\_HEIGHT - 1) \* DILATION\_HEIGHT + 1)
#define NEW\_FILTER\_WIDTH ((FILTER\_WIDTH - 1) \* DILATION\_WIDTH + 1)
#define OUT\_HEIGHT ((((IN\_HEIGHT) - (NEW\_FILTER\_HEIGHT)) / (STRIDE\_HEIGHT)) + 1)
#define OUT\_WIDTH ((((IN\_WIDTH) - (NEW\_FILTER\_WIDTH)) / (STRIDE\_WIDTH)) + 1)
#define OUT\_DATA\_NUM ((OUT\_HEIGHT) \* (OUT\_WIDTH) \* (OUT\_CHANNEL))
#define IN\_DATA\_NUM ((IN\_HEIGHT) \* (IN\_WIDTH) \* (IN\_CHANNEL))
#define FILTER\_DATA\_NUM ((FILTER\_HEIGHT) \* (FILTER\_WIDTH) \*\
                        (IN\_CHANNEL) \* (OUT\_CHANNEL))

\_\_mlu\_entry\_\_ void ConvKernel(float \*out\_data, int16\_t \*in\_data,
                              int16\_t \*filter\_data, float \*partial\_data) {
  \_\_nram\_\_ float nram\_out\_data[OUT\_DATA\_NUM];
  \_\_nram\_\_ int16\_t nram\_in\_data[IN\_DATA\_NUM];
  \_\_nram\_\_ float nram\_partial\_data[OUT\_DATA\_NUM];
  \_\_wram\_\_ int16\_t wram\_filter[FILTER\_DATA\_NUM];

  \_\_memcpy(nram\_in\_data, in\_data, IN\_DATA\_NUM \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_memcpy(wram\_filter, filter\_data, FILTER\_DATA\_NUM \* sizeof(int16\_t), GDRAM2WRAM);
  \_\_memcpy(nram\_partial\_data, partial\_data, OUT\_DATA\_NUM \* sizeof(float),
           GDRAM2NRAM);

  \_\_bang\_conv\_partial(nram\_out\_data, nram\_in\_data, wram\_filter,
                      nram\_partial\_data, IN\_CHANNEL, IN\_HEIGHT, IN\_WIDTH,
                      FILTER\_HEIGHT, FILTER\_WIDTH, STRIDE\_WIDTH, STRIDE\_HEIGHT,
                      OUT\_CHANNEL, POS, DILATION\_WIDTH, DILATION\_HEIGHT);
  \_\_memcpy(out\_data, nram\_out\_data, OUT\_DATA\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.12.5. \_\_bang\_conv\_partial\_tf32
--------------------------------------




void `__bang_conv_partial_tf32`(float \**dst*, *const* float \**src*, *const* float \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_partial_tf32`(float \**dst*, *const* float \**src*, *const* float \**kernel*, *const* float \**partial*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  

In `\_\_nram\_\_` address space, uses the four-dimensional convolution kernel `<kernel>[<channel\_output>, <kernel\_height>, <kernel\_width>, <channel\_input>]` to perform a partial convolution operation on the three-dimensional tensor `<src>[<height>, <width>, <channel\_input>]` with an interactive step size of `[<stride\_width>, <stride\_height>]`, then adds the three-dimensional tensor `<partial>[<dst\_height>, <dst\_width>, <channel\_output>]`, and stores the result in the three-dimensional tensor `<dst>[<dst\_height>, <dst\_width>, <channel\_output>]`.


See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination tensor which has \(NH\_oW\_oC\_o\) data layout.
* `[in] src`: The address of source tensor which has \(NH\_iW\_iC\_i\) data layout.
* `[in] kernel`: The address of filter tensor which has \(C\_oH\_kW\_kC\_i\) data layout.
* `[in] partial`: The address of partial\_sum tensor which has \(NH\_oW\_oC\_o\) data layout.
* `[in] channel\_input`: Number of input channels.
* `[in] height`: The height of source tensor.
* `[in] width`: The width of source tensor.
* `[in] kernel\_height`: The height of filter tensor.
* `[in] kernel\_width`: The width of filter tensor.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] channel\_output`: Number of output channels.
* `[in] indilation\_width`: Input dilation in W direction.
* `[in] indilation\_height`: Input dilation in H direction.
* `[in] outdilation\_width`: Output dilation in W direction.
* `[in] outdilation\_height`: Output dilation in H direction.



**Return*** `void`






**Remark*** `<src>`, `<dst>` and `<partial>` must point to `\_\_nram\_\_` address space;
* `<kernel>` must point to `\_\_wram\_\_` address space;
* The address of `<kernel>` must be 32-byte aligned;
* The byte size of `<kernel>` must be 64-byte aligned; otherwise, the non-aligned part will be set to zero;
* There is no alignment constraint for parameter `<channel\_input>`, but when allocating memory, \(C\_i\) \* `sizeof(typeof<kernel>)` must be 64-byte aligned;
* There is no alignment constraint for parameter `<channel\_output>`, but when allocating memory, the `co` dimension of memory space of `<kernel>` must be 64 aligned;
* `<kernel\_height>`, `<kernel\_width>`, `<channel\_input>` and `<channel\_output>` must be greater than 0;
* `<stride\_width>` and `<stride\_height>` must be in range [1, 1023];
* `<indilation\_width>`, `<indilation\_height>`, `<outdilation\_width>` and `<outdilation\_height>` must be in range [1, 1023], and 1 means no dilation;
* If `<indilation\_height>` is used, `(<height> - ((<kernel\_height> - 1) \* <indilation\_height> + 1)) / <stride\_height> + 1` must be greater than 0; otherwise, `(<height> - <kernel\_height>) / <stride\_height> + 1` must be greater than 0;
* If `<indilation\_width>` is used, `(<width> - ((<kernel\_width> - 1) \* <indilation\_width> + 1)) / <stride\_width> + 1` must be greater than 0; otherwise, `(<width> - <kernel\_width>) / <stride\_width> + 1` must be greater than 0;
* `<dst>` cannot be overlapped with `<src>`;
* `<dst>` can be overlapped with `<partial>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include <bang.h>

#define IN\_CHANNEL 128
#define IN\_HEIGHT 9
#define IN\_WIDTH 8
#define FILTER\_HEIGHT 2
#define FILTER\_WIDTH 3
#define STRIDE\_HEIGHT 4
#define STRIDE\_WIDTH 3
#define OUT\_CHANNEL 64
#define DILATION\_HEIGHT 4
#define DILATION\_WIDTH 2

#define NEW\_FILTER\_HEIGHT ((FILTER\_HEIGHT - 1) \* DILATION\_HEIGHT + 1)
#define NEW\_FILTER\_WIDTH ((FILTER\_WIDTH - 1) \* DILATION\_WIDTH + 1)
#define OUT\_HEIGHT ((((IN\_HEIGHT) - (NEW\_FILTER\_HEIGHT)) / (STRIDE\_HEIGHT)) + 1)
#define OUT\_WIDTH ((((IN\_WIDTH) - (NEW\_FILTER\_WIDTH)) / (STRIDE\_WIDTH)) + 1)
#define OUT\_DATA\_NUM ((OUT\_HEIGHT) \* (OUT\_WIDTH) \* (OUT\_CHANNEL))
#define IN\_DATA\_NUM ((IN\_HEIGHT) \* (IN\_WIDTH) \* (IN\_CHANNEL))
#define FILTER\_DATA\_NUM ((FILTER\_HEIGHT) \* (FILTER\_WIDTH) \* (IN\_CHANNEL) \* (OUT\_CHANNEL))

\_\_mlu\_entry\_\_ void ConvKernel(float \*out\_data, float \*in\_data,
                              float \*filter\_data, float \*partial\_data) {
  \_\_nram\_\_ float nram\_out\_data[OUT\_DATA\_NUM];
  \_\_nram\_\_ float nram\_in\_data[IN\_DATA\_NUM];
  \_\_nram\_\_ float nram\_partial\_data[OUT\_DATA\_NUM];
  \_\_wram\_\_ float wram\_filter[FILTER\_DATA\_NUM];

  \_\_memcpy(nram\_in\_data, in\_data, IN\_DATA\_NUM \* sizeof(float), GDRAM2NRAM);
  \_\_memcpy(wram\_filter, filter\_data, FILTER\_DATA\_NUM \* sizeof(float), GDRAM2WRAM);
  \_\_memcpy(nram\_partial\_data, partial\_data, OUT\_DATA\_NUM \* sizeof(float),
           GDRAM2NRAM);

  \_\_bang\_conv\_partial\_tf32(nram\_out\_data, nram\_in\_data, wram\_filter,
                           nram\_partial\_data, IN\_CHANNEL, IN\_HEIGHT, IN\_WIDTH,
                           FILTER\_HEIGHT, FILTER\_WIDTH, STRIDE\_WIDTH, STRIDE\_HEIGHT,
                           OUT\_CHANNEL, POS, DILATION\_WIDTH, DILATION\_HEIGHT);
  \_\_memcpy(out\_data, nram\_out\_data, OUT\_DATA\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.12.6. \_\_bang\_conv\_sparse
-------------------------------




void `__bang_conv_sparse`(float \**dst*, *const* float \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_sparse`(float \**dst*, *const* half \**src*, *const* half \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_sparse`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(float \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(half \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(int16\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int8\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  




void `__bang_conv_sparse`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, int *fix\_position*)  

In `\_\_nram\_\_` address space, uses the four-dimensional convolution kernel `<kernel>[<channel\_output>, <kernel\_height>, <kernel\_width>, <channel\_input>]` to perform a convolution operation on the three-dimensional tensor `<src>[<height>, <width>, <channel\_input>]` in sparse mode with an interactive step size of `[<stride\_width>, <stride\_height>]`, and stores the result in the three-dimensional tensor `<dst>[<dst\_height>, <dst\_width>, <channel\_output>]`.



**Parameters*** `[out] dst`: The address of destination tensor which has \(NH\_oW\_oC\_o\) data layout.
* `[in] src`: The address of source tensor which has \(NH\_iW\_iC\_i\) data layout.
* `[in] kernel`: The address of filter tensor which has \(C\_oH\_kW\_kC\_i\) data layout.
* `[in] channel\_input`: Number of input channels.
* `[in] height`: The height of source tensor.
* `[in] width`: The width of source tensor.
* `[in] kernel\_height`: The height of filter tensor.
* `[in] kernel\_width`: The width of filter tensor.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] channel\_output`: Number of output channels.
* `[in] fix\_position`: Sum of scale factor of `<src>` and `<kernel>`.



**Return*** `void`






**Remark*** In sparse mode, `<kernel>` is in form of 96-byte structure with 64-byte data and 32-byte index. `<kernel>` can either be generated online by \_\_bang\_ssparse\_filter\_union related function or be prepared offline by programmers. If programmers want to offline prepare `<kernel>`, please refer to description of the output of \_\_bang\_ssparse\_filter\_union function for details on data structure and alignment requirements;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<kernel>` must point to `\_\_wram\_\_` address space;
* `<fix\_position>` is the sum of the scale factor of `<src>` and `<kernel>`, and must be in the range `[-127, 127]`;
* The address of `<kernel>` must be 32-byte aligned;
* The byte size of `<kernel>` must be 64-byte aligned; otherwise, the non-aligned part of `<kernel>` will be zero;






* There is no alignment constraint for parameter `<channel\_input>`, but when allocating memory, the `ci` dimension of the memory space of `<kernel>` must satisfy the following alignment constraints:


	+ If the types of `<src>` and `<kernel>` are both floating point:
	
	
		- If `sizeof(typeof<src>) / sizeof(typeof<kernel>) == 2`, \(C\_i\) \* `sizeof(typeof<kernel>)` must be 32-byte aligned;
		- Otherwise, \(C\_i\) \* `sizeof(typeof<kernel>)` must be 64-byte aligned;
	+ If the types of `<src>` and `<kernel>` are both integer:
	
	
		- If `--wram-align 64` or `#pragma bang walign(64)`, see the table Conv w64 Alignment for more information about alignment constraints;
		- If `--wram-align 16` or `#pragma bang walign(16)`, see the table Conv w16 Alignment for more information about alignment constraints;









* There is no alignment constraint for parameter `<channel\_output>`, but when allocating memory, the `co` dimension of memory space of `<kernel>` must be 64 aligned;
* The space size of `<bias>` is identical to `<channel\_output>`;
* `<kernel\_height>`, `<kernel\_width>`, `<channel\_input>` and `<channel\_output>` must be greater than 0;
* `<stride\_width>` and `<stride\_height>` must be in range [1, 1023];
* `(<height> - <kernel\_height>) / <stride\_height> + 1` must be greater than 0;
* `(<width> - <kernel\_width>) / <stride\_width> + 1` must be greater than 0;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include "bang.h"
#define IN\_CHANNEL 128
#define IN\_HEIGHT 2
#define IN\_WIDTH 2
#define FILTER\_HEIGHT 1
#define FILTER\_WIDTH 1
#define STRIDE\_HEIGHT 1
#define STRIDE\_WIDTH 1
#define OUT\_CHANNEL 64
#define LT\_NUM 16
#define ESP 1e-7

#define OUT\_HEIGHT ((((IN\_HEIGHT) - (FILTER\_HEIGHT)) / (STRIDE\_HEIGHT)) + 1)
#define OUT\_WIDTH ((((IN\_WIDTH) - (FILTER\_WIDTH)) / (STRIDE\_WIDTH)) + 1)

#define OUT\_DATA\_NUM ((OUT\_HEIGHT) \* (OUT\_WIDTH) \* (OUT\_CHANNEL))
#define IN\_DATA\_NUM ((IN\_HEIGHT) \* (IN\_WIDTH) \* (IN\_CHANNEL))
#define FILTER\_DATA\_NUM (FILTER\_HEIGHT \* FILTER\_WIDTH \* IN\_CHANNEL \* OUT\_CHANNEL)
#define FILTER\_WITH\_INDEX\_DATA\_NUM (FILTER\_DATA\_NUM / 128 \* 96)

\_\_mlu\_global\_\_ void kernel(float\* dst, int16\_t\* src, int16\_t\* filter) {
  \_\_nram\_\_ float nram\_out\_data[OUT\_DATA\_NUM];
  \_\_nram\_\_ int16\_t nram\_in\_data[IN\_DATA\_NUM];
  \_\_nram\_\_ int16\_t nram\_filter[FILTER\_DATA\_NUM];
  \_\_nram\_\_ int16\_t nram\_filter\_with\_index[FILTER\_WITH\_INDEX\_DATA\_NUM];
  \_\_wram\_\_ int16\_t wram\_filter\_with\_index[FILTER\_WITH\_INDEX\_DATA\_NUM];

  \_\_memcpy(nram\_in\_data, src, IN\_DATA\_NUM \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_memcpy(nram\_filter, filter, FILTER\_DATA\_NUM \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_ssparse\_filter\_union(nram\_filter\_with\_index, nram\_filter,
                              IN\_CHANNEL \* sizeof(int16\_t), FILTER\_HEIGHT,
                              FILTER\_WIDTH, OUT\_CHANNEL);
  \_\_memcpy(wram\_filter\_with\_index, nram\_filter\_with\_index,
           FILTER\_WITH\_INDEX\_DATA\_NUM \* sizeof(int16\_t), NRAM2WRAM);
  \_\_bang\_conv\_sparse(nram\_out\_data, nram\_in\_data, wram\_filter\_with\_index,
                     IN\_CHANNEL, IN\_HEIGHT, IN\_WIDTH, FILTER\_HEIGHT,
                     FILTER\_WIDTH, STRIDE\_WIDTH, STRIDE\_HEIGHT, OUT\_CHANNEL, 0);
  \_\_memcpy(dst, nram\_out\_data, OUT\_DATA\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.12.7. \_\_bang\_conv\_tf32
-----------------------------




void `__bang_conv_tf32`(float \**dst*, *const* float \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*)  




void `__bang_conv_tf32`(float \**dst*, *const* float \**src*, *const* float \**kernel*, unsigned int *channel\_input*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *channel\_output*, unsigned int *indilation\_width*, unsigned int *indilation\_height*, unsigned int *outdilation\_width*, unsigned int *outdilation\_height*)  

In `\_\_nram\_\_` address space, uses the four-dimensional convolution kernel `<kernel>[<channel\_output>, <kernel\_height>, <kernel\_width>, <channel\_input>]` to perform a convolution operation on the three-dimensional tensor `<src>[<height>, <width>, <channel\_input>]` with an interactive step size of `[<stride\_width>, <stride\_height>]`, and stores the result in the three-dimensional tensor `<dst>[<dst\_height>, <dst\_width>, <channel\_output>]`.


See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination tensor which has \(NH\_oW\_oC\_o\) data layout.
* `[in] src`: The address of source tensor which has \(NH\_iW\_iC\_i\) data layout.
* `[in] kernel`: The address of filter tensor which has \(C\_oH\_kW\_kC\_i\) data layout.
* `[in] channel\_input`: Number of input channels.
* `[in] height`: The height of source tensor.
* `[in] width`: The width of source tensor.
* `[in] kernel\_height`: The height of filter tensor.
* `[in] kernel\_width`: The width of filter tensor.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] channel\_output`: Number of output channels.
* `[in] indilation\_width`: Input dilation in W direction.
* `[in] indilation\_height`: Input dilation in H direction.
* `[in] outdilation\_width`: Output dilation in W direction.
* `[in] outdilation\_height`: Output dilation in H direction.



**Return*** `void`.






**Remark*** `<src>`, `<dst>` must point to `\_\_nram\_\_` address space;
* `<kernel>` must point to `\_\_wram\_\_` address space;
* The address of `<kernel>` must be 32-byte aligned;
* The byte size of `<kernel>` must be 64-byte aligned; otherwise, the non-aligned part will be set to zero;
* There is no alignment constraint for parameter `<channel\_input>`, but when allocating memory, \(C\_i\) \* `sizeof(typeof<kernel>)` must be 64-byte aligned;
* There is no alignment constraint for parameter `<channel\_output>`, but when allocating memory, the `co` dimension of memory space of `<kernel>` must be 64 aligned;
* `<kernel\_height>`, `<kernel\_width>`, `<channel\_input>` and `<channel\_output>` must be greater than 0;
* `<stride\_width>` and `<stride\_height>` must be in range [1, 1023];
* `<indilation\_width>`, `<indilation\_height>`, `<outdilation\_width>` and `<outdilation\_height>` must be in range [1, 1023], and 1 means no dilation;
* If `<indilation\_height>` is used, `(<height> - ((<kernel\_height> - 1) \* <indilation\_height> + 1)) / <stride\_height> + 1` must be greater than 0; otherwise, `(<height> - <kernel\_height>) / <stride\_height> + 1` must be greater than 0;
* If `<indilation\_width>` is used, `(<width> - ((<kernel\_width> - 1) \* <indilation\_width> + 1)) / <stride\_width> + 1` must be greater than 0; otherwise, `(<width> - <kernel\_width>) / <stride\_width> + 1` must be greater than 0;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** See the example of \_\_bang\_conv\_partial\_tf32 for more detail.













3.12.8. \_\_bang\_maxpool
--------------------------




void `__bang_maxpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*)  




void `__bang_maxpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_maxpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_maxpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_maxpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_maxpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




3.12.9. \_\_bang\_maxpool\_bp
------------------------------




void `__bang_maxpool_bp`(half \**dst*, *const* half \**src*, short \**mask*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  




void `__bang_maxpool_bp`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned short \**mask*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  




void `__bang_maxpool_bp`(float \**dst*, *const* float \**src*, int \**mask*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  

Applies maxpooling backward propagation operation on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the index with the maximum value. `<overlap>` indicates the type of overlap options. `<overlap>` is assigned to an enumerated type called `mluPoolBPOverlap` that contains 2 enumerators listed in the table below. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded.




Table 3.25 Semantics of `mluPoolBPOverlap`



| `mluPoolBPOverlap` Type | Semantic |
| --- | --- |
| `OVERLAP\_ACC` | Accumulates the overlap parts of the output. |
| `OVERLAP\_COVER` | Covers the overlap parts of the output. |









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] mask`: The index of the maximum value inside a kernel, and the tensor data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of output feature map.
* `[in] width`: The width of output feature map.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] overlap`: The type of overlap options.



**Return*** `void`.






**Remark*** `<src>`, `<mask>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* The address of `<src>`, `<mask>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* When the data type of `<src>` and `<dst>` is `half` or `bfloat16\_t`, the data type of `<mask>` must be `short`. When the data type of `<src>` and `<dst>` are float, the data type of `<mask>` must be `int`;
* `<dst>` cannot be overlapped with `<src>`;
* The default `mluPoolBPOverlap` option is `OVERLAP\_ACC`;
* `[input\_height]` and `[input\_width]` of `<src>` must be greater than 0;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>` and `<stride\_width>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\).






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void PoolMaxBpKernel(half\* output, half\* input, int16\_t\* mask,
                                   int channels, int out\_height,
                                   int out\_width, int kernel\_height,
                                   int kernel\_width, int stride\_width,
                                   int stride\_height) {
  \_\_nram\_\_ half a\_tmp[INPUT\_COUNT];
  \_\_nram\_\_ half b\_tmp[OUTPUT\_COUNT];
  \_\_nram\_\_ int16\_t c\_tmp[INPUT\_COUNT];

  \_\_memcpy(b\_tmp, output, OUTPUT\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(a\_tmp, input, INPUT\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(c\_tmp, mask, INPUT\_COUNT \* sizeof(int16\_t), GDRAM2NRAM);

  \_\_bang\_maxpool\_bp(b\_tmp, a\_tmp, c\_tmp, channels, out\_height, out\_width,
                    kernel\_height, kernel\_width, stride\_width, stride\_height);

  \_\_memcpy(output, b\_tmp, OUTPUT\_COUNT \* sizeof(half), NRAM2GDRAM);
}

```













3.12.10. \_\_bang\_maxpool\_index
----------------------------------




void `__bang_maxpool_index`(unsigned short \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*)  




void `__bang_maxpool_index`(unsigned short \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_maxpool_index`(unsigned short \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_maxpool_index`(unsigned short \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_maxpool_index`(unsigned int \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_maxpool_index`(unsigned short \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_maxpool_index`(unsigned int \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  

Applies maxpooling forward operation with index on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the index of the maximum value in each window. When the data type of `<src>` is `half` or `bfloat16\_t`, the data type of `<dst>` is `unsigned short`. When the data type of `<src>` is `float`, the data type of `<dst>` is `unsigned int`. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple maximum values, the index is the position of the first maximum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The function with dilation is supported on `(m)tp\_3xx` or higher;
* `<dst>` cannot be overlapped with `<src>`;
* In the function without stride, `<stride\_width>` equals `<kernel\_width>` and `<stride\_height>` equals `<kernel\_height>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* `<stride\_height>` and `<stride\_width>` must be greater than 0 if specified;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define CHANNELS 64
#define HEIGHT 9
#define WIDTH 12
#define KERNEL\_HEIGHT 5
#define KERNEL\_WIDTH 4

#define BOTTOM\_DATA\_COUNT ((CHANNELS) \* (WIDTH) \* (HEIGHT))
#define TOP\_DATA\_COUNT \
  ((CHANNELS) \* (HEIGHT / KERNEL\_HEIGHT) \* (WIDTH / KERNEL\_WIDTH))

\_\_mlu\_entry\_\_ void MaxPoolIndexKernel(half\* bottom\_data, int16\_t\* top\_data,
                                      int channels, int height, int width,
                                      int pooled\_height, int pooled\_width) {
  \_\_nram\_\_ half a\_tmp[BOTTOM\_DATA\_COUNT];
  \_\_nram\_\_ uint16\_t b\_tmp[TOP\_DATA\_COUNT];
  \_\_memcpy(a\_tmp, bottom\_data, BOTTOM\_DATA\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_maxpool\_index(b\_tmp, a\_tmp, CHANNELS, HEIGHT, WIDTH,
                       KERNEL\_HEIGHT, KERNEL\_WIDTH);
  \_\_memcpy(top\_data, b\_tmp, TOP\_DATA\_COUNT \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.12.11. \_\_bang\_maxpool\_value\_index
-----------------------------------------




void `__bang_maxpool_value_index`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*)  




void `__bang_maxpool_value_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*)  




void `__bang_maxpool_value_index`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*)  




void `__bang_maxpool_value_index`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_maxpool_value_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_maxpool_value_index`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  

Performs maximum pooling operation with the kernel `[kernel\_height, kernel\_width]` and the stride `[stride\_width, stride\_height]` on the tensor `<src>[channel, height, width]` in `\_\_nram\_\_` address space, then stores the maximum value and the corresponding index to `<dst>`. When the data type of `<src>` is `half`, the data type of `value` in `<dst>` is `half` and the data type of `index` in `<dst>` is `unsigned short`. When the data type of `<src>` is `float`, the data type of `value` in `<dst>` is `float` and the data type of `index` in `<dst>` is `unsigned int`. When the kernel moves to the edge of input `<width>` and the kernel overflows, it will automatically adapt to the size of `<kernel\_width>`, so as to ensure that useless input is not included. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple maximum values, the index is the position of the first maximum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: The input channel.
* `[in] height`: The height of input source.
* `[in] width`: The width of input source.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] value\_index\_stride`: The offset from the beginning of data value to index value in bytes.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* For the output tensor `<dst>[output\_channel, output\_height, output\_width]`, `[output\_channel] = <channel>`, and `[output\_height, output\_width]` are obtained by deducing from `[height, width]`, `[kernel\_height, kernel\_width]` and `[stride\_width, stride\_height]`;
* For the value part of `<dst>`, when `<value\_index\_stride> > 0`, the address operands `<dst>` can be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>`, `<stride\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example**
```
#include <bang.h>

#define DATA\_NUM 64

\_\_mlu\_entry\_\_ void kernel(half \*dst, half \*src, float \*dst\_f,
                          float \*src\_f, int channel,
                          int height, int width,
                          int kernel\_height, int kernel\_width,
                          int stride\_width, int stride\_height,
                          int value\_index\_stride,
                          int in\_dh, int in\_dw,
                          int out\_dh, int out\_dw) {
  \_\_nram\_\_ half svc\_dst[DATA\_NUM];
  \_\_nram\_\_ half svc\_src[DATA\_NUM];
  int datasize = DATA\_NUM \* sizeof(half);
  \_\_memcpy(svc\_src, src, datasize, GDRAM2NRAM);
  \_\_bang\_maxpool\_value\_index(svc\_dst, svc\_src, channel, height,
                             width, kernel\_height, kernel\_width,
                             stride\_width, stride\_height,
                             value\_index\_stride,
                             in\_dh, in\_dw, out\_dh, out\_dw);
  \_\_memcpy(dst, svc\_dst, datasize, NRAM2GDRAM);
}

```













3.12.12. \_\_bang\_minpool
---------------------------




void `__bang_minpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*)  




void `__bang_minpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_minpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_minpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_minpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_minpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_minpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  

Applies minpooling forward operation on `<src>``[``<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the minimum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple minimum values, the result is the first minimum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of sliding window.
* `[in] kernel\_width`: The width of sliding window.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The function with dilation is supported on `(m)tp\_3xx` or higher;
* `<dst>` cannot be overlapped with `<src>`;
* In the function without stride, `<stride\_width>` equals `<kernel\_width>` and `<stride\_height>` equals `<kernel\_height>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* `<stride\_height>` and `<stride\_width>` must be greater than 0 if specified;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.12.13. \_\_bang\_minpool\_index
----------------------------------




void `__bang_minpool_index`(unsigned short \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*)  




void `__bang_minpool_index`(unsigned short \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_minpool_index`(unsigned short \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_minpool_index`(unsigned short \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_minpool_index`(unsigned int \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_minpool_index`(unsigned short \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_minpool_index`(unsigned int \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  

Applies minpooling forward operation with index on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the index with the minimum value in each window. When the data type of `<src>` is `half` or `bfloat16\_t`, the data type of `<dst>` is `unsigned short`. When the data type of `<src>` is `float`, the data type of `<dst>` is `unsigned int`. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple minimum values, the index is the position of the first minimum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of sliding window.
* `[in] kernel\_width`: The width of sliding window.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The function with dilation is supported on `(m)tp\_3xx` or higher;
* `<dst>` cannot be overlapped with `<src>`;
* In the function without stride, `<stride\_width>` equals `<kernel\_width>` and `<stride\_height>` equals `<kernel\_height>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* `<stride\_height>` and `<stride\_width>` must be greater than 0 if specified;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.12.14. \_\_bang\_minpool\_value\_index
-----------------------------------------




void `__bang_minpool_value_index`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*)  




void `__bang_minpool_value_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*)  




void `__bang_minpool_value_index`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*)  




void `__bang_minpool_value_index`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_minpool_value_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_minpool_value_index`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  

* Performs minimum pooling operation with the kernel [`<kernel\_height>`, `<kernel\_width>`] and the stride [`<stride\_width>`, `<stride\_height>`] on the tensor `<src>``[``<channel>`, `<height>`, `<width>`] in `\_\_nram\_\_` address space, and stores the minimum value and the corresponding index to `<dst>`. When the data type of `<src>` is `half` or `bfloat16\_t`, the data type of `value` in `<dst>` is `half` and the data type of `index` in `<dst>` is `unsigned short`. When the data type of `<src>` is `float`, the data type of `value` in `<dst>` is `float` and the data type of `index` in `<dst>` is `unsigned int`. When the kernel moves to the edge of input `<width>` and the kernel overflows, it will automatically adapt to the size of `<kernel\_width>`, so as to ensure that useless input is not included. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple minimum values, the index is the position of the first minimum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: The input channel.
* `[in] height`: The height of input source.
* `[in] width`: The width of input source.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] value\_index\_stride`: The offset from the beginning of data value to index value in bytes.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* For the output tensor `<dst>[output\_channel, output\_height, output\_width]`, `[output\_channel] = <channel>`, and `[output\_height, output\_width]` are obtained by deducing from `[height, width]`, `[kernel\_height, kernel\_width]` and `[stride\_width, stride\_height]`;
* For the value part of `<dst>`, when `<value\_index\_stride> > 0`, the address operands `<dst>` can be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>`, `<stride\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example**
```
#include <bang.h>

#define DATA\_NUM 64

\_\_mlu\_entry\_\_ void kernel(half \*dst, half \*src, float \*dst\_f, float \*src\_f,
                          int channel, int height, int width, int kernel\_height,
                          int kernel\_width, int stride\_width, int stride\_height,
                          int value\_index\_stride, int in\_dh, int in\_dw,
                          int out\_dh, int out\_dw);
  int datasize = DATA\_NUM \* sizeof(half);
  \_\_nram\_\_ half svc\_dst[DATA\_NUM];
  \_\_nram\_\_ half svc\_src[DATA\_NUM];
  \_\_memcpy(svc\_src, src, datasize, GDRAM2NRAM);
  \_\_bang\_minpool\_value\_index(svc\_dst, svc\_src, channel, height, width,
                             kernel\_height, kernel\_width, stride\_width,
                             stride\_height, value\_index\_stride,
                             in\_dh, in\_dw, out\_dh, out\_dw);
  \_\_memcpy(dst, svc\_dst, datasize, NRAM2GDRAM);
}

```













3.12.15. \_\_bang\_mlp
-----------------------




void `__bang_mlp`(half \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int8\_t \**src*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int16\_t \**src*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int4x2\_t \**src*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int4x2\_t \**src*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int4x2\_t \**src*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int8\_t \**src*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int8\_t \**src*, *const* int16\_t \**filter*, int *height*, int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int16\_t \**src*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int16\_t \**src*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* half \**src*, *const* half \**filter*, int *height*, int *width*)  




void `__bang_mlp`(float \**dst*, *const* float \**src*, *const* float \**filter*, int *height*, int *width*)  




void `__bang_mlp`(float \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**filter*, int *height*, int *width*)  




void `__bang_mlp`(int16\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int4x2\_t \**src*, *const* half \**bias*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int4x2\_t \**src*, *const* half \**bias*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int4x2\_t \**src*, *const* half \**bias*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int8\_t \**src*, *const* half \**bias*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int8\_t \**src*, *const* half \**bias*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int8\_t \**src*, *const* half \**bias*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int16\_t \**src*, *const* half \**bias*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int16\_t \**src*, *const* half \**bias*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(half \**dst*, *const* int16\_t \**src*, *const* half \**bias*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int4x2\_t \**src*, *const* float \**bias*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int4x2\_t \**src*, *const* float \**bias*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int4x2\_t \**src*, *const* float \**bias*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int8\_t \**src*, *const* float \**bias*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int8\_t \**src*, *const* float \**bias*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int16\_t \**src*, *const* float \**bias*, *const* int4x2\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int16\_t \**src*, *const* float \**bias*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(float \**dst*, *const* int16\_t \**src*, *const* float \**bias*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(int16\_t \**dst*, *const* int8\_t \**src*, *const* int16\_t \**bias*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**bias*, *const* int8\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  




void `__bang_mlp`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**bias*, *const* int16\_t \**filter*, unsigned int *height*, unsigned int *width*, int *fix\_position*)  

Applies multilayer perception operation. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.








For version with `<bias>`: \(<dst> = <src> \times <filter> + <bias>\).


For version without `<bias>`: \(<dst> = <src> \times <filter>\).



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] bias`: The address of bias vector.
* `[in] filter`: The address of filter matrix which has row-major data layout.
* `[in] height`: The height of <filter>.
* `[in] width`: The width of <filter>.
* `[in] fix\_position`: Sum of scale factor of `<src>` and `<kernel>`.



**Return*** `void`.






**Remark*** `<dst>`, `<src>` and `<bias>` must point to `\_\_nram\_\_` address space;
* `<filter>` must point to `\_\_wram\_\_` address space;
* The matrix `<filter>` must be reshaped either on host or on device with `\_\_bang\_reshape()`;
* `<fix\_position>` is the sum of the scale factor of `<src>` and `<filter>`;
* `<fix\_position>` must be in the range `[-127, 127]`;
* The address of `<dst>`, `<src>` and `<bias>` must be 64-byte aligned on `(m)tp\_2xx`;
* The address of `<filter>` must be 32-byte aligned;
* `<height>` must be divisible by 64 on `(m)tp\_2xx`;
* `<width> \* sizeof(typeof<src>)` must be 64-byte aligned on `(m)tp\_2xx`;






* On `(m)tp\_3xx` and higher, `width` dimension space of `<filter>` must satisfy the following alignment constraints:


	+ If the types of `<src>` and `<filter>` are both floating point:
	
	
		- If `sizeof(typeof<src>) / sizeof(typeof<filter>) == 2`, `width \* sizeof(typeof<filter>)` must be 32-byte aligned;
		- Otherwise, `width \* sizeof(typeof<filter>)` must be 64-byte aligned;
	+ If the types of `<src>` and `<filter>` are both integer:
	
	
		- If `--wram-align 64` or `#pragma bang walign(64)`, `width \* sizeof(typeof<filter>)` must be 64-byte aligned;
		- If `--wram-align 16` or `#pragma bang walign(16)`, see the table Mlp w16 Alignment for more information about `width` alignment constraints;









* On `(m)tp\_3xx` and higher, there is no alignment constraint for parameter `<height>`, but when allocating memory, the `height` dimension of memory space of `<filter>` must be 64 aligned;
* `<width>` and `<height>` must be greater than 0;
* If have `<bias>`, the data type of `<bias>` must be same with `<dst>`;
* `<dst>` cannot be overlapped with `<src>`;
* `<dst>` cannot be overlapped with `<bias>`.






**Compatibility between Various Architectures**



Table 3.26 Data Types Supported on `(m)tp\_2xx`





| Src Type | Filter Type | Dst Type | Bias Type |
| --- | --- | --- | --- |
| int4 | int4 | half | half |
| int8\_t | int4 | half | half |
| int8\_t | int8\_t | half | half |
| int16\_t | int4 | half | half |
| int16\_t | int8\_t | half | half |
| int16\_t | int16\_t | half | half |
| int4 | int4 | float | float |
| int8\_t | int4 | float | float |
| int8\_t | int8\_t | float | float |
| int16\_t | int4 | float | float |
| int16\_t | int8\_t | float | float |
| int16\_t | int16\_t | float | float |
| int8\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | int16\_t | int16\_t |
| int4 | int4 | half | none |
| int8\_t | int4 | half | none |
| int8\_t | int8\_t | half | none |
| int16\_t | int4 | half | none |
| int16\_t | int8\_t | half | none |
| int16\_t | int16\_t | half | none |
| int4 | int4 | float | none |
| int8\_t | int4 | float | none |
| int8\_t | int8\_t | float | none |
| int16\_t | int4 | float | none |
| int16\_t | int8\_t | float | none |
| int16\_t | int16\_t | float | none |
| int8\_t | int8\_t | int16\_t | none |
| int16\_t | int8\_t | int16\_t | none |
| int16\_t | int16\_t | int16\_t | none |











Table 3.27 Data Types Supported on `mtp\_372` and `mtp\_592`





| Src Type | Filter Type | Dst Type | Bias Type |
| --- | --- | --- | --- |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int8\_t | int8\_t | half | half |
| int8\_t | int16\_t | half | half |
| int16\_t | int4 | half | half |
| int16\_t | int8\_t | half | half |
| int16\_t | int16\_t | half | half |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int8\_t | int8\_t | float | float |
| int8\_t | int16\_t | float | float |
| int16\_t | int4 | float | float |
| int16\_t | int8\_t | float | float |
| int16\_t | int16\_t | float | float |
| int8\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | int16\_t | int16\_t |
| int4 | int4 | half | none |
| int4 | int8\_t | half | none |
| int4 | int16\_t | half | none |
| int8\_t | int4 | half | none |
| int8\_t | int8\_t | half | none |
| int8\_t | int16\_t | half | none |
| int16\_t | int4 | half | none |
| int16\_t | int8\_t | half | none |
| int16\_t | int16\_t | half | none |
| int4 | int4 | float | none |
| int4 | int8\_t | float | none |
| int4 | int16\_t | float | none |
| int8\_t | int4 | float | none |
| int8\_t | int8\_t | float | none |
| int8\_t | int16\_t | float | none |
| int16\_t | int4 | float | none |
| int16\_t | int8\_t | float | none |
| int16\_t | int16\_t | float | none |
| half | half | float | none |
| float | float | float | none |
| bfloat16\_t | bfloat16\_t | float | none |
| int8\_t | int8\_t | int16\_t | none |
| int16\_t | int8\_t | int16\_t | none |
| int16\_t | int16\_t | int16\_t | none |











Table 3.28 Data Types Supported on `tp\_322` and `tp\_520`





| Src Type | Filter Type | Dst Type | Bias Type |
| --- | --- | --- | --- |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int8\_t | int8\_t | half | half |
| int8\_t | int16\_t | half | half |
| int16\_t | int4 | half | half |
| int16\_t | int8\_t | half | half |
| int16\_t | int16\_t | half | half |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int8\_t | int8\_t | float | float |
| int8\_t | int16\_t | float | float |
| int16\_t | int4 | float | float |
| int16\_t | int8\_t | float | float |
| int16\_t | int16\_t | float | float |
| int8\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int8\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | int16\_t | int16\_t |
| int4 | int4 | half | none |
| int4 | int8\_t | half | none |
| int4 | int16\_t | half | none |
| int8\_t | int4 | half | none |
| int8\_t | int8\_t | half | none |
| int8\_t | int16\_t | half | none |
| int16\_t | int4 | half | none |
| int16\_t | int8\_t | half | none |
| int16\_t | int16\_t | half | none |
| int4 | int4 | float | none |
| int4 | int8\_t | float | none |
| int4 | int16\_t | float | none |
| int8\_t | int4 | float | none |
| int8\_t | int8\_t | float | none |
| int8\_t | int16\_t | float | none |
| int16\_t | int4 | float | none |
| int16\_t | int8\_t | float | none |
| int16\_t | int16\_t | float | none |
| int8\_t | int8\_t | int16\_t | none |
| int16\_t | int8\_t | int16\_t | none |
| int16\_t | int16\_t | int16\_t | none |




Table 3.29 Mlp w16 Alignment




| Src Type | Kernel Type | Width align(B) |
| --- | --- | --- |
| int4 | int4 | 32 |
| int4 | int8\_t | 64 |
| int4 | int16\_t | 64 |
| int8\_t | int4 | 32 |
| int8\_t | int8\_t | 64 |
| int8\_t | int16\_t | 64 |
| int16\_t | int4 | 16 |
| int16\_t | int8\_t | 32 |
| int16\_t | int16\_t | 64 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
 #include <bang.h>

 #define HEIGHT 64
 #define WIDTH 64
 #define POS 0

 \_\_mlu\_entry\_\_ void MlpKernel(half\* out\_data, int16\_t\* in\_data,
                              int16\_t\* filter\_data, half\* bias\_data,
                              int height, int width, int pos) {
  \_\_nram\_\_ half nram\_out\_data[HEIGHT];
  \_\_nram\_\_ half nram\_bias\_data[HEIGHT];
  \_\_nram\_\_ int16\_t nram\_in\_data[WIDTH];
  \_\_wram\_\_ int16\_t wram\_filter[HEIGHT \* WIDTH];
  \_\_memcpy(nram\_in\_data, in\_data, WIDTH \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_memcpy(nram\_bias\_data, bias\_data, HEIGHT \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(wram\_filter, filter\_data, HEIGHT \* WIDTH \* sizeof(int16\_t),
           GDRAM2WRAM);
  \_\_bang\_mlp(nram\_out\_data, nram\_in\_data, nram\_bias\_data, wram\_filter,
             HEIGHT, WIDTH, POS);
  \_\_memcpy(out\_data, nram\_out\_data, HEIGHT \* sizeof(half), NRAM2GDRAM);
}

```













3.12.16. \_\_bang\_nan\_maxpool
--------------------------------




void `__bang_nan_maxpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_maxpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_maxpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  

Applies maxpooling forward operation on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the maximum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple maximum values, the result is the first maximum value.









**Parameters*** `[out] dst`: The address of destination tensor. And the tensor data layout is HWC.
* `[in] src`: The address of source tensor. And the tensor data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of sliding window.
* `[in] kernel\_width`: The width of sliding window.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>`, `<stride\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define CHANNELS 64
#define HEIGHT 4
#define WIDTH 4
#define KERNEL\_HEIGHT 2
#define KERNEL\_WIDTH 2
#define BOTTOM\_DATA\_COUNT ((CHANNELS) \* (WIDTH) \* (HEIGHT))
#define TOP\_DATA\_COUNT \
  ((CHANNELS) \* (HEIGHT / KERNEL\_HEIGHT) \* (WIDTH / KERNEL\_WIDTH))

\_\_mlu\_entry\_\_ void maxPoolingKernel(half\* bottom\_data, half\* top\_data,
                                    int channels, int height, int width,
                                    int pooled\_height, int pooled\_width) {
  \_\_nram\_\_ half a\_tmp[BOTTOM\_DATA\_COUNT];
  \_\_nram\_\_ half b\_tmp[TOP\_DATA\_COUNT];
  \_\_memcpy(a\_tmp, bottom\_data, BOTTOM\_DATA\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_nan\_maxpool(b\_tmp, a\_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL\_HEIGHT, KERNEL\_WIDTH);
  \_\_memcpy(top\_data, b\_tmp, TOP\_DATA\_COUNT \* sizeof(half), NRAM2GDRAM);
}

```













3.12.17. \_\_bang\_nan\_maxpool\_index
---------------------------------------




void `__bang_nan_maxpool_index`(unsigned short \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_maxpool_index`(unsigned short \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_maxpool_index`(unsigned int \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  

Applies maxpooling forward operation with index on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the index of the maximum value in each window. When the data type of `<src>` is `half` or `bfloat16\_t`, the data type of `<dst>` is `unsigned short`. When the data type of `<src>` is `float`, the data type of `<dst>` is `unsigned int`. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple maximum values, the index is the position of the first maximum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>`, `<stride\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define CHANNELS 64
#define HEIGHT 9
#define WIDTH 12
#define KERNEL\_HEIGHT 5
#define KERNEL\_WIDTH 4

#define BOTTOM\_DATA\_COUNT ((CHANNELS) \* (WIDTH) \* (HEIGHT))
#define TOP\_DATA\_COUNT \
  ((CHANNELS) \* (HEIGHT / KERNEL\_HEIGHT) \* (WIDTH / KERNEL\_WIDTH))

\_\_mlu\_entry\_\_ void MaxPoolIndexKernel(half\* bottom\_data, int16\_t\* top\_data,
                                      int channels, int height, int width,
                                      int pooled\_height, int pooled\_width) {
  \_\_nram\_\_ half a\_tmp[BOTTOM\_DATA\_COUNT];
  \_\_nram\_\_ uint16\_t b\_tmp[TOP\_DATA\_COUNT];
  \_\_memcpy(a\_tmp, bottom\_data, BOTTOM\_DATA\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_nan\_maxpool\_index(b\_tmp, a\_tmp, CHANNELS, HEIGHT, WIDTH,
                           KERNEL\_HEIGHT, KERNEL\_WIDTH);
  \_\_memcpy(top\_data, b\_tmp, TOP\_DATA\_COUNT \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.12.18. \_\_bang\_nan\_maxpool\_value\_index
----------------------------------------------




void `__bang_nan_maxpool_value_index`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_maxpool_value_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_maxpool_value_index`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  

* Performs maximum pooling operation with the kernel `[kernel\_height, kernel\_width]` and the stride `[stride\_width, stride\_height]` on the tensor `<src>[channel, height, width]` in `\_\_nram\_\_` address space, then stores the maximum value and the corresponding index to `<dst>`. When the data type of `<src>` is `half`, the data type of `value` in `<dst>` is `half` and the data type of `index` in `<dst>` is `unsigned short`. When the data type of `<src>` is `float`, the data type of `value` in `<dst>` is `float` and the data type of `index` in `<dst>` is `unsigned int`. When the kernel moves to the edge of input `<width>` and the kernel overflows, it will automatically adapt to the size of `<kernel\_width>`, so as to ensure that useless input is not included. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple maximum values, the index is the position of the first maximum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: The input channel.
* `[in] height`: The height of input source.
* `[in] width`: The width of input source.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] value\_index\_stride`: The offset from the beginning of data value to index value in bytes.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* For the output tensor `<dst>[output\_channel, output\_height, output\_width]`, `[output\_channel] = <channel>`, and `[output\_height, output\_width]` are obtained by deducing from `[height, width]`, `[kernel\_height, kernel\_width]` and `[stride\_width, stride\_height]`;
* For the value part of `<dst>`, when `<value\_index\_stride> > 0`, the address operands `<dst>` can be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>`, `<stride\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define DATA\_NUM 64

\_\_mlu\_entry\_\_ void kernel(half \*dst, half \*src, float \*dst\_f,
                          float \*src\_f, int channel,
                          int height, int width,
                          int kernel\_height, int kernel\_width,
                          int stride\_width, int stride\_height,
                          int value\_index\_stride,
                          int in\_dh, int in\_dw,
                          int out\_dh, int out\_dw) {
  \_\_nram\_\_ half svc\_dst[DATA\_NUM];
  \_\_nram\_\_ half svc\_src[DATA\_NUM];
  int datasize = DATA\_NUM \* sizeof(half);
  \_\_memcpy(svc\_src, src, datasize, GDRAM2NRAM);
  \_\_bang\_nan\_maxpool\_value\_index(svc\_dst, svc\_src, channel, height,
                                 width, kernel\_height, kernel\_width,
                                 stride\_width, stride\_height,
                                 value\_index\_stride,
                                 in\_dh, in\_dw, out\_dh, out\_dw);
  \_\_memcpy(dst, svc\_dst, datasize, NRAM2GDRAM);
}

```













3.12.19. \_\_bang\_nan\_minpool
--------------------------------




void `__bang_nan_minpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_minpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_minpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  

Applies minpooling forward operation on `<src>``[``<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the minimum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple minimum values, the result is the first minimum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of sliding window.
* `[in] kernel\_width`: The width of sliding window.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>`, `<stride\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.12.20. \_\_bang\_nan\_minpool\_index
---------------------------------------




void `__bang_nan_minpool_index`(unsigned short \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_minpool_index`(unsigned short \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_minpool_index`(unsigned int \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  

Applies minpooling forward operation with index on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the index with the minimum value in each window. When the data type of `<src>` is `half` or `bfloat16\_t`, the data type of `<dst>` is `unsigned short`. When the data type of `<src>` is `float`, the data type of `<dst>` is `unsigned int`. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple minimum values, the index is the position of the first minimum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of sliding window.
* `[in] kernel\_width`: The width of sliding window.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>`, `<stride\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.12.21. \_\_bang\_nan\_minpool\_value\_index
----------------------------------------------




void `__bang_nan_minpool_value_index`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_minpool_value_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_nan_minpool_value_index`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *value\_index\_stride*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  

* Performs minimum pooling operation with the kernel [`<kernel\_height>`, `<kernel\_width>`] and the stride [`<stride\_width>`, `<stride\_height>`] on the tensor `<src>``[``<channel>`, `<height>`, `<width>`] in `\_\_nram\_\_` address space, and stores the minimum value and the corresponding index to `<dst>`. When the data type of `<src>` is `half` or `bfloat16\_t`, the data type of `value` in `<dst>` is `half` and the data type of `index` in `<dst>` is `unsigned short`. When the data type of `<src>` is `float`, the data type of `value` in `<dst>` is `float` and the data type of `index` in `<dst>` is `unsigned int`. When the kernel moves to the edge of input `<width>` and the kernel overflows, it will automatically adapt to the size of `<kernel\_width>`, so as to ensure that useless input is not included. If one of the elements being compared is a NaN, returns the element. If there are multiple NaN values, the index is the position of the first NaN value. If there are multiple minimum values, the index is the position of the first minimum value.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: The input channel.
* `[in] height`: The height of input source.
* `[in] width`: The width of input source.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: The stride in W direction.
* `[in] stride\_height`: The stride in H direction.
* `[in] value\_index\_stride`: The offset from the beginning of data value to index value in bytes.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* For the output tensor `<dst>[output\_channel, output\_height, output\_width]`, `[output\_channel] = <channel>`, and `[output\_height, output\_width]` are obtained by deducing from `[height, width]`, `[kernel\_height, kernel\_width]` and `[stride\_width, stride\_height]`;
* For the value part of `<dst>`, when `<value\_index\_stride> > 0`, the address operands `<dst>` can be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>`, `<stride\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define DATA\_NUM 64

\_\_mlu\_entry\_\_ void kernel(half \*dst, half \*src, float \*dst\_f, float \*src\_f,
                          int channel, int height, int width, int kernel\_height,
                          int kernel\_width, int stride\_width, int stride\_height,
                          int value\_index\_stride, int in\_dh, int in\_dw,
                          int out\_dh, int out\_dw);
  int datasize = DATA\_NUM \* sizeof(half);
  \_\_nram\_\_ half svc\_dst[DATA\_NUM];
  \_\_nram\_\_ half svc\_src[DATA\_NUM];
  \_\_memcpy(svc\_src, src, datasize, GDRAM2NRAM);
  \_\_bang\_nan\_minpool\_value\_index(svc\_dst, svc\_src, channel, height, width,
                                 kernel\_height, kernel\_width, stride\_width,
                                 stride\_height, value\_index\_stride,
                                 in\_dh, in\_dw, out\_dh, out\_dw);
  \_\_memcpy(dst, svc\_dst, datasize, NRAM2GDRAM);
}

```













3.12.22. \_\_bang\_relu
------------------------




void `__bang_relu`(char \**dst*, *const* char \**src*, unsigned int *elem\_count*)  




void `__bang_relu`(short \**dst*, *const* short \**src*, unsigned int *elem\_count*)  




void `__bang_relu`(int \**dst*, *const* int \**src*, unsigned int *elem\_count*)  




void `__bang_relu`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_relu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_relu`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This instruction performs relu operation on each element in vector `<src>` and saves the result to vector `<dst>`. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short` and `char` are not supported on `tp\_520`;
* `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example**
```
#include <bang.h>

#define DATA\_NUM 64

\_\_mlu\_entry\_\_ void kernel(half \*dst\_h, half \*src\_h) {
  \_\_nram\_\_ half nram\_dst\_h[DATA\_NUM];
  \_\_nram\_\_ half nram\_src\_h[DATA\_NUM];
  \_\_memcpy(nram\_src\_h, src\_h, DATA\_NUM \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_relu(nram\_dst\_h, nram\_src\_h, DATA\_NUM);
  \_\_memcpy(dst\_h, nram\_dst\_h, DATA\_NUM \* sizeof(half), NRAM2GDRAM);
}

```













3.12.23. \_\_bang\_relun
-------------------------




void `__bang_relun`(int \**dst*, *const* int \**src*, unsigned int *elem\_count*, int *nvalue*)  




void `__bang_relun`(short \**dst*, *const* short \**src*, unsigned int *elem\_count*, short *nvalue*)  




void `__bang_relun`(char \**dst*, *const* char \**src*, unsigned int *elem\_count*, char *nvalue*)  




void `__bang_relun`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*, half *nvalue*)  




void `__bang_relun`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*, bfloat16\_t *nvalue*)  




void `__bang_relun`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*, float *nvalue*)  

The instruction performs relun operation on each element in `<src>`. If the element in `<src>` is less than 0, corresponding element in `<dst>` will be `0`. If the element is greater than `<nvalue>`, corresponding element in `<dst>` will be `<nvalue>`. Otherwise, the element in `<dst>` will be itself. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source.
* `[in] nvalue`: The N value of instruction.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short` and `char` are not supported on `tp\_520`;
* `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<nvalue>` must be greater than zero, and cannot be `INF` or `NaN`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example**
```
#include <bang.h>

#define DATA\_NUM 64

\_\_mlu\_entry\_\_ void kernel(half \*dst\_h, half \*src\_h, half const\_h) {
  \_\_nram\_\_ half nram\_dst\_h[DATA\_NUM];
  \_\_nram\_\_ half nram\_src\_h[DATA\_NUM];
  \_\_memcpy(nram\_src\_h, src\_h, DATA\_NUM \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_relun(nram\_dst\_h, nram\_src\_h, DATA\_NUM, const\_h);
  \_\_memcpy(dst\_h, nram\_dst\_h, DATA\_NUM \* sizeof(half), NRAM2GDRAM);
}

```













3.12.24. \_\_bang\_reshape\_filter
-----------------------------------




void `__bang_reshape_filter`(half \**dst*, *const* half \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_filter`(short \**dst*, *const* short \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_filter`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_filter`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_filter`(char \**dst*, *const* char \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_filter`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_filter`(float \**dst*, *const* float \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_filter`(int \**dst*, *const* int \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_filter`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  

Reshapes the vector `<src>` to `<n> / 64` along `n` dimension and suit for `\_\_bang\_mlp()` and `\_\_bang\_conv()`, where the vector `<src>` is in `\_\_nram\_\_` space, then gives the result to the vector `<dst>` in `\_\_nram\_\_` space. 
```
#include <bang.h>

\_\_mlu\_entry\_\_ void MlpKernel(half \*out\_data,
                             int8\_t \*in\_data,
                             int8\_t \*filter\_data,
                             half \*bias\_data,
                             int height,
                             int width,
                             int pos) {
 \_\_nram\_\_ half nram\_out\_data[height];
 \_\_nram\_\_ half nram\_bias\_data[height];
 \_\_nram\_\_ int8\_t nram\_in\_data[width];
 \_\_wram\_\_ int8\_t wram\_filter[height \* width];
 \_\_nram\_\_ int8\_t nram\_filter1[height \* width];
 \_\_nram\_\_ int8\_t nram\_filter2[height \* width];

 \_\_memcpy(nram\_in\_data, in\_data, width \* sizeof(int8\_t), GDRAM2NRAM);
 \_\_memcpy(nram\_bias\_data, bias\_data, height \* sizeof(half), GDRAM2NRAM);
 \_\_memcpy(nram\_filter1, filter\_data, height \* width \* sizeof(int8\_t), GDRAM2NRAM);

 // \_\_bang\_mlp() height means channel output, width means channel input.
 // if filter\_data all ready be shaped on host, don't need reshape again on MLU
 \_\_bang\_reshape\_filter(nram\_filter2, nram\_filter1, height, 1, 1, width);

 \_\_memcpy(wram\_filter, nram\_filter2, height \* width \* sizeof(int8\_t), NRAM2WRAM);
 \_\_bang\_mlp(nram\_out\_data, nram\_in\_data, nram\_bias\_data, wram\_filter, width, width, pos);
 \_\_memcpy(out\_data, nram\_out\_data, height \* sizeof(half), NRAM2GDRAM);
}

```



**Parameters*** `[out] dst`: The address of output kernel whose data layout is `NHWC` .
* `[in] src`: The address of input kernel whose data layout is `NHWC` .
* `[in] n`: The batch number of input kernel, also can represent channel output.
* `[in] h`: The height of input kernel.
* `[in] w`: The width of input kernel.
* `[in] c`: The channel input of kernel.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<n>` must be divisible by 64;
* \(<h> \times <w> \times <c> \times sizeof(type)\) must be divisible by 128 on `(m)tp\_2xx`;
* \(<h> \times <w> \times <c> \times sizeof(type)\) must be divisible by 32 on `(m)tp\_3xx or higher`;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**








3.12.25. \_\_bang\_reshape\_nchw2nhwc
--------------------------------------




void `__bang_reshape_nchw2nhwc`(half \**dst*, *const* half \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nchw2nhwc`(short \**dst*, *const* short \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nchw2nhwc`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nchw2nhwc`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nchw2nhwc`(char \**dst*, *const* char \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nchw2nhwc`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nchw2nhwc`(float \**dst*, *const* float \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nchw2nhwc`(int \**dst*, *const* int \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nchw2nhwc`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  

Reshapes the vector `<src>` from `NCHW` to `NHWC`, where the vector `<src>` is in `\_\_nram\_\_` space and has an order of `NCHW`, then gives the result to the vector `<dst>` in `\_\_nram\_\_` space and has an order of `NHWC`.



**Parameters*** `[out] dst`: The address of output kernel whose data layout is `NHWC` .
* `[in] src`: The address of input kernel whose data layout is `NCHW` .
* `[in] n`: The batch number of input kernel, also can represent channel output..
* `[in] h`: The height of input kernel.
* `[in] w`: The width of input kernel.
* `[in] c`: The channel input of kernel.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* \(<h> \times <w> \times sizeof(type)\) must be divisible by 64;
* \(<c> \times sizeof(type)\) must be divisible by 64;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.12.26. \_\_bang\_reshape\_nhwc2nchw
--------------------------------------




void `__bang_reshape_nhwc2nchw`(half \**dst*, *const* half \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nhwc2nchw`(short \**dst*, *const* short \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nhwc2nchw`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nhwc2nchw`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nhwc2nchw`(char \**dst*, *const* char \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nhwc2nchw`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nhwc2nchw`(float \**dst*, *const* float \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nhwc2nchw`(int \**dst*, *const* int \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  




void `__bang_reshape_nhwc2nchw`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *n*, unsigned int *h*, unsigned int *w*, unsigned int *c*)  

Reshapes the vector `<src>` from `NHWC` to `NCHW`, where the vector `<src>` is in `\_\_nram\_\_` space and has an order of `NHWC`, then gives the result to the vector `<dst>` in `\_\_nram\_\_` space and has an order of `NCHW` .



**Parameters*** `[out] dst`: The address of output kernel whose data layout is `NCHW` .
* `[in] src`: The address of input kernel whose data layout is `NHWC` .
* `[in] n`: The batch number of input kernel, also can represent channel output.
* `[in] h`: The height of input kernel.
* `[in] w`: The width of input kernel.
* `[in] c`: The channel input of kernel.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* \(<h> \times <w> \times sizeof(type)\) must be divisible by 64;
* \(<c> \times sizeof(type)\) must be divisible by 64;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.12.27. \_\_bang\_ssparse\_filter\_index
------------------------------------------




void `__bang_ssparse_filter_index`(half \**dst*, *const* half \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_index`(float \**dst*, *const* float \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_index`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_index`(int16\_t \**dst*, *const* int16\_t \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_index`(int \**dst*, *const* int \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  

Selects 2 elements with larger absolute value from every 4 elements of `<src>` and stores the index of selected elements in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] input\_channel`: The number of input channel of source vector.
* `[in] src\_height`: The height of source vector.
* `[in] src\_width`: The width of source vector.
* `[in] output\_channel`: The number of channel of destination vector.



**Return*** `void`






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<src>` is split by 8 elements on `input\_channel` dimension. When the split part is less than 8 elements, hardware will pad to 8 elements with zero;
* Each bit in index corresponds to one element in `<src>`;
* There is no alignment constraint for parameter `<input\_channel>`, but the size of `input\_channel` dimension of `<dst>` must align to `ceil(<input\_channel> / (8 \* (sizeof(typeof(<src>)))))` byte(s).






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include "bang.h"

#define SRC\_CHANNEL\_BYTES (2 \* 128)
#define KERNEL\_HEIGHT 2
#define KERNEL\_WIDTH 3
#define DST\_CHANNEL 4
#define INPUT\_BYTES (SRC\_CHANNEL\_BYTES \* KERNEL\_HEIGHT \* KERNEL\_WIDTH \* DST\_CHANNEL)
#define OUTPUT\_BYTES ((INPUT\_BYTES) / 4)
#define TOTAL\_INPUT\_BYTES ((INPUT\_BYTES)\*2)
#define TOTAL\_OUTPUT\_BYTES ((OUTPUT\_BYTES)\*2)

\_\_mlu\_global\_\_ void kernel\_ssparse\_filter\_index(bfloat16\_t\* dst, bfloat16\_t\* src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[TOTAL\_OUTPUT\_BYTES / sizeof(bfloat16\_t)];
  \_\_nram\_\_ bfloat16\_t src\_nram[TOTAL\_INPUT\_BYTES / sizeof(bfloat16\_t)];

  \_\_memcpy(src\_nram, src, TOTAL\_INPUT\_BYTES, GDRAM2NRAM);

  \_\_bang\_ssparse\_filter\_index(dst\_nram, src\_nram, SRC\_CHANNEL\_BYTES,
                              KERNEL\_HEIGHT, KERNEL\_WIDTH, DST\_CHANNEL);
  \_\_bang\_ssparse\_filter\_index(
      dst\_nram + (INPUT\_BYTES / (sizeof(bfloat16\_t) \* 8 \* sizeof(bfloat16\_t))),
      src\_nram + (INPUT\_BYTES / sizeof(bfloat16\_t)), SRC\_CHANNEL\_BYTES, KERNEL\_HEIGHT,
      KERNEL\_WIDTH, DST\_CHANNEL);

  \_\_memcpy(dst, dst\_nram, TOTAL\_OUTPUT\_BYTES, NRAM2GDRAM);
}

```













3.12.28. \_\_bang\_ssparse\_filter\_sparse\_index
--------------------------------------------------




void `__bang_ssparse_filter_sparse_index`(half \**dst*, *const* half \**src*, *const* half \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_sparse_index`(float \**dst*, *const* float \**src*, *const* float \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_sparse_index`(int8\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_sparse_index`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_sparse_index`(int \**dst*, *const* int \**src*, *const* int \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_sparse_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  

Selects 2 elements based on `<index>` from every 4 elements of `<src>`, sets the unselected elements to zero and stores the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] index`: The address of index vector.
* `[in] input\_channel`: The number of input channel of source vector.
* `[in] src\_height`: The height of source vector.
* `[in] src\_width`: The width of source vector.
* `[in] output\_channel`: The number of channel of destination vector.



**Return*** `void`






**Remark*** `<dst>`, `<src>` and `<index>` must point to `\_\_nram\_\_` address space;
* Each bit in `<index>` corresponds to one element in `<src>`;
* `<dst>` and `<src>` have the same `<input\_channel>` dimension size;
* The byte size of `<input\_channel>` dimension of `<index>` equals `ceil(<input\_channel> / bit\_size(typeof(<src>)))`;
* If `<index>` is split by 4 bits and some parts do not belong to `{4'b0011, 4'b0101, 4'b1001, 4'b0110, 4'b1010, 4'b1100}`, hardware will set illegal parts to `4'b0011` to keep the propram running.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include "bang.h"

#define SRC\_CHANNEL\_BYTES (2 \* 128)
#define KERNEL\_HEIGHT 1
#define KERNEL\_WIDTH 1
#define DST\_CHANNEL 1

#define INPUT\_BYTES ((SRC\_CHANNEL\_BYTES) \* (KERNEL\_HEIGHT) \* (KERNEL\_WIDTH) \* (DST\_CHANNEL))
#define OUTPUT\_BYTES (INPUT\_BYTES)

#define TOTAL\_INPUT\_BYTES (2 \* (INPUT\_BYTES))
#define TOTAL\_OUTPUT\_BYTES (2 \* (OUTPUT\_BYTES))

\_\_mlu\_global\_\_ void kernel(bfloat16\_t\* dst, bfloat16\_t\* src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[TOTAL\_OUTPUT\_BYTES / sizeof(bfloat16\_t)];
  \_\_nram\_\_ bfloat16\_t src\_nram[TOTAL\_INPUT\_BYTES / sizeof(bfloat16\_t)];
  \_\_nram\_\_ bfloat16\_t idx\_nram[TOTAL\_INPUT\_BYTES / sizeof(bfloat16\_t) / 4];

  \_\_memcpy(src\_nram, src, TOTAL\_INPUT\_BYTES, GDRAM2NRAM);

  \_\_bang\_ssparse\_filter\_index(idx\_nram,
                              src\_nram,
                              SRC\_CHANNEL\_BYTES,
                              SRC\_HEIGHT,
                              SRC\_WIDTH,
                              DST\_CHANNEL);

  \_\_bang\_ssparse\_filter\_sparse\_index(dst\_nram,
                                     src\_nram,
                                     idx\_nram,
                                     SRC\_CHANNEL\_BYTES,
                                     SRC\_HEIGHT,
                                     SRC\_WIDTH,
                                     DST\_CHANNEL);
  \_\_bang\_ssparse\_filter\_index(
      (bfloat16\_t\*)((char\*)(idx\_nram) + INPUT\_BYTES / (sizeof(bfloat16\_t) \* 8)),
      (bfloat16\_t\*)((char\*)(src\_nram) + INPUT\_BYTES), SRC\_CHANNEL\_BYTES, KERNEL\_HEIGHT,
      KERNEL\_WIDTH, DST\_CHANNEL);
  \_\_bang\_ssparse\_filter\_sparse\_index(
      (bfloat16\_t\*)((char\*)(dst\_nram) + OUTPUT\_BYTES),
      (bfloat16\_t\*)((char\*)(src\_nram) + INPUT\_BYTES),
      (bfloat16\_t\*)((char\*)(idx\_nram) + (INPUT\_BYTES / (sizeof(bfloat16\_t) \* 8))),
      SRC\_CHANNEL\_BYTES, KERNEL\_HEIGHT, KERNEL\_WIDTH, DST\_CHANNEL);
  \_\_memcpy(dst, dst\_nram, TOTAL\_OUTPUT\_BYTES, NRAM2GDRAM);
}

```













3.12.29. \_\_bang\_ssparse\_filter\_union
------------------------------------------




void `__bang_ssparse_filter_union`(half \**dst*, *const* half \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union`(float \**dst*, *const* float \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union`(int16\_t \**dst*, *const* int16\_t \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union`(int \**dst*, *const* int \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  

Selects 2 elements with larger absolute value from every 4 elements of `<src>` and stores the selected elements and corresponding indexes in `<dst>` in form of 96-byte structure. Each structure consists of 64-byte data and 32-byte index.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] input\_channel`: The number of input channel of source vector.
* `[in] src\_height`: The height of source vector.
* `[in] src\_width`: The width of source vector.
* `[in] output\_channel`: The number of channel of destination vector.



**Return*** `void`






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<src>` is split by 128 bytes on `input\_channel` dimension. When the split part is less than 128 bytes, hardware will pad to 128 bytes with zero;
* Each bit in index corresponds to 4 bits in `<src>`. If one bit is 1 in output index, that means its corresponding 4 bits in `<src>` are selected;
* There is no alignment constraint for parameter `<input\_channel>`, but the size of `input\_channel` dimension of `<dst>` must align to `(ceil(<input\_channel> / 128) \* 96)` byte(s).






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include "bang.h"

#define SRC\_CHANNEL\_BYTES (2 \* 128)
#define KERNEL\_HEIGHT 1
#define KERNEL\_WIDTH 1
#define DST\_CHANNEL 1
#define INPUT\_BYTES \
  ((SRC\_CHANNEL\_BYTES) \* (KERNEL\_HEIGHT) \* (KERNEL\_WIDTH) \* (DST\_CHANNEL))
#define OUTPUT\_BYTES ((INPUT\_BYTES) / 128 \* 96)
#define TOTAL\_INPUT\_BYTES (2 \* (INPUT\_BYTES))
#define TOTAL\_OUTPUT\_BYTES (2 \* (OUTPUT\_BYTES))

\_\_mlu\_global\_\_ void kernel\_ssparse\_filter\_union(bfloat16\_t\* dst, bfloat16\_t\* src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[TOTAL\_OUTPUT\_BYTES / sizeof(bfloat16\_t)];
  \_\_nram\_\_ bfloat16\_t src\_nram[TOTAL\_INPUT\_BYTES / sizeof(bfloat16\_t)];
  \_\_memcpy(src\_nram, src, TOTAL\_INPUT\_BYTES, GDRAM2NRAM);
  \_\_bang\_ssparse\_filter\_union(static\_cast<bfloat16\_t\*>(dst\_nram),
                              static\_cast<bfloat16\_t\*>(src\_nram), SRC\_CHANNEL\_BYTES,
                              KERNEL\_HEIGHT, KERNEL\_WIDTH, DST\_CHANNEL);
  \_\_bang\_ssparse\_filter\_union(
      static\_cast<bfloat16\_t\*>(&dst\_nram[OUTPUT\_BYTES / sizeof(bfloat16\_t)]),
      static\_cast<bfloat16\_t\*>(&src\_nram[INPUT\_BYTES / sizeof(bfloat16\_t)]), SRC\_CHANNEL\_BYTES,
      KERNEL\_HEIGHT, KERNEL\_WIDTH, DST\_CHANNEL);
  \_\_memcpy(dst, dst\_nram, TOTAL\_OUTPUT\_BYTES, NRAM2GDRAM);
}

```













3.12.30. \_\_bang\_ssparse\_filter\_union\_index
-------------------------------------------------




void `__bang_ssparse_filter_union_index`(half \**dst*, *const* half \**src*, *const* half \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union_index`(float \**dst*, *const* float \**src*, *const* float \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union_index`(int8\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union_index`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union_index`(int \**dst*, *const* int \**src*, *const* int \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  




void `__bang_ssparse_filter_union_index`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**index*, unsigned int *input\_channel*, unsigned int *src\_height*, unsigned int *src\_width*, unsigned int *output\_channel*)  

Selects 2 elements based on `<index>` from every 4 elements of `<src>` and stores the selected elements and corresponding indexes in `<dst>` in form of 96-byte structure. Each structure consists of 64-byte data and 32-byte index.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] index`: The address of index vector.
* `[in] input\_channel`: The number of input channel of source vector.
* `[in] src\_height`: The height of source vector.
* `[in] src\_width`: The width of source vector.
* `[in] output\_channel`: The number of channel of destination vector.



**Return*** `void`.






**Remark*** `<dst>`, `<src>` and `<index>` must point to `\_\_nram\_\_` address space;
* Each bit in `<index>` corresponds to one element in `<src>`;
* Each bit in output index corresponds to 4 bits in `<src>`. If one bit is 1 in output index, its corresponding 4 bits in `<src>` are selected;
* There is no alignment constraint for parameter `<input\_channel>`, but the size of `input\_channel` dimension of `<dst>` must align to 96 bytes;
* The data part of `<dst>` should be 64-byte aligned. Otherwise, hardware will pad to 64 bytes with zero;
* The index part of `<dst>` should be 32-byte aligned. Otherwise,
	+ If `bit\_size(<type>) == 4`, hardware will pad to 32 bytes with `4'b0011`.
	+ If `bit\_size(<type>) == 8`, hardware will pad to 32 bytes with `8'b0000\_1111`.
	+ If `bit\_size(<type>) == 16`, hardware will pad to 32 bytes with `16'b0000\_0000\_1111\_1111`.
	+ If `bit\_size(<type>) == 32`, hardware will pad to 32 bytes with `32'b0000\_0000\_0000\_0000\_1111\_1111\_1111\_1111`;
* Split `<index>` by 4 bits and set illegal parts, which do not belong to `{4'b0011, 4'b0101, 4'b1001, 4'b0110, 4'b1010, 4'b1100}`, to `4'b0011`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include "bang.h"

#define SRC\_CHANNEL\_BYTES (2 \* 128)
#define KERNEL\_HEIGHT 1
#define KERNEL\_WIDTH 1
#define DST\_CHANNEL 1
#define INPUT\_BYTES \
  ((SRC\_CHANNEL\_BYTES) \* (KERNEL\_HEIGHT) \* (KERNEL\_WIDTH) \* (DST\_CHANNEL))
#define OUTPUT\_BYTES ((INPUT\_BYTES) / 128 \* 96)
#define TOTAL\_INPUT\_BYTES (2 \* (INPUT\_BYTES))
#define TOTAL\_OUTPUT\_BYTES (2 \* (OUTPUT\_BYTES))

\_\_mlu\_global\_\_ void kernel\_ssparse\_filter\_union\_index(bfloat16\_t\* dst, bfloat16\_t\* src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[TOTAL\_OUTPUT\_BYTES / sizeof(bfloat16\_t)];
  \_\_nram\_\_ bfloat16\_t src\_nram[TOTAL\_INPUT\_BYTES / sizeof(bfloat16\_t)];
  \_\_nram\_\_ bfloat16\_t idx\_nram[TOTAL\_INPUT\_BYTES / sizeof(bfloat16\_t) / 4];
  \_\_memcpy(src\_nram, src, TOTAL\_INPUT\_BYTES, GDRAM2NRAM);
  \_\_bang\_ssparse\_filter\_index(static\_cast<bfloat16\_t\*>(idx\_nram),
                              static\_cast<bfloat16\_t\*>(src\_nram), SRC\_CHANNEL\_BYTES,
                              KERNEL\_HEIGHT, KERNEL\_WIDTH, DST\_CHANNEL);
  \_\_bang\_ssparse\_filter\_union\_index(
      static\_cast<bfloat16\_t\*>(dst\_nram), static\_cast<bfloat16\_t\*>(src\_nram),
      static\_cast<bfloat16\_t\*>(idx\_nram), SRC\_CHANNEL\_BYTES, KERNEL\_HEIGHT, KERNEL\_WIDTH,
      DST\_CHANNEL);
  \_\_bang\_ssparse\_filter\_index(
      (bfloat16\_t\*)((char\*)(idx\_nram) + INPUT\_BYTES / (sizeof(bfloat16\_t) \* 8)),
      (bfloat16\_t\*)((char\*)(src\_nram) + INPUT\_BYTES), SRC\_CHANNEL\_BYTES, KERNEL\_HEIGHT,
      KERNEL\_WIDTH, DST\_CHANNEL);
  \_\_bang\_ssparse\_filter\_union\_index(
      (bfloat16\_t\*)((char\*)(dst\_nram) + OUTPUT\_BYTES),
      (bfloat16\_t\*)((char\*)(src\_nram) + INPUT\_BYTES),
      (bfloat16\_t\*)((char\*)(idx\_nram) + (INPUT\_BYTES / (sizeof(bfloat16\_t) \* 8))),
      SRC\_CHANNEL\_BYTES, KERNEL\_HEIGHT, KERNEL\_WIDTH, DST\_CHANNEL);
  \_\_memcpy(dst, dst\_nram, TOTAL\_OUTPUT\_BYTES, NRAM2GDRAM);
}

```













3.12.31. \_\_bang\_sumpool
---------------------------




void `__bang_sumpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*)  




void `__bang_sumpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_sumpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_sumpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  

Applies sumpooling forward operation on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and saves the sum in each window. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded.



**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: Stride of W direction.
* `[in] stride\_height`: Stride of H direction.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>` and `<kernel\_width>` must be greater than 0;
* `<stride\_height>` and `<stride\_width>` must be greater than 0 if specified;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\).






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define CHANNELS 64
#define IN\_HEIGHT 9
#define IN\_WIDTH 9
#define KERNEL\_HEIGHT 3
#define KERNEL\_WIDTH 3
#define STRIDE\_X 1
#define STRIDE\_Y 1
#define INPUT\_COUNT ((CHANNELS) \* (IN\_WIDTH) \* (IN\_HEIGHT))
#define OUTPUT\_COUNT \
  ((CHANNELS) \* ((IN\_HEIGHT - KERNEL\_HEIGHT) / STRIDE\_Y + 1) \* \
  ((IN\_WIDTH - KERNEL\_WIDTH) / STRIDE\_X + 1))

\_\_mlu\_entry\_\_ void PoolSumKernel(half\* output, half\* input) {
  \_\_nram\_\_ half a\_tmp[INPUT\_COUNT];
  \_\_nram\_\_ half b\_tmp[OUTPUT\_COUNT];
  \_\_memcpy(a\_tmp, input, INPUT\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_sumpool(b\_tmp, a\_tmp, CHANNELS, IN\_HEIGHT, IN\_WIDTH,
                 KERNEL\_HEIGHT, KERNEL\_WIDTH, STRIDE\_X, STRIDE\_Y);
  \_\_memcpy(output, b\_tmp, OUTPUT\_COUNT \* sizeof(half), NRAM2GDRAM);
}

```













3.12.32. \_\_bang\_sumpool\_bp
-------------------------------




void `__bang_sumpool_bp`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  




void `__bang_sumpool_bp`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  




void `__bang_sumpool_bp`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  

Performs sumpooling backward propagation operation on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and calculates the sum value in each window. `<overlap>` indicates the type of overlap options. `<overlap>` is assigned to an enumerated type called `mluPoolBPOverlap` that contains 2 enumerators listed in the table below. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded.




Table 3.30 Semantics of `mluPoolBPOverlap`



| `mluPoolBPOverlap` Type | Semantic |
| --- | --- |
| `OVERLAP\_ACC` | Accumulates the overlap parts of the output. |
| `OVERLAP\_COVER` | Covers the overlap parts of the output. |








See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of output feature map.
* `[in] width`: The width of output feature map.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] overlap`: The type of overlap options.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* The default `mluPoolBPOverlap` option is `OVERLAP\_ACC`;
* `[input\_height]` and `[input\_width]` of `<src>` must be greater than 0;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>` and `<stride\_width>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\).
* This function was deprecated from CNCC v4.5.0. Use \_\_bang\_sumpool\_bp and \_\_bang\_cycle\_mul instead on (m)tp\_2xx or use \_\_bang\_sumpool\_bp and \_\_bang\_mul\_scalar instead on (m)tp\_3xx or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
 #include <bang.h>

 \_\_mlu\_entry\_\_ void PoolSumBpKernel(half\* output, half\* input,
                                    unsigned int channels, int out\_height,
                                    unsigned int out\_width, int kernel\_height,
                                    unsigned int kernel\_width, int stride\_width,
                                    unsigned int stride\_height) {
   \_\_nram\_\_ half a\_tmp[INPUT\_COUNT];
   \_\_nram\_\_ half b\_tmp[OUTPUT\_COUNT];
   \_\_memcpy(b\_tmp, output, OUTPUT\_COUNT \* sizeof(half), GDRAM2NRAM);
   \_\_memcpy(a\_tmp, input, INPUT\_COUNT \* sizeof(half), GDRAM2NRAM);
   \_\_bang\_sumpool\_bp(b\_tmp, a\_tmp, channels, out\_height, out\_width,
                     kernel\_height, kernel\_width, stride\_width,
                     stride\_height);
   \_\_memcpy(output, b\_tmp, OUTPUT\_COUNT \* sizeof(half), NRAM2GDRAM);
}

```













3.12.33. \_\_bang\_unpool
--------------------------




void `__bang_unpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *index*)  




void `__bang_unpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *index*)  




void `__bang_unpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *index*)  

Applies unpooling backward operation on `<src>`, a tensor. Every element of `<src>` tensor corresponds to a kernel window on `<dst>` tensor operand. The elements of `<src>` tensor is written into `<index>`th position in that kernel window on `<dst>` tensor, and other positions in the kernel window are written zero.


The Figure Process of Unpool Operation shows an example with the following parameters, `height = 5`, `width = 5`, `kernel\_height = 2`, `kernel\_width = 2`, `stride\_height = 3`, `stride\_width = 3`, `input\_height = 2`, `input\_width = 2`, and `index = 1`.



![../_images/11.3.png](../_images/11.3.png)

Fig. 3.4 Process of Unpool Operation












**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of output feature map.
* `[in] width`: The width of output feature map.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: W direction of stride.
* `[in] stride\_height`: H direction of stride.
* `[in] index`: Index within kernel window.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The shape of `<dst>` tensor [`<height>`, `<width>`, `out\_channel`] and `<src>` tensor [`input\_height`, `input\_width`, `<channel>`] has following restrictions: \(<height> = (input\\_height  1) \* <stride\\_height> + <kernel\\_height>\), \(<width> = (input\\_width  1) \* <stride\\_width> + <kernel\\_width>\), \(out\\_channel = <channel>\);
* The `<index>`th position in kernel window means ikhth row and ikwth column in kernel window, where (ikh \* `<kernel\_width>` + ikw = `<index>`);
* If `<stride\_width>` > `<kernel\_width>` or `<stride\_height>` > `<kernel\_height>`, the elements in `<dst>` that do not belong to any kernel window remain unchanged;
* `<dst>` cannot be overlapped with `<src>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>` and `<stride\_width>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\).






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define CHANNELS 128
#define HEIGHT 6
#define WIDTH 4
#define KERNEL\_HEIGHT 3
#define KERNEL\_WIDTH 2
#define STRIDE\_X 2
#define STRIDE\_Y 3
#define INDEX\_IN\_KERNEL 2
#define H\_SMALL ((HEIGHT-KERNEL\_HEIGHT)/STRIDE\_Y+1)
#define W\_SMALL ((WIDTH-KERNEL\_WIDTH)/STRIDE\_X+1)
#define TOP\_DATA\_COUNT ((CHANNELS) \* (WIDTH) \* (HEIGHT))
#define BOTTOM\_DATA\_COUNT ((CHANNELS) \* H\_SMALL \* W\_SMALL)

\_\_mlu\_entry\_\_ void UnPoolKernel(half\* top\_data, int16\_t\* bottom\_data,
                                int channels, int height, int width,
                                int kh, int kw, int sx, int sy,
                                int index\_in\_kernel) {
  \_\_nram\_\_ half a\_tmp[BOTTOM\_DATA\_COUNT];
  \_\_nram\_\_ half b\_tmp[TOP\_DATA\_COUNT];
  \_\_memcpy(a\_tmp, bottom\_data, BOTTOM\_DATA\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, top\_data, TOP\_DATA\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_unpool(b\_tmp, a\_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL\_HEIGHT,
                KERNEL\_WIDTH, sx, sy, index\_in\_kernel);
  \_\_memcpy(top\_data, b\_tmp, TOP\_DATA\_COUNT \* sizeof(half), NRAM2GDRAM);
}

```

















3.13. Atomic Functions
=======================



3.13.1. \_\_bang\_atomic\_add
------------------------------




void `__bang_atomic_add`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_add`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_add`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_add`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  




void `__bang_atomic_add`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_add`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_add`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Copies `<src1>` to `<dst>`, adds `<src2>` to `<src1>` element-wisely. That is: `<dst>` = `<src1>`; `<src1>` = `<src1>` + `<src2>`. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector;
* `<size>` must be greater than zero;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short\* src1, short src2) {
  \_\_nram\_\_ short v[64];
  \_\_bang\_atomic\_add(v, src1, src2, 64);
}

```













3.13.2. \_\_bang\_atomic\_add\_async
-------------------------------------




void `__bang_atomic_add_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add_async`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add_async`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_add_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_add_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_add_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_add_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  




void `__bang_atomic_add_async`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_add_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_add_async`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Copies `<src1>` to `<dst>`, adds `<src2>` to `<src1>` element-wisely. That is: `<dst>` = `<src1>`; `<src1>` = `<src1>` + `<src2>`. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector;
* `<size>` must be greater than zero;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short\* src1, short src2) {
  \_\_nram\_\_ short v[64];
  \_\_bang\_atomic\_add\_async(v, src1, src2, 64);
}

```













3.13.3. \_\_bang\_atomic\_and
------------------------------




void `__bang_atomic_and`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_and`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_and`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_and`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_and`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_and`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_and`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_and`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Applies bitwise AND operation to the vector `<src1>` and `<src2>`, stores the result in `<src1>`, and stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = `<src1>` & `<src2>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.4. \_\_bang\_atomic\_and\_async
-------------------------------------




void `__bang_atomic_and_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_and_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_and_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_and_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_and_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_and_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_and_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_and_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Applies bitwise AND operation to the vector `<src1>` and `<src2>`, stores the result in `<src1>`, and stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = `<src1>` & `<src2>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.5. \_\_bang\_atomic\_cas
------------------------------




void `__bang_atomic_cas`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned short *src3*)  




void `__bang_atomic_cas`(short \**dst*, short \**src1*, short *src2*, short *src3*)  




void `__bang_atomic_cas`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *src3*)  




void `__bang_atomic_cas`(float \**dst*, float \**src1*, float *src2*, float *src3*)  




void `__bang_atomic_cas`(half \**dst*, half \**src1*, half *src2*, half *src3*)  




void `__bang_atomic_cas`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, bfloat16\_t *src3*)  




void `__bang_atomic_cas`(int \**dst*, int \**src1*, int *src2*, int *src3*)  

If `<src2>` is equal to `<\*src1>`, stores `<src3>` in `<src1>`. Stores the original value of `<\*src1>` in `<dst>`. That is: `<\*dst>` = `<\*src1>`; `<\*src1>` = (`<\*src1>` == `<src2>`) ? `<src3>` : `<\*src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1`: The address of first operand.
* `[in] src2`: The second operand.
* `[in] src3`: The third operand.



**Return*** `void`.






**Remark*** This function only operates on one element;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `bfloat16\_t`, `float` and `half` are supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short\* src1, short src2, short src3) {
  \_\_nram\_\_ short v;
  \_\_bang\_atomic\_cas(&v, src1, src2, src3);
}

```













3.13.6. \_\_bang\_atomic\_cas\_async
-------------------------------------




void `__bang_atomic_cas_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned short *src3*)  




void `__bang_atomic_cas_async`(short \**dst*, short \**src1*, short *src2*, short *src3*)  




void `__bang_atomic_cas_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *src3*)  




void `__bang_atomic_cas_async`(float \**dst*, float \**src1*, float *src2*, float *src3*)  




void `__bang_atomic_cas_async`(half \**dst*, half \**src1*, half *src2*, half *src3*)  




void `__bang_atomic_cas_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, bfloat16\_t *src3*)  




void `__bang_atomic_cas_async`(int \**dst*, int \**src1*, int *src2*, int *src3*)  

If `<src2>` is equal to `<\*src1>`, stores `<src3>` in `<src1>`. Stores the original value of `<\*src1>` in `<dst>`. That is: `<\*dst>` = `<\*src1>`; `<\*src1>` = (`<\*src1>` == `<src2>`) ? `<src3>` : `<\*src1>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1`: The address of first operand.
* `[in] src2`: The second operand.
* `[in] src3`: The third operand.



**Return*** `void`.






**Remark*** This function only operates on one element;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `bfloat16\_t`, `float` and `half` are supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short\* src1, short src2, short src3) {
  \_\_nram\_\_ short v;
  \_\_bang\_atomic\_cas\_async(&v, src1, src2, src3);
}

```













3.13.7. \_\_bang\_atomic\_dec
------------------------------




void `__bang_atomic_dec`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_dec`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_dec`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_dec`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_dec`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_dec`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_dec`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_dec`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Compares vector `<src1>` and `<src2>` element-wisely. If `<src1>` is larger than `<src2>`, or the value of `<src1>` is 0, stores the int value `<src2>` in `<src1>`; otherwise, subtracts `<src1>` by 1. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` == 0 || `<src1>` > `<src2>`) ? `<src2>` : (`<src1>` - 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* `<size>` must be greater than zero;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.8. \_\_bang\_atomic\_dec\_async
-------------------------------------




void `__bang_atomic_dec_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_dec_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_dec_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_dec_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_dec_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_dec_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_dec_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_dec_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Compares vector `<src1>` and `<src2>` element-wisely. If `<src1>` is larger than `<src2>`, or the value of `<src1>` is 0, stores the int value `<src2>` in `<src1>`; otherwise, subtracts `<src1>` by 1. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` == 0 || `<src1>` > `<src2>`) ? `<src2>` : (`<src1>` - 1). All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* `<size>` must be greater than zero;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.9. \_\_bang\_atomic\_exch
-------------------------------




void `__bang_atomic_exch`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_exch`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_exch`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_exch`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  




void `__bang_atomic_exch`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_exch`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_exch`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Stores vector `<src1>` in `<dst>`. Stores `<src2>` in `<src1>`. That is: `<dst>` = `<src1>`; `<src1>` = `<src2>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<size>` must be greater than zero;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.10. \_\_bang\_atomic\_exch\_async
---------------------------------------




void `__bang_atomic_exch_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch_async`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch_async`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_exch_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_exch_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_exch_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_exch_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  




void `__bang_atomic_exch_async`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_exch_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_exch_async`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Stores vector `<src1>` in `<dst>`. Stores `<src2>` in `<src1>`. That is: `<dst>` = `<src1>`; `<src1>` = `<src2>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<size>` must be greater than zero;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.11. \_\_bang\_atomic\_inc
-------------------------------




void `__bang_atomic_inc`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_inc`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_inc`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_inc`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_inc`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_inc`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_inc`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_inc`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Compares vector `<src1>` and `<src2>` element-wisely. If `<src1>` is smaller than `<src2>`, increases `<src1>` by 1; otherwise, sets `<src1>` to 0. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` >= `<src2>`) ? 0 : (`<src1>` + 1). All steps are inseparable.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.12. \_\_bang\_atomic\_inc\_async
--------------------------------------




void `__bang_atomic_inc_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_inc_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_inc_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_inc_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_inc_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_inc_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_inc_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_inc_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Compares vector `<src1>` and `<src2>` element-wisely. If `<src1>` is smaller than `<src2>`, increases `<src1>` by 1; otherwise, sets `<src1>` to 0. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` >= `<src2>`) ? 0 : (`<src1>` + 1). All steps are inseparable.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.13. \_\_bang\_atomic\_max
-------------------------------




void `__bang_atomic_max`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_max`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_max`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_max`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  




void `__bang_atomic_max`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_max`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_max`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

element-wisely stores the larger value of vector `<src1>` and `<src2>` in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` > `<src2>`) ? `<src1>` : `<src2>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.14. \_\_bang\_atomic\_max\_async
--------------------------------------




void `__bang_atomic_max_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max_async`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max_async`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_max_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_max_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_max_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_max_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  




void `__bang_atomic_max_async`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_max_async`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

element-wisely stores the larger value of vector `<src1>` and `<src2>` in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` > `<src2>`) ? `<src1>` : `<src2>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.15. \_\_bang\_atomic\_min
-------------------------------




void `__bang_atomic_min`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_min`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_min`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_min`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  




void `__bang_atomic_min`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_min`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_min`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Takes the smaller value from two vector values `<src1>` and `<src2>`, and stores it in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` < `<src2>`) ? `<src1>` : `<src2>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.16. \_\_bang\_atomic\_min\_async
--------------------------------------




void `__bang_atomic_min_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min_async`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min_async`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_min_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_min_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_min_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_min_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  




void `__bang_atomic_min_async`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_min_async`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Takes the smaller value from two vector values `<src1>` and `<src2>`, and stores it in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` < `<src2>`) ? `<src1>` : `<src2>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.17. \_\_bang\_atomic\_nan\_max
------------------------------------




void `__bang_atomic_nan_max`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_max`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_max`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_max`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_nan_max`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_nan_max`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

element-wisely stores the larger value of vector `<src1>` and `<src2>` in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` > `<src2>`) ? `<src1>` : `<src2>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.18. \_\_bang\_atomic\_nan\_max\_async
-------------------------------------------




void `__bang_atomic_nan_max_async`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_max_async`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_max_async`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_nan_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_nan_max_async`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

element-wisely stores the larger value of vector `<src1>` and `<src2>` in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` > `<src2>`) ? `<src1>` : `<src2>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.19. \_\_bang\_atomic\_nan\_min
------------------------------------




void `__bang_atomic_nan_min`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_min`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_min`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_min`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_nan_min`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_nan_min`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Takes the smaller value from two vector values `<src1>` and `<src2>`, and stores it in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` < `<src2>`) ? `<src1>` : `<src2>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.20. \_\_bang\_atomic\_nan\_min\_async
-------------------------------------------




void `__bang_atomic_nan_min_async`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_min_async`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_nan_min_async`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_nan_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_nan_min_async`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Takes the smaller value from two vector values `<src1>` and `<src2>`, and stores it in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` < `<src2>`) ? `<src1>` : `<src2>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.21. \_\_bang\_atomic\_number\_max
---------------------------------------




void `__bang_atomic_number_max`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_max`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_max`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_max`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_number_max`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_number_max`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

element-wisely stores the larger value of vector `<src1>` and `<src2>` in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` > `<src2>`) ? `<src1>` : `<src2>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.22. \_\_bang\_atomic\_number\_max\_async
----------------------------------------------




void `__bang_atomic_number_max_async`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_max_async`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_max_async`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_number_max_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_number_max_async`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

element-wisely stores the larger value of vector `<src1>` and `<src2>` in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` > `<src2>`) ? `<src1>` : `<src2>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.23. \_\_bang\_atomic\_number\_min
---------------------------------------




void `__bang_atomic_number_min`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_min`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_min`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_min`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_number_min`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_number_min`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Takes the smaller value from two vector values `<src1>` and `<src2>`, and stores it in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` < `<src2>`) ? `<src1>` : `<src2>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.24. \_\_bang\_atomic\_number\_min\_async
----------------------------------------------




void `__bang_atomic_number_min_async`(half \**dst*, half \**src1*, half *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_min_async`(float \**dst*, float \**src1*, float *src2*, unsigned int *size* = 1)  




void `__bang_atomic_number_min_async`(half \**dst*, half \**src1*, *const* half \**src2*, unsigned int *size*)  




void `__bang_atomic_number_min_async`(bfloat16\_t \**dst*, bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_atomic_number_min_async`(float \**dst*, float \**src1*, *const* float \**src2*, unsigned int *size*)  

Takes the smaller value from two vector values `<src1>` and `<src2>`, and stores it in `<src1>`. Stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = (`<src1>` < `<src2>`) ? `<src1>` : `<src2>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<size>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.25. \_\_bang\_atomic\_or
------------------------------




void `__bang_atomic_or`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_or`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_or`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_or`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_or`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_or`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_or`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_or`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Applies bitwise OR operation to vector `<src1>` and `<src2>`, stores the result in `<src1>`, and stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = `<src1>` | `<src2>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.26. \_\_bang\_atomic\_or\_async
-------------------------------------




void `__bang_atomic_or_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_or_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_or_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_or_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_or_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_or_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_or_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_or_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Applies bitwise OR operation to vector `<src1>` and `<src2>`, stores the result in `<src1>`, and stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = `<src1>` | `<src2>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.27. \_\_bang\_atomic\_xor
-------------------------------




void `__bang_atomic_xor`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_xor`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_xor`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_xor`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_xor`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_xor`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_xor`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_xor`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Applies bitwise XOR operation to vector `<src1>` and `<src2>`, stores the result in `<src1>`, and stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = `<src1>` ^ `<src2>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.













3.13.28. \_\_bang\_atomic\_xor\_async
--------------------------------------




void `__bang_atomic_xor_async`(unsigned short \**dst*, unsigned short \**src1*, unsigned short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_xor_async`(short \**dst*, short \**src1*, short *src2*, unsigned int *size* = 1)  




void `__bang_atomic_xor_async`(unsigned int \**dst*, unsigned int \**src1*, unsigned int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_xor_async`(int \**dst*, int \**src1*, int *src2*, unsigned int *size* = 1)  




void `__bang_atomic_xor_async`(unsigned short \**dst*, unsigned short \**src1*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_atomic_xor_async`(short \**dst*, short \**src1*, *const* short \**src2*, unsigned int *size*)  




void `__bang_atomic_xor_async`(unsigned int \**dst*, unsigned int \**src1*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_atomic_xor_async`(int \**dst*, int \**src1*, *const* int \**src2*, unsigned int *size*)  

Applies bitwise XOR operation to vector `<src1>` and `<src2>`, stores the result in `<src1>`, and stores the original value of `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`; `<src1>` = `<src1>` ^ `<src2>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The address of first source vector.
* `[in] src2`: The second source scalar or the address of second source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<src2>` must point to `\_\_nram\_\_` address space if `<src2>` is a vector;
* `<src1>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* `<dst>` can be overlapped with `<src2>` if `<src2>` is a vector;
* The address of `<src1>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 322 and 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx` except `tp\_322` and `tp\_520`.






**Example*** None.

















3.14. Atomic Reduce Functions
==============================



3.14.1. \_\_bang\_atomic\_nan\_reduce\_max
-------------------------------------------




void `__bang_atomic_nan_reduce_max`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_max`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_max`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_max`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_nan_reduce_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_nan_reduce_max`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the larger value from vector `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` > `<src1>`) ? `<dst>` : `<src1>`. If one of the elements being compared is a NaN, then NaN is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.2. \_\_bang\_atomic\_nan\_reduce\_max\_async
--------------------------------------------------




void `__bang_atomic_nan_reduce_max_async`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_max_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_max_async`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_max_async`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_nan_reduce_max_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_nan_reduce_max_async`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the larger value from vector `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` > `<src1>`) ? `<dst>` : `<src1>`. If one of the elements being compared is a NaN, then NaN is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.3. \_\_bang\_atomic\_nan\_reduce\_min
-------------------------------------------




void `__bang_atomic_nan_reduce_min`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_min`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_min`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_min`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_nan_reduce_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_nan_reduce_min`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the smaller value from two vector values `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` < `<src1>`) ? `<dst>` : `<src1>`. If one of the elements being compared is a NaN, then NaN is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.4. \_\_bang\_atomic\_nan\_reduce\_min\_async
--------------------------------------------------




void `__bang_atomic_nan_reduce_min_async`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_min_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_min_async`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_nan_reduce_min_async`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_nan_reduce_min_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_nan_reduce_min_async`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the smaller value from two vector values `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` < `<src1>`) ? `<dst>` : `<src1>`. If one of the elements being compared is a NaN, then NaN is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.5. \_\_bang\_atomic\_number\_reduce\_max
----------------------------------------------




void `__bang_atomic_number_reduce_max`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_max`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_max`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_max`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_number_reduce_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_number_reduce_max`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the larger value from vector `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` > `<src1>`) ? `<dst>` : `<src1>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.6. \_\_bang\_atomic\_number\_reduce\_max\_async
-----------------------------------------------------




void `__bang_atomic_number_reduce_max_async`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_max_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_max_async`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_max_async`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_number_reduce_max_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_number_reduce_max_async`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the larger value from vector `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` > `<src1>`) ? `<dst>` : `<src1>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.7. \_\_bang\_atomic\_number\_reduce\_min
----------------------------------------------




void `__bang_atomic_number_reduce_min`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_min`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_min`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_min`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_number_reduce_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_number_reduce_min`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the smaller value from two vector values `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` < `<src1>`) ? `<dst>` : `<src1>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.8. \_\_bang\_atomic\_number\_reduce\_min\_async
-----------------------------------------------------




void `__bang_atomic_number_reduce_min_async`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_min_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_min_async`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_number_reduce_min_async`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_number_reduce_min_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_number_reduce_min_async`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the smaller value from two vector values `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` < `<src1>`) ? `<dst>` : `<src1>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.9. \_\_bang\_atomic\_reduce\_add
--------------------------------------




void `__bang_atomic_reduce_add`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_add`(int \**dst*, *const* int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_add`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_add`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Increases `<dst>` by `<src1>` element-wisely. That is: `<dst>` = `<dst>` + `<src1>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short\* src1, short src2, int size) {
  \_\_bang\_atomic\_reduce\_add(src1, src2, size);
}

```













3.14.10. \_\_bang\_atomic\_reduce\_add\_async
----------------------------------------------




void `__bang_atomic_reduce_add_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add_async`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add_async`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_add_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_add_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_add_async`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_add_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_add_async`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Increases `<dst>` by `<src1>` element-wisely. That is: `<dst>` = `<dst>` + `<src1>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short\* src1, short src2, int size) {
  \_\_bang\_atomic\_reduce\_add\_async(src1, src2, size);
}

```













3.14.11. \_\_bang\_atomic\_reduce\_and
---------------------------------------




void `__bang_atomic_reduce_and`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_and`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_and`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_and`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Applies bitwise AND operation to the vector `<dst>` and `<src1>`, and stores the result in `<dst>`. That is: `<dst>` = `<dst>` & `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.12. \_\_bang\_atomic\_reduce\_and\_async
----------------------------------------------




void `__bang_atomic_reduce_and_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_and_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_and_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_and_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Applies bitwise AND operation to the vector `<dst>` and `<src1>`, and stores the result in `<dst>`. That is: `<dst>` = `<dst>` & `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.13. \_\_bang\_atomic\_reduce\_cas
---------------------------------------




void `__bang_atomic_reduce_cas`(short \**dst*, short *src1*, short *src2*)  




void `__bang_atomic_reduce_cas`(half \**dst*, half *src1*, half *src2*)  




void `__bang_atomic_reduce_cas`(float \**dst*, float *src1*, float *src2*)  




void `__bang_atomic_reduce_cas`(bfloat16\_t \**dst*, bfloat16\_t *src1*, bfloat16\_t *src2*)  




void `__bang_atomic_reduce_cas`(int \**dst*, int *src1*, int *src2*)  

If `<src1>` is equal to `<\*dst>`, stores `<src2>` in `<dst>`. That is: `<\*dst>` = (`<\*dst>` == `<src1>`) ? `<src2>` : `<\*dst>`.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1`: The first operand.
* `[in] src2`: The second operand.



**Return*** `void`.






**Remark*** This function only operates on one element;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int\* dst, int src1, int src2) {
  \_\_bang\_atomic\_reduce\_cas(dst, src1, src2);
}

```













3.14.14. \_\_bang\_atomic\_reduce\_cas\_async
----------------------------------------------




void `__bang_atomic_reduce_cas_async`(short \**dst*, short *src1*, short *src2*)  




void `__bang_atomic_reduce_cas_async`(half \**dst*, half *src1*, half *src2*)  




void `__bang_atomic_reduce_cas_async`(float \**dst*, float *src1*, float *src2*)  




void `__bang_atomic_reduce_cas_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, bfloat16\_t *src2*)  




void `__bang_atomic_reduce_cas_async`(int \**dst*, int *src1*, int *src2*)  

If `<src1>` is equal to `<\*dst>`, stores `<src2>` in `<dst>`. That is: `<\*dst>` = (`<\*dst>` == `<src1>`) ? `<src2>` : `<\*dst>`.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1`: The first operand.
* `[in] src2`: The second operand.



**Return*** `void`.






**Remark*** This function only operates on one element;
* `bfloat16\_t` is supported on `mtp\_592` or higher;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int\* dst, int src1, int src2) {
  \_\_bang\_atomic\_reduce\_cas\_async(dst, src1, src2);
}

```













3.14.15. \_\_bang\_atomic\_reduce\_dec
---------------------------------------




void `__bang_atomic_reduce_dec`(unsigned short \**dst*, unsigned short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_dec`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_dec`(unsigned int \**dst*, unsigned int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_dec`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_dec`(unsigned short \**dst*, *const* unsigned short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_dec`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_dec`(unsigned int \**dst*, *const* unsigned int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_dec`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Compares vector `<dst>` and `<src1>`. If `<dst>` is larger than `<src1>`, or the value of `<dst>` is 0, stores the int value `<src1>` in `<dst>`; otherwise, reduces `<dst>` by 1. That is: `<dst>` = (`<dst>` == 0 || `<dst>` > `<src1>`) ? `<src1>` : (`<dst>` - 1).



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.16. \_\_bang\_atomic\_reduce\_dec\_async
----------------------------------------------




void `__bang_atomic_reduce_dec_async`(unsigned short \**dst*, unsigned short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_dec_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_dec_async`(unsigned int \**dst*, unsigned int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_dec_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_dec_async`(unsigned short \**dst*, *const* unsigned short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_dec_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_dec_async`(unsigned int \**dst*, *const* unsigned int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_dec_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Compares vector `<dst>` and `<src1>`. If `<dst>` is larger than `<src1>`, or the value of `<dst>` is 0, stores the int value `<src1>` in `<dst>`; otherwise, reduces `<dst>` by 1. That is: `<dst>` = (`<dst>` == 0 || `<dst>` > `<src1>`) ? `<src1>` : (`<dst>` - 1).



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.17. \_\_bang\_atomic\_reduce\_exch
----------------------------------------




void `__bang_atomic_reduce_exch`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_exch`(int \**dst*, *const* int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_exch`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_exch`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_exch`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Stores `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.18. \_\_bang\_atomic\_reduce\_exch\_async
-----------------------------------------------




void `__bang_atomic_reduce_exch_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch_async`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch_async`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_exch_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_exch_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_exch_async`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_exch_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_exch_async`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Stores `<src1>` in `<dst>`. That is: `<dst>` = `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.19. \_\_bang\_atomic\_reduce\_inc
---------------------------------------




void `__bang_atomic_reduce_inc`(unsigned short \**dst*, unsigned short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_inc`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_inc`(unsigned int \**dst*, unsigned int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_inc`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_inc`(unsigned short \**dst*, *const* unsigned short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_inc`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_inc`(unsigned int \**dst*, *const* unsigned int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_inc`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Compares vector `<dst>` and `<src1>`. If `<dst>` is smaller than `<src1>`, increases `<dst>` by 1; otherwise, sets `<dst>` to 0. That is: `<dst>` = (`<dst>` >= `<src1>`) ? 0 : (`<dst>` + 1).



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.20. \_\_bang\_atomic\_reduce\_inc\_async
----------------------------------------------




void `__bang_atomic_reduce_inc_async`(unsigned short \**dst*, unsigned short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_inc_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_inc_async`(unsigned int \**dst*, unsigned int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_inc_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_inc_async`(unsigned short \**dst*, *const* unsigned short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_inc_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_inc_async`(unsigned int \**dst*, *const* unsigned int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_inc_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Compares vector `<dst>` and `<src1>`. If `<dst>` is smaller than `<src1>`, increases `<dst>` by 1; otherwise, sets `<dst>` to 0. That is: `<dst>` = (`<dst>` >= `<src1>`) ? 0 : (`<dst>` + 1).



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.21. \_\_bang\_atomic\_reduce\_max
---------------------------------------




void `__bang_atomic_reduce_max`(unsigned short \**dst*, unsigned short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max`(unsigned int \**dst*, unsigned int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max`(unsigned short \**dst*, *const* unsigned short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max`(unsigned int \**dst*, *const* unsigned int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max`(int \**dst*, *const* int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the larger value from vector `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` > `<src1>`) ? `<dst>` : `<src1>`. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.22. \_\_bang\_atomic\_reduce\_max\_async
----------------------------------------------




void `__bang_atomic_reduce_max_async`(unsigned short \**dst*, unsigned short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max_async`(unsigned int \**dst*, unsigned int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max_async`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max_async`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_max_async`(unsigned short \**dst*, *const* unsigned short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max_async`(unsigned int \**dst*, *const* unsigned int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max_async`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_max_async`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the larger value from vector `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` > `<src1>`) ? `<dst>` : `<src1>`. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<dst>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.23. \_\_bang\_atomic\_reduce\_min
---------------------------------------




void `__bang_atomic_reduce_min`(unsigned short \**dst*, unsigned short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min`(unsigned int \**dst*, unsigned int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min`(unsigned short \**dst*, *const* unsigned short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min`(unsigned int \**dst*, *const* unsigned int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min`(int \**dst*, *const* int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the smaller value from two vector values `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` < `<src1>`) ? `<dst>` : `<src1>`. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.24. \_\_bang\_atomic\_reduce\_min\_async
----------------------------------------------




void `__bang_atomic_reduce_min_async`(unsigned short \**dst*, unsigned short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min_async`(unsigned int \**dst*, unsigned int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min_async`(half \**dst*, half *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min_async`(bfloat16\_t \**dst*, bfloat16\_t *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min_async`(float \**dst*, float *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_min_async`(unsigned short \**dst*, *const* unsigned short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min_async`(unsigned int \**dst*, *const* unsigned int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min_async`(half \**dst*, *const* half \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min_async`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_min_async`(float \**dst*, *const* float \**src1*, unsigned int *size*)  

Takes the smaller value from two vector values `<dst>` and `<src1>`, and stores it in `<dst>`. That is: `<dst>` = (`<dst>` < `<src1>`) ? `<dst>` : `<src1>`. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1>` must be `sizeof(type)` aligned;
* `<size>` must be greater than zero;
* `bfloat16\_t` is supported on `mtp\_592` or higher.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.25. \_\_bang\_atomic\_reduce\_or
--------------------------------------




void `__bang_atomic_reduce_or`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_or`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_or`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_or`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Applies bitwise OR operation to vector `<dst>` and `<src1>`, and stores the result in `<dst>`. That is: `<dst>` = `<dst>` | `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.26. \_\_bang\_atomic\_reduce\_or\_async
---------------------------------------------




void `__bang_atomic_reduce_or_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_or_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_or_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_or_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Applies bitwise OR operation to vector `<dst>` and `<src1>`, and stores the result in `<dst>`. That is: `<dst>` = `<dst>` | `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.27. \_\_bang\_atomic\_reduce\_xor
---------------------------------------




void `__bang_atomic_reduce_xor`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_xor`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_xor`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_xor`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Applies bitwise XOR operation to vector `<dst>` and `<src1>`, and stores the result in `<dst>`. That is: `<dst>` = `<dst>` ^ `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.













3.14.28. \_\_bang\_atomic\_reduce\_xor\_async
----------------------------------------------




void `__bang_atomic_reduce_xor_async`(short \**dst*, short *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_xor_async`(int \**dst*, int *src1*, unsigned int *size* = 1)  




void `__bang_atomic_reduce_xor_async`(short \**dst*, *const* short \**src1*, unsigned int *size*)  




void `__bang_atomic_reduce_xor_async`(int \**dst*, *const* int \**src1*, unsigned int *size*)  

Applies bitwise XOR operation to vector `<dst>` and `<src1>`, and stores the result in `<dst>`. That is: `<dst>` = `<dst>` ^ `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src1`: The first source scalar or the address of first source vector.
* `[in] size`: The elements number of source vector.



**Return*** `void`.






**Remark*** `<src1>` must point to `\_\_nram\_\_` address space if `<src1>` is a vector;
* `<dst>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero;
* The address of `<dst>` must be `sizeof(type)` aligned.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_372` except `tp\_520`.






**Example*** None.

















3.15. Control Flow and Debugging Functions
===========================================



3.15.1. \_\_bang\_printf
-------------------------




int `__bang_printf`(*const* char \**fmt*, ...)  

Similar to standard printf function, prints arguments to screen, formatted by the format string.



**Parameters*** `[in] fmt`: The format string, which must be a literal constant string.



**Return*** `void`.






**Remark*** `<fmt>` must be a literal constant string;
* This function can at most accept 17 parameters including the format string;
* The type of parameters can be different. It must be one of: char, unsigned char, short, unsigned short, int, unsigned int, half, float, char, bool, pointer;
* Since this function involves extremely time-consuming interaction between CPU and MLU, it might cause significant performance degradation.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.15.2. \_\_is\_ipu
--------------------




bool `__is_ipu`()  

Returns `true` for MLU cores.



**Return*** `bool`.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.4.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.15.3. \_\_is\_mpu
--------------------




bool `__is_mpu`()  

Returns `true` for MPU cores.



**Return*** `bool`.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.4.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.

















3.16. Discrete Atomic Functions
================================



3.16.1. \_\_bang\_discrete\_atomic\_add
----------------------------------------




void `__bang_discrete_atomic_add`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Adds `<src2>` to the values in discrete `<src1>` addresses. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic add is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short\* acc, char\* offset, short\* src2, int\* mask) {
  \_\_nram\_\_ short v[128];
  \_\_nram\_\_ char offset\_nram[128];
  \_\_nram\_\_ short src2\_nram[128];
  \_\_nram\_\_ int mask\_nram[128 / sizeof(int) / 8];
  \_\_memcpy(offset\_nram, offset, 128 \* sizeof(char), GDRAM2NRAM);
  \_\_memcpy(src2\_nram, src2, 128 \* sizeof(short), GDRAM2NRAM);
  \_\_memcpy(mask\_nram, mask, 128 / 8, GDRAM2NRAM);
  \_\_bang\_discrete\_atomic\_add(v, acc, offset\_nram, src2\_nram, mask\_nram, 128);
}

```













3.16.2. \_\_bang\_discrete\_atomic\_and
----------------------------------------




void `__bang_discrete_atomic_and`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_and`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Performs bitwise AND on the values in discrete `<src1>` addresses with `<src2>` respectively. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic bitwise AND is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.3. \_\_bang\_discrete\_atomic\_cas
----------------------------------------




void `__bang_discrete_atomic_cas`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, short *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, short *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, short *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, int *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, int *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, int *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, half *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, half *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, half *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, float *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, float *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, float *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, bfloat16\_t *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, bfloat16\_t *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, bfloat16\_t *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, short *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, short *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, short *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, int *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, int *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, int *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, half *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, half *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, half *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, float *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, float *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, float *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, bfloat16\_t *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, bfloat16\_t *src3*, unsigned int *size*)  




void `__bang_discrete_atomic_cas`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, bfloat16\_t *src3*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Stores the values in `<src2>` in discrete `<src1>` addresses respectively if they are equal to `<src3>`. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] src3`: The third operand.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic compare-and-swap is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.4. \_\_bang\_discrete\_atomic\_dec
----------------------------------------




void `__bang_discrete_atomic_dec`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_dec`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Decrements the values in discrete `<src1>` addresses by 1 if they are not greater than the corresponding values in `<src2>` and not equal to 0; otherwise, sets them to the corresponding values in `<src2>`. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic decrement is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.5. \_\_bang\_discrete\_atomic\_exch
-----------------------------------------




void `__bang_discrete_atomic_exch`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_exch`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Stores the values in `<src2>` in discrete `<src1>` addresses respectively. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic exchange is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.6. \_\_bang\_discrete\_atomic\_inc
----------------------------------------




void `__bang_discrete_atomic_inc`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_inc`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Increments the values in discrete `<src1>` addresses by 1 if they are smaller than the corresponding values in `<src2>`; otherwise, sets them to 0. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable.









**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic increment is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.7. \_\_bang\_discrete\_atomic\_max
----------------------------------------




void `__bang_discrete_atomic_max`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Sets the values in discrete `<src1>` addresses to the greater values between the original values and the corresponding values in `<src2>`. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.8. \_\_bang\_discrete\_atomic\_min
----------------------------------------




void `__bang_discrete_atomic_min`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned short \**dst*, *const* unsigned short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(unsigned int \**dst*, *const* unsigned int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* unsigned int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Sets the values in discrete `<src1>` addresses to the smaller values between the original values and the corresponding values in `<src2>`. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.9. \_\_bang\_discrete\_atomic\_nan\_max
---------------------------------------------




void `__bang_discrete_atomic_nan_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Sets the values in discrete `<src1>` addresses to the greater values between the original values and the corresponding values in `<src2>`. Stores the original values in discrete `<src1>` addresses in `<dst>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.10. \_\_bang\_discrete\_atomic\_nan\_min
----------------------------------------------




void `__bang_discrete_atomic_nan_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_nan_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Sets the values in discrete `<src1>` addresses to the smaller values between the original values and the corresponding values in `<src2>`. Stores the original values in discrete `<src1>` addresses in `<dst>`. If one of the elements being compared is a NaN, then NaN is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.11. \_\_bang\_discrete\_atomic\_number\_max
-------------------------------------------------




void `__bang_discrete_atomic_number_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_max`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Sets the values in discrete `<src1>` addresses to the greater values between the original values and the corresponding values in `<src2>`. Stores the original values in discrete `<src1>` addresses in `<dst>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic maximum is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.12. \_\_bang\_discrete\_atomic\_number\_min
-------------------------------------------------




void `__bang_discrete_atomic_number_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(half \**dst*, *const* half \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* half \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(float \**dst*, *const* float \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* float \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_number_min`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* bfloat16\_t \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Sets the values in discrete `<src1>` addresses to the smaller values between the original values and the corresponding values in `<src2>`. Stores the original values in discrete `<src1>` addresses in `<dst>`. If one of the elements being compared is a NaN, then the non-NaN element is returned. All steps are inseparable. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic minimum is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.13. \_\_bang\_discrete\_atomic\_or
----------------------------------------




void `__bang_discrete_atomic_or`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_or`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Performs bitwise OR on the values in discrete `<src1>` addresses with `<src2>` respectively. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic bitwise OR is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.16.14. \_\_bang\_discrete\_atomic\_xor
-----------------------------------------




void `__bang_discrete_atomic_xor`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(short \**dst*, *const* short \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(short \**dst*, *const* short \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(short \**dst*, *const* short \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* short \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(int \**dst*, *const* int \**src1\_base*, *const* unsigned char \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(int \**dst*, *const* int \**src1\_base*, *const* unsigned short \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  




void `__bang_discrete_atomic_xor`(int \**dst*, *const* int \**src1\_base*, *const* unsigned int \**src1\_offset*, *const* int \**src2*, *const* void \**mask*, unsigned int *size*)  

Computes the discrete `<src1>` addresses by adding offsets stored in `<src1\_offset>` to `<src1\_base>`. Performs bitwise XOR on the values in discrete `<src1>` addresses with `<src2>` respectively. Stores the original values in discrete `<src1>` addresses in `<dst>`. All steps are inseparable.



**Parameters*** `[out] dst`: The address of destination operand.
* `[in] src1\_base`: The base address of the first operand.
* `[in] src1\_offset`: The address of the offsets of the first operand.
* `[in] src2`: The second operand.
* `[in] mask`: The address of mask.
* `[in] size`: The number of elements to be computed.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src1\_base>` must point to `\_\_mlu\_device\_\_` address space;
* The address of `<src1\_base>` must be `sizeof(type)` aligned;
* `<dst>`, `<src1\_offset>`, `<src2>` and `<mask>` must point to `\_\_nram\_\_` address space;
* The offsets stored in `<src1\_offset>` are in bytes, and must be `sizeof(type)` aligned;
* `<mask>` has `<size>` effective bits, and each bit controls if atomic bitwise XOR is performed on the corresponding element. If no `<mask>` is given, all elements are computed.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.

















3.17. Discrete Move Functions
==============================



3.17.1. \_\_gather
-------------------




void `__gather`(void \**dst*, *const* void \**src*, *const* unsigned char \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather`(void \**dst*, *const* void \**src*, *const* unsigned short \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather`(void \**dst*, *const* void \**src*, *const* unsigned int \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather`(void \**dst*, *const* void \**src*, *const* unsigned char \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather`(void \**dst*, *const* void \**src*, *const* unsigned short \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather`(void \**dst*, *const* void \**src*, *const* unsigned int \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  

Move discrete data segments in `<src>` to `<dst>` with stride.


As shown in Figure Discrete Vector Gather Function , the cells with blue background indicate the data to be copied.



![../_images/gather_vector.png](../_images/gather_vector.png)

Fig. 3.5 Discrete Vector Gather Function












**Parameters*** `[out] dst`: The destination vector.
* `[in] src`: The source vector.
* `[in] offset`: The offsets between the segments in `<src>` and the beginning of `<src>` in bytes.
* `[in] mask`: The source mask vector.
* `[in] transfer\_size`: The size of single segment of `<src>` in bytes.
* `[in] dir`: Transport direction.
* `[in] stride`: The stride of adjacent segments in `<dst>` in bytes.
* `[in] transfer\_num`: The number of segments in `<src>`.



**Return*** `void`.






**Remark*** `<offset>` and `<mask>` must point to `\_\_nram\_\_` address space;
* Each data transfer corresponds to a bit in `<mask>` while has `<mask>` in parameters, if the value of bit is 1, a data transfer occurs, otherwise, it does not;
* The address of `<src>` is recommended to be 64-byte aligned to get better performance;
* The address of `<mask>` is recommended to be 32-byte aligned to get better performance;
* If the space of `<dst>` is in `wram`, `<transfer\_size>` and `<stride>` must be divisible by 8;
* The value of `<transfer\_size>`, `<transfer\_num>` and `<stride>` must be greater than 0;
* `<stride>` should be grater than or equal to `<transfer\_size>`;
* `<src>` and `<dst>` cannot be overlapped;
* The function does not support transport directions of GDRAM2SRAM, SRAM2GDRAM, LDRAM2SRAM, SRAM2LDRAM, SRAM2SRAM and WRAM2WRAM.






**Instruction Pipeline*** Execute in Move instruction pipeline, if `<dst>` and `<src>` are `on-chip address`;
* Execute in IO instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include <mlu.h>

\_\_mlu\_entry\_\_ void kernel() {
  \_\_nram\_\_ char nram\_dst[1024];
  \_\_nram\_\_ char nram\_src[1024];
  \_\_nram\_\_ char nram\_mask[1024];
  \_\_nram\_\_ unsigned char nram\_offset\_u8[1024];

  \_\_gather(nram\_dst, nram\_src, nram\_offset\_u8, nram\_mask, 1, NRAM2NRAM, 1, 32);
}

```













3.17.2. \_\_gather\_async
--------------------------




void `__gather_async`(void \**dst*, *const* void \**src*, *const* unsigned char \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather_async`(void \**dst*, *const* void \**src*, *const* unsigned short \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather_async`(void \**dst*, *const* void \**src*, *const* unsigned int \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather_async`(void \**dst*, *const* void \**src*, *const* unsigned char \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather_async`(void \**dst*, *const* void \**src*, *const* unsigned short \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__gather_async`(void \**dst*, *const* void \**src*, *const* unsigned int \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  

Move the discrete data segments in `<src>` to `<dst>` with stride asynchronized.


As shown in Figure Discrete Vector Gather Function , the cells with blue background indicate the data to be copied.









**Parameters*** `[out] dst`: The destination vector.
* `[in] src`: The source vector.
* `[in] offset`: The offsets between the segments in `<src>` and the beginning of `<src>` in bytes.
* `[in] mask`: The source mask vector.
* `[in] transfer\_size`: The size of single segment of `<src>` in bytes.
* `[in] dir`: Transport direction.
* `[in] stride`: The stride of adjacent segments in `<dst>` in bytes.
* `[in] transfer\_num`: The number of segments in `<src>`.



**Return*** `void`.






**Remark*** `<offset>` and `<mask>` must point to `\_\_nram\_\_` address space;
* Each data transfer corresponds to a bit in `<mask>` while has `<mask>` in parameters, if the value of bit is 1, a data transfer occurs, otherwise, it does not;
* The address of `<src>` is recommended to be 64-byte aligned to get better performance;
* The address of `<mask>` is recommended to be 32-byte aligned to get better performance;
* If the space of `<dst>` is in `wram`, `<transfer\_size>` and `<stride>` must be divisible by 8;
* The value of `<transfer\_size>`, `<transfer\_num>` and `<stride>` must be greater than 0;
* `<stride>` should be grater than or equal to `<transfer\_size>`;
* `<src>` and `<dst>` cannot be overlapped;
* The function does not support transport directions of GDRAM2SRAM, SRAM2GDRAM, LDRAM2SRAM, SRAM2LDRAM, SRAM2SRAM and WRAM2WRAM.






**Instruction Pipeline*** Execute in Move instruction pipeline, if `<dst>` and `<src>` are `on-chip address`;
* Execute in IO instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.













3.17.3. \_\_prefetch\_smmu
---------------------------




void `__prefetch_smmu`(*const* void \**src*, unsigned int *size*)  

Prefetches smmu entries before it is needed. 


* None.






**Parameters*** `[in] src`: The address of source data.
* `[in] size`: The byte size of the source data.



**Return**void.



**Remark*** `<src>` must point to `\_\_mlu\_device\_\_` address space;
* `<size>` must be greater than zero.






**Instruction Pipeline*** IO.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float\* src) {
  \_\_prefetch\_smmu(src, 1024);
}

```













3.17.4. \_\_scatter
--------------------




void `__scatter`(void \**dst*, *const* void \**src*, *const* unsigned char \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter`(void \**dst*, *const* void \**src*, *const* unsigned short \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter`(void \**dst*, *const* void \**src*, *const* unsigned int \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter`(void \**dst*, *const* void \**src*, *const* unsigned char \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter`(void \**dst*, *const* void \**src*, *const* unsigned short \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter`(void \**dst*, *const* void \**src*, *const* unsigned int \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  

Move the data segments in `<src>` to the discrete space of `<dst>`.


As shown in Figure Discrete Vector Scatter Function , the cells with blue background indicate the data to be copied.



![../_images/scatter_vector.png](../_images/scatter_vector.png)

Fig. 3.6 Discrete Vector Scatter Function












**Parameters*** `[out] dst`: The destination vector.
* `[in] src`: The source vector.
* `[in] offset`: The offsets between the segments in `<dst>` and the beginning of `<dst>` in bytes.
* `[in] mask`: The source mask vector.
* `[in] transfer\_size`: The size of single segment of `<src>` in bytes.
* `[in] dir`: Transport direction.
* `[in] stride`: The stride of adjacent segments in `<src>` in bytes.
* `[in] transfer\_num`: The number of segments in `<src>`.



**Return*** `void`.






**Remark*** `<offset>` and `<mask>` must point to `\_\_nram\_\_` address space;
* Each data transfer corresponds to a bit in `<mask>` while has `<mask>` in parameters, if the value of bit is 1, a data transfer occurs, otherwise, it does not;
* The address of `<src>` is recommended to be 64-byte aligned to get better performance;
* The address of `<mask>` is recommended to be 32-byte aligned to get better performance;
* If the space of `<dst>` is in `wram`, `<transfer\_size>` and the values of `<offset>` must be divisible by 8;
* The value of `<transfer\_size>`, `<transfer\_num>` and `<stride>` must be greater than 0;
* `<stride>` should be grater than or equal to `<transfer\_size>`;
* `<src>` and `<dst>` cannot be overlapped;
* The function does not support transport directions of GDRAM2SRAM, SRAM2GDRAM, LDRAM2SRAM, SRAM2LDRAM, SRAM2SRAM and WRAM2WRAM.






**Instruction Pipeline*** Execute in Move instruction pipeline, if `<dst>` and `<src>` are `on-chip address`;
* Execute in IO instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example**
```
#include <mlu.h>

\_\_mlu\_entry\_\_ void kernel() {
  \_\_nram\_\_ char nram\_dst[1024];
  \_\_nram\_\_ char nram\_src[1024];
  \_\_nram\_\_ char nram\_mask[1024];
  \_\_nram\_\_ unsigned char nram\_offset\_u8[1024];

  \_\_scatter(nram\_dst, nram\_src, nram\_offset\_u8, nram\_mask, 1, NRAM2NRAM, 1, 32);
}

```













3.17.5. \_\_scatter\_async
---------------------------




void `__scatter_async`(void \**dst*, *const* void \**src*, *const* unsigned char \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter_async`(void \**dst*, *const* void \**src*, *const* unsigned short \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter_async`(void \**dst*, *const* void \**src*, *const* unsigned int \**offset*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter_async`(void \**dst*, *const* void \**src*, *const* unsigned char \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter_async`(void \**dst*, *const* void \**src*, *const* unsigned short \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  




void `__scatter_async`(void \**dst*, *const* void \**src*, *const* unsigned int \**offset*, *const* void \**mask*, unsigned int *transfer\_size*, mluMemcpyDirection\_t *dir*, unsigned int *stride*, unsigned short *transfer\_num*)  

Move the data segments in `<src>` to the discrete space of `<dst>` asynchronized.


As shown in Figure Discrete Vector Scatter Function , the cells with blue background indicate the data to be copied.









**Parameters*** `[out] dst`: The destination vector.
* `[in] src`: The source vector.
* `[in] offset`: The offsets between the segments in `<dst>` and the beginning of `<dst>` in bytes.
* `[in] mask`: The source mask vector.
* `[in] transfer\_size`: The size of single segment of `<src>` in bytes.
* `[in] dir`: Transport direction.
* `[in] stride`: The stride of adjacent segments in `<src>` in bytes.
* `[in] transfer\_num`: The number of segments in `<src>`.



**Return*** `void`.






**Remark*** `<offset>` and `<mask>` must point to `\_\_nram\_\_` address space;
* Each data transfer corresponds to a bit in `<mask>` while has `<mask>` in parameters, if the value of bit is 1, a data transfer occurs, otherwise, it does not;
* The address of `<src>` is recommended to be 64-byte aligned to get better performance;
* The address of `<mask>` is recommended to be 32-byte aligned to get better performance;
* If the space of `<dst>` is in `wram`, `<transfer\_size>` and the values of `<offset>` must be divisible by 8;
* The value of `<transfer\_size>`, `<transfer\_num>` and `<stride>` must be greater than 0;
* `<stride>` should be grater than or equal to `<transfer\_size>`;
* `<src>` and `<dst>` cannot be overlapped;
* The function does not support transport directions of GDRAM2SRAM, SRAM2GDRAM, LDRAM2SRAM, SRAM2LDRAM, SRAM2SRAM and WRAM2WRAM.






**Instruction Pipeline*** Execute in Move instruction pipeline, if `<dst>` and `<src>` are `on-chip address`;
* Execute in IO instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 592`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_592`.






**Example*** None.

















3.18. Inter-Core Synchronization Functions
===========================================



3.18.1. \_\_sync\_all
----------------------




void `__sync_all`()  

Synchronizes all clusters on which the kernel executes. It has the same effect as `\_\_sync\_all\_ipu` and `\_\_sync\_all\_mpu` combined. The number of MLU core and MPU core to synchronize is related to task type, UNION1 is 5, UNION2 is 10, UNION4 is 20.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** Execute on MPU core and MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.18.2. \_\_sync\_all\_arrive
------------------------------




void `__sync_all_arrive`(unsigned int *id*, unsigned int *count*)  

Sends an unblocking signal of the cores to the barrier with the <id> across clusters.



**Parameters*** `[in] id`: The barrier id.
* `[in] count`: The barrier count.



**Return**`void`.



**Remark*** The range of `<id>` is [0, 32767];
* `count` must be greater than 1;
* This function must be used together with \_\_sync\_all\_wait;
* This function does not support crossing. See the remark of \_\_sync\_all\_wait for more details.






**Instruction Pipeline*** Execute on MPU core and MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_3xx`.






**Example*** None.













3.18.3. \_\_sync\_all\_ipu
---------------------------




void `__sync_all_ipu`()  

Synchronizes all MLU cores of clusters on which the kernel executes. The number of MLU cores to synchronize is related to task type, e.g., UNION1 is 4, UNION2 is 8, and UNION4 is 16.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.18.4. \_\_sync\_all\_ipu\_within\_cluster
--------------------------------------------




void `__sync_all_ipu_within_cluster`()  

Synchronizes all MLU cores within a cluster on which the kernel executes.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.18.5. \_\_sync\_all\_mpu
---------------------------




void `__sync_all_mpu`()  

Synchronizes all MPU cores of clusters on which the kernel executes. The number of MPU cores to synchronize is related to task type, e.g., UNION1 is 1, UNION2 is 2, and UNION4 is 4.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** Execute on MPU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.18.6. \_\_sync\_all\_wait
----------------------------




void `__sync_all_wait`(unsigned int *id*, unsigned int *count*)  

Blocks execution of a core until <count> number of unblocking signals from `\_\_sync\_all\_wait` or `\_\_sync\_all\_arrive` of the same <id> are received across clusters.


@remark
- The range of `<id>` is [0, 32767];
- `count` must be greater than 1;
- If multiple barrier events exist in different cores, barrier crossing is not supported. Crossing means a pair of `\_\_sync\_all\_arrive` or `\_\_sync\_all\_wait` instructions are in different order with the corresponding `\_\_sync\_all\_wait` instructions (with the same `id`). For example,



![../_images/barrier_crossing_global.png](../_images/barrier_crossing_global.png)

Fig. 3.7 Global Barrier Crossing Examples





Figure Global Barrier Crossing Examples shows crossing between `\_\_sync\_all\_wait` and `\_\_sync\_all\_wait` and crossing between `\_\_sync\_all\_arrive` and `\_\_sync\_all\_wait`.






**Parameters*** `[in] id`: The barrier id.
* `[in] count`: The barrier count.



**Return**`void`.








**Instruction Pipeline*** Execute on MPU core and MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_3xx`.






**Example*** None.













3.18.7. \_\_sync\_cluster
--------------------------




void `__sync_cluster`()  

Synchronizes all cores inside the cluster on which the kernel executes. The cores to synchronize consists of 1 MPU core and 4 MLU cores.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** Execute on MPU core and MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.18.8. \_\_sync\_cluster\_arrive
----------------------------------




void `__sync_cluster_arrive`(unsigned int *id*, unsigned int *count*)  

Sends an unblocking signal of the cores to the barrier with the <id> within the cluster.



**Parameters*** `[in] id`: The barrier id.
* `[in] count`: The barrier count.



**Return**`void`.



**Remark*** The range of `<id>` is [0, 32767];
* `count` must be greater than 1;
* This function must be used together with \_\_sync\_cluster\_wait;
* This function does not support crossing. See the remark of \_\_sync\_cluster\_wait for more details.






**Instruction Pipeline*** Execute on MPU core and MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_3xx`.






**Example*** None.













3.18.9. \_\_sync\_cluster\_wait
--------------------------------




void `__sync_cluster_wait`(unsigned int *id*, unsigned int *count*)  

Blocks execution of a core until <count> number of unblocking signals from `\_\_sync\_cluster\_wait` or `\_\_sync\_cluster\_arrive` of the same <id> are received within the cluster.


@remark
- The range of `<id>` is [0, 32767];
- `count` must be greater than 1;
- If multiple barrier events exist in different cores, barrier crossing is not supported. Crossing means a pair of `\_\_sync\_cluster\_arrive` or `\_\_sync\_cluster\_wait` instructions are in different order with the corresponding `\_\_sync\_cluster\_wait` instructions (with the same `id`). For example,



![../_images/barrier_crossing_local.png](../_images/barrier_crossing_local.png)

Fig. 3.8 Local Barrier Crossing Examples





Figure Local Barrier Crossing Examples shows crossing between `\_\_sync\_cluster\_wait` and `\_\_sync\_cluster\_wait` and crossing between `\_\_sync\_cluster\_arrive` and `\_\_sync\_cluster\_wait`.






**Parameters*** `[in] id`: The barrier id.
* `[in] count`: The barrier count.



**Return**`void`.








**Instruction Pipeline*** Execute on MPU core and MLU core.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 372` except 520;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_3xx`.






**Example*** None.

















3.19. Intra-Core Synchronization Functions
===========================================



3.19.1. \_\_sync
-----------------




void `__sync`()  

Synchronizes all instructions within a core. All IO/Move/Compute/Scalar instructions after this function must wait until all instructions before this function have finished.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** Execute on MPU core and MLU core.






**Requirements*** BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.19.2. \_\_sync\_compute
--------------------------




void `__sync_compute`()  

Synchronizes all instructions in compute pipeline within a core. All IO/Move/Compute instructions after this function must wait until all instructions in Compute pipeline have finished.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.19.3. \_\_sync\_io
---------------------




void `__sync_io`()  

Synchronizes all instructions in IO pipeline within a core. All IO/Move/Compute instructions after this function must wait until all instructions in IO pipeline have finished.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.19.4. \_\_sync\_io\_move\_compute
------------------------------------




void `__sync_io_move_compute`(bool *ioproducer* = true, bool *moveproducer* = true, bool *computeproducer* = true, bool *ioconsumer* = true, bool *moveconsumer* = true, bool *computeconsumer* = true)  

Synchronizes all instructions in specified IO/Move/Compute pipelines within a core. All instructions in queues specified by consumer flags(flags with consumer suffix) after the `\_\_sync\_io\_move\_compute` instruction must wait until all instructions in queues specified by producer flags(flags with producer suffix) before the `\_\_sync\_io\_move\_compute` instruction have finished. If no flag is given, all IO/Move/Compute instructions after this function must wait until all instructions in IO/Move/Compute pipelines have finished.



**Parameters*** `[in] ioproducer`: Specify whether io is producer.
* `[in] moveproducer`: Specify whether move is producer.
* `[in] computeproducer`: Specify whether compute is producer.
* `[in] ioconsumer`: Specify whether io is consumer.
* `[in] moveconsumer`: Specify whether move is consumer.
* `[in] computeconsumer`: Specify whether compute is consumer.



**Return**`void`.



**Remark*** Producers cannot all be false, consumers cannot all be false.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.19.5. \_\_sync\_move
-----------------------




void `__sync_move`()  

Synchronizes all instructions in move pipeline within a MLU core. All IO/Move/Compute instructions after this function must wait until all instructions in Move pipeline have finished.



**Return**`void`.



**Remark*** None.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.

















3.20. Matrix Multiplication Functions
======================================



3.20.1. \_\_bang\_matmul
-------------------------




void `__bang_matmul`(half \**dst*, *const* int4x2\_t \**src0*, *const* int4x2\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int4x2\_t \**src0*, *const* int8\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int4x2\_t \**src0*, *const* int16\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int8\_t \**src0*, *const* int4x2\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int8\_t \**src0*, *const* int8\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int8\_t \**src0*, *const* int16\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int16\_t \**src0*, *const* int4x2\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int16\_t \**src0*, *const* int8\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int16\_t \**src0*, *const* int16\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int4x2\_t \**src0*, *const* int4x2\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int4x2\_t \**src0*, *const* int8\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int4x2\_t \**src0*, *const* int16\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int8\_t \**src0*, *const* int4x2\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int8\_t \**src0*, *const* int8\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int8\_t \**src0*, *const* int16\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int16\_t \**src0*, *const* int4x2\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int16\_t \**src0*, *const* int8\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int16\_t \**src0*, *const* int16\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*)  




void `__bang_matmul`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*)  




void `__bang_matmul`(float \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*)  




void `__bang_matmul`(int16\_t \**dst*, *const* int8\_t \**src0*, *const* int8\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(int16\_t \**dst*, *const* int16\_t \**src0*, *const* int8\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(int16\_t \**dst*, *const* int16\_t \**src0*, *const* int16\_t \**src1*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int4x2\_t \**src0*, *const* int4x2\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int4x2\_t \**src0*, *const* int8\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int4x2\_t \**src0*, *const* int16\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int8\_t \**src0*, *const* int4x2\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int8\_t \**src0*, *const* int8\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int8\_t \**src0*, *const* int16\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int16\_t \**src0*, *const* int4x2\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int16\_t \**src0*, *const* int8\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(half \**dst*, *const* int16\_t \**src0*, *const* int16\_t \**src1*, *const* half \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int4x2\_t \**src0*, *const* int4x2\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int4x2\_t \**src0*, *const* int8\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int4x2\_t \**src0*, *const* int16\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int8\_t \**src0*, *const* int4x2\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int8\_t \**src0*, *const* int8\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int8\_t \**src0*, *const* int16\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int16\_t \**src0*, *const* int4x2\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int16\_t \**src0*, *const* int8\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  




void `__bang_matmul`(float \**dst*, *const* int16\_t \**src0*, *const* int16\_t \**src1*, *const* float \**src2*, unsigned int *M*, unsigned int *K*, unsigned int *N*, int *fix\_position*)  

For version without `<src2>`, use the two-dimensional tensor `<src0>[<M>, <K>]` to perform a product operation on the two-dimensional tensor `<src1>[<K>, <N>]` and stores the result in the two-dimensional tensor `<dst>[<M>, <N>]` , i.e., \(<dst> = <src0> \times <src1>\). For version with `<src2>`, use the two-dimensional tensor `<src0>[<M>, <K>]` to perform a product operation on the two-dimensional tensor `<src1>[<K>, <N>]` and add the two-dimensional tensor `<src2>[<M>, <N>]` and stores the result in the two-dimensional tensor `<dst>[<M>, <N>]` , i.e., \(<dst> = <src0> \times <src1> + <src2>\).


See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination matrix which has row-major data layout.
* `[in] src0`: The address of source0 matrix which has row-major data layout.
* `[in] src1`: The address of source1 matrix which has column-major data layout.
* `[in] src2`: The address of source2 matrix which has row-major data layout.
* `[in] M`: The height of source0 matrix.
* `[in] K`: The width of source0 matrix.
* `[in] N`: The width of source1 matrix.
* `[in] fix\_position`: Sum of the scale factor of `<src0>` and `<src1>`.



**Return*** `void`.






**Remark*** `<src0>` , `<src2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src1>` must point to `\_\_wram\_\_` address space;
* `<fix\_position>` must be in the range `[-127, 127]`;
* The address of `<src1>` must be 32-byte aligned;
* The matrix `<src1>` must be reshaped either on host or on device with `\_\_bang\_reshape()`;
* The address of `<dst>` , `<src0>` and `<src2>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<K> \* sizeof(typeof<src0>)` must be 64-byte aligned on `(m)tp\_2xx`;
* `<N>` must be divisible by 64 on `(m)tp\_2xx`;
* `<N> \* sizeof(typeof<dst>)` must be 64-byte aligned on `(m)tp\_2xx`;
* The byte size of `<src1>` must be 64-byte aligned;
* On `(m)tp\_3xx` and higher, `M` dimension of `<src1>` must satisfy the following alignment constraints:
	+ If `sizeof(typeof<src0>) / sizeof(typeof<src1>) == 4`, `K \* sizeof(typeof<src1>)` must be 16-byte aligned;
	+ If `sizeof(typeof<src0>) / sizeof(typeof<src1>) == 2`, `K \* sizeof(typeof<src1>)` must be 32-byte aligned;
	+ Otherwise, `K \* sizeof(typeof<src1>)` must be 64-byte aligned;
* On `(m)tp\_3xx` and higher, there is no alignment constraint for parameter `<N>`, but when allocating memory, the `N` dimension of memory space of `<src1>` must be 64 aligned;
* `<M>`, `<K>` and `<N>` must be greater than 0;
* `<dst>` cannot be overlapped with `<src0>`;
* `<dst>` can be overlapped with `<src2>`.






**Compatibility between Various Architectures**



Table 3.31 Data Types Supported on `(m)tp\_2xx`





| Src0 Type | Src1 Type | Src2 Type | Dst Type |
| --- | --- | --- | --- |
| int4 | int4 | half | half |
| int8\_t | int4 | half | half |
| int8\_t | int8\_t | half | half |
| int16\_t | int4 | half | half |
| int16\_t | int8\_t | half | half |
| int16\_t | int16\_t | half | half |
| int4 | int4 | float | float |
| int8\_t | int4 | float | float |
| int8\_t | int8\_t | float | float |
| int16\_t | int4 | float | float |
| int16\_t | int8\_t | float | float |
| int16\_t | int16\_t | float | float |
| int4 | int4 | none | half |
| int8\_t | int4 | none | half |
| int8\_t | int8\_t | none | half |
| int16\_t | int4 | none | half |
| int16\_t | int8\_t | none | half |
| int16\_t | int16\_t | none | half |
| int4 | int4 | none | float |
| int8\_t | int4 | none | float |
| int8\_t | int8\_t | none | float |
| int16\_t | int4 | none | float |
| int16\_t | int8\_t | none | float |
| int16\_t | int16\_t | none | float |
| int8\_t | int8\_t | none | int16\_t |
| int16\_t | int8\_t | none | int16\_t |
| int16\_t | int16\_t | none | int16\_t |




Table 3.32 Data Types Supported on `mtp\_372` and `mtp\_592`





| Src0 Type | Src1 Type | Src2 Type | Dst Type |
| --- | --- | --- | --- |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int8\_t | int8\_t | half | half |
| int8\_t | int16\_t | half | half |
| int16\_t | int4 | half | half |
| int16\_t | int8\_t | half | half |
| int16\_t | int16\_t | half | half |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int8\_t | int8\_t | float | float |
| int8\_t | int16\_t | float | float |
| int16\_t | int4 | float | float |
| int16\_t | int8\_t | float | float |
| int16\_t | int16\_t | float | float |
| int4 | int4 | none | half |
| int4 | int8\_t | none | half |
| int4 | int16\_t | none | half |
| int8\_t | int4 | none | half |
| int8\_t | int8\_t | none | half |
| int8\_t | int16\_t | none | half |
| int16\_t | int4 | none | half |
| int16\_t | int8\_t | none | half |
| int16\_t | int16\_t | none | half |
| int4 | int4 | none | float |
| int4 | int8\_t | none | float |
| int4 | int16\_t | none | float |
| int8\_t | int4 | none | float |
| int8\_t | int8\_t | none | float |
| int8\_t | int16\_t | none | float |
| int16\_t | int4 | none | float |
| int16\_t | int8\_t | none | float |
| int16\_t | int16\_t | none | float |
| half | half | none | float |
| float | float | none | float |
| bfloat16\_t | bfloat16\_t | none | float |
| int8\_t | int8\_t | none | int16\_t |
| int16\_t | int8\_t | none | int16\_t |
| int16\_t | int16\_t | none | int16\_t |




Table 3.33 Data Types Supported on `tp\_322` and `tp\_520`





| Src0 Type | Src1 Type | Src2 Type | Dst Type |
| --- | --- | --- | --- |
| int4 | int4 | half | half |
| int4 | int8\_t | half | half |
| int4 | int16\_t | half | half |
| int8\_t | int4 | half | half |
| int8\_t | int8\_t | half | half |
| int8\_t | int16\_t | half | half |
| int16\_t | int4 | half | half |
| int16\_t | int8\_t | half | half |
| int16\_t | int16\_t | half | half |
| int4 | int4 | float | float |
| int4 | int8\_t | float | float |
| int4 | int16\_t | float | float |
| int8\_t | int4 | float | float |
| int8\_t | int8\_t | float | float |
| int8\_t | int16\_t | float | float |
| int16\_t | int4 | float | float |
| int16\_t | int8\_t | float | float |
| int16\_t | int16\_t | float | float |
| int4 | int4 | none | half |
| int4 | int8\_t | none | half |
| int4 | int16\_t | none | half |
| int8\_t | int4 | none | half |
| int8\_t | int8\_t | none | half |
| int8\_t | int16\_t | none | half |
| int16\_t | int4 | none | half |
| int16\_t | int8\_t | none | half |
| int16\_t | int16\_t | none | half |
| int4 | int4 | none | float |
| int4 | int8\_t | none | float |
| int4 | int16\_t | none | float |
| int8\_t | int4 | none | float |
| int8\_t | int8\_t | none | float |
| int8\_t | int16\_t | none | float |
| int16\_t | int4 | none | float |
| int16\_t | int8\_t | none | float |
| int16\_t | int16\_t | none | float |
| int8\_t | int8\_t | none | int16\_t |
| int16\_t | int8\_t | none | int16\_t |
| int16\_t | int16\_t | none | int16\_t |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define N 64
#define K 256
#define M 128

#define SRC0\_DATA\_NUM (M \* K)
#define SRC1\_DATA\_NUM (K \* N)
#define DST\_DATA\_NUM (M \* N)

\_\_mlu\_entry\_\_ void MatmulKernel(half \*dst,
                                int16\_t \*src0,
                                int8\_t \*src1,
                                int M,
                                int K,
                                int N,
                                int pos) {
 \_\_nram\_\_ half nram\_dst[DST\_DATA\_NUM];
 \_\_nram\_\_ int16\_t nram\_src0[SRC0\_DATA\_NUM];
 \_\_wram\_\_ int8\_t wram\_src1[SRC1\_DATA\_NUM];
 \_\_memcpy(nram\_src0, src0, SRC0\_DATA\_NUM \* sizeof(int16\_t), GDRAM2NRAM);
 \_\_memcpy(wram\_src1, src1, SRC1\_DATA\_NUM \* sizeof(int8\_t), GDRAM2WRAM);
 \_\_bang\_matmul(nram\_dst, nram\_src0, wram\_src1, M, K, N, pos);
 \_\_memcpy(dst, nram\_dst, DST\_DATA\_NUM \* sizeof(half), NRAM2GDRAM);
}

```

















3.21. Scalar Type Conversion Functions
=======================================



3.21.1. \_\_bfloat162char
--------------------------




char `__bfloat162char`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t a) {
  char result;
  result = \_\_bfloat162char(a);
}

```













3.21.2. \_\_bfloat162char\_dn
------------------------------




char `__bfloat162char_dn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `char` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162char for more details.













3.21.3. \_\_bfloat162char\_oz
------------------------------




char `__bfloat162char_oz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `char` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162char for more details.













3.21.4. \_\_bfloat162char\_rd
------------------------------




char `__bfloat162char_rd`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `char` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162char for more details.













3.21.5. \_\_bfloat162char\_rm
------------------------------




char `__bfloat162char_rm`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `char` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162char for more details.













3.21.6. \_\_bfloat162char\_rn
------------------------------




char `__bfloat162char_rn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `char` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162char for more details.













3.21.7. \_\_bfloat162char\_tz
------------------------------




char `__bfloat162char_tz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162char for more details.













3.21.8. \_\_bfloat162char\_up
------------------------------




char `__bfloat162char_up`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `char` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162char for more details.













3.21.9. \_\_bfloat162float
---------------------------




float `__bfloat162float`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t a) {
  float result;
  result = \_\_bfloat162float(a);
}

```













3.21.10. \_\_bfloat162float\_dn
--------------------------------




float `__bfloat162float_dn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `float` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162float for more details.













3.21.11. \_\_bfloat162float\_oz
--------------------------------




float `__bfloat162float_oz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `float` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162float for more details.













3.21.12. \_\_bfloat162float\_rd
--------------------------------




float `__bfloat162float_rd`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `float` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162float for more details.













3.21.13. \_\_bfloat162float\_rm
--------------------------------




float `__bfloat162float_rm`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `float` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162float for more details.













3.21.14. \_\_bfloat162float\_rn
--------------------------------




float `__bfloat162float_rn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `float` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162float for more details.













3.21.15. \_\_bfloat162float\_tz
--------------------------------




float `__bfloat162float_tz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162float for more details.













3.21.16. \_\_bfloat162float\_up
--------------------------------




float `__bfloat162float_up`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `float` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162float for more details.













3.21.17. \_\_bfloat162half
---------------------------




half `__bfloat162half`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t a) {
  half result;
  result = \_\_bfloat162half(a);
}

```













3.21.18. \_\_bfloat162half\_dn
-------------------------------




half `__bfloat162half_dn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `half` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162half for more details.













3.21.19. \_\_bfloat162half\_oz
-------------------------------




half `__bfloat162half_oz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `half` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162half for more details.













3.21.20. \_\_bfloat162half\_rd
-------------------------------




half `__bfloat162half_rd`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `half` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162half for more details.













3.21.21. \_\_bfloat162half\_rm
-------------------------------




half `__bfloat162half_rm`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `half` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162half for more details.













3.21.22. \_\_bfloat162half\_rn
-------------------------------




half `__bfloat162half_rn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `half` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162half for more details.













3.21.23. \_\_bfloat162half\_tz
-------------------------------




half `__bfloat162half_tz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162half for more details.













3.21.24. \_\_bfloat162half\_up
-------------------------------




half `__bfloat162half_up`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `half` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162half for more details.













3.21.25. \_\_bfloat162int
--------------------------




int `__bfloat162int`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t a) {
  int result;
  result = \_\_bfloat162int(a);
}

```













3.21.26. \_\_bfloat162int\_dn
------------------------------




int `__bfloat162int_dn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `int` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162int for more details.













3.21.27. \_\_bfloat162int\_oz
------------------------------




int `__bfloat162int_oz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `int` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162int for more details.













3.21.28. \_\_bfloat162int\_rd
------------------------------




int `__bfloat162int_rd`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `int` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162int for more details.













3.21.29. \_\_bfloat162int\_rm
------------------------------




int `__bfloat162int_rm`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `int` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162int for more details.













3.21.30. \_\_bfloat162int\_rn
------------------------------




int `__bfloat162int_rn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `int` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162int for more details.













3.21.31. \_\_bfloat162int\_tz
------------------------------




int `__bfloat162int_tz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162int for more details.













3.21.32. \_\_bfloat162int\_up
------------------------------




int `__bfloat162int_up`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `int` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162int for more details.













3.21.33. \_\_bfloat162short
----------------------------




short `__bfloat162short`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t a) {
  short result;
  result = \_\_bfloat162short(a);
}

```













3.21.34. \_\_bfloat162short\_dn
--------------------------------




short `__bfloat162short_dn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `short` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162short for more details.













3.21.35. \_\_bfloat162short\_oz
--------------------------------




short `__bfloat162short_oz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `short` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162short for more details.













3.21.36. \_\_bfloat162short\_rd
--------------------------------




short `__bfloat162short_rd`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `short` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162short for more details.













3.21.37. \_\_bfloat162short\_rm
--------------------------------




short `__bfloat162short_rm`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `short` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162short for more details.













3.21.38. \_\_bfloat162short\_rn
--------------------------------




short `__bfloat162short_rn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `short` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162short for more details.













3.21.39. \_\_bfloat162short\_tz
--------------------------------




short `__bfloat162short_tz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162short for more details.













3.21.40. \_\_bfloat162short\_up
--------------------------------




short `__bfloat162short_up`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `short` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162short for more details.













3.21.41. \_\_bfloat162tf32
---------------------------




float `__bfloat162tf32`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t a) {
  float result;
  result = \_\_bfloat162tf32(a);
}

```













3.21.42. \_\_bfloat162tf32\_dn
-------------------------------




float `__bfloat162tf32_dn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `tf32` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162tf32 for more details.













3.21.43. \_\_bfloat162tf32\_oz
-------------------------------




float `__bfloat162tf32_oz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `tf32` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162tf32 for more details.













3.21.44. \_\_bfloat162tf32\_rd
-------------------------------




float `__bfloat162tf32_rd`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `tf32` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162tf32 for more details.













3.21.45. \_\_bfloat162tf32\_rm
-------------------------------




float `__bfloat162tf32_rm`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `tf32` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162tf32 for more details.













3.21.46. \_\_bfloat162tf32\_rn
-------------------------------




float `__bfloat162tf32_rn`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `tf32` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162tf32 for more details.













3.21.47. \_\_bfloat162tf32\_tz
-------------------------------




float `__bfloat162tf32_tz`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162tf32 for more details.













3.21.48. \_\_bfloat162tf32\_up
-------------------------------




float `__bfloat162tf32_up`(bfloat16\_t *a*)  

This function converts type of `a` from `bfloat16\_t` to `tf32` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bfloat162tf32 for more details.













3.21.49. \_\_char2bfloat16
---------------------------




bfloat16\_t `__char2bfloat16`(char *a*)  

This function converts type of `a` from `char` to `bfloat16\_t`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(char a) {
  bfloat16\_t result;
  result = \_\_char2bfloat16(a);
}

```













3.21.50. \_\_char2float
------------------------




float `__char2float`(char *a*)  

This function converts type of `a` from `char` to `float`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.21.51. \_\_char2half
-----------------------




half `__char2half`(char *a*)  

This function converts type of `a` from `char` to `half`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.21.52. \_\_char2tf32
-----------------------




float `__char2tf32`(char *a*)  

This function converts type of `a` from `char` to `tf32`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(char a) {
  float result;
  result = \_\_char2tf32(a);
}

```













3.21.53. \_\_float2bfloat16
----------------------------




bfloat16\_t `__float2bfloat16`(float *a*)  

This function converts type of `a` from `float` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  bfloat16\_t result;
  result = \_\_float2bfloat16(a);
}

```













3.21.54. \_\_float2bfloat16\_dn
--------------------------------




bfloat16\_t `__float2bfloat16_dn`(float *a*)  

This function converts type of `a` from `float` to `bfloat16\_t` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2bfloat16 for more details.













3.21.55. \_\_float2bfloat16\_oz
--------------------------------




bfloat16\_t `__float2bfloat16_oz`(float *a*)  

This function converts type of `a` from `float` to `bfloat16\_t` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2bfloat16 for more details.













3.21.56. \_\_float2bfloat16\_rd
--------------------------------




bfloat16\_t `__float2bfloat16_rd`(float *a*)  

This function converts type of `a` from `float` to `bfloat16\_t` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2bfloat16 for more details.













3.21.57. \_\_float2bfloat16\_rm
--------------------------------




bfloat16\_t `__float2bfloat16_rm`(float *a*)  

This function converts type of `a` from `float` to `bfloat16\_t` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2bfloat16 for more details.













3.21.58. \_\_float2bfloat16\_rn
--------------------------------




bfloat16\_t `__float2bfloat16_rn`(float *a*)  

This function converts type of `a` from `float` to `bfloat16\_t` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2bfloat16 for more details.













3.21.59. \_\_float2bfloat16\_tz
--------------------------------




bfloat16\_t `__float2bfloat16_tz`(float *a*)  

This function converts type of `a` from `float` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2bfloat16 for more details.













3.21.60. \_\_float2bfloat16\_up
--------------------------------




bfloat16\_t `__float2bfloat16_up`(float *a*)  

This function converts type of `a` from `float` to `bfloat16\_t` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2bfloat16 for more details.













3.21.61. \_\_float2char
------------------------




char `__float2char`(float *a*)  

This function converts type of `a` from `float` to `char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  char result;
  result = \_\_float2char(a);
}

```













3.21.62. \_\_float2char\_dn
----------------------------




char `__float2char_dn`(float *a*)  

This function converts type of `a` from `float` to `char` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2char for more details.













3.21.63. \_\_float2char\_oz
----------------------------




char `__float2char_oz`(float *a*)  

This function converts type of `a` from `float` to `char` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2char for more details.













3.21.64. \_\_float2char\_rd
----------------------------




char `__float2char_rd`(float *a*)  

This function converts type of `a` from `float` to `char` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2char for more details.













3.21.65. \_\_float2char\_rm
----------------------------




char `__float2char_rm`(float *a*)  

This function converts type of `a` from `float` to `char` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2char for more details.













3.21.66. \_\_float2char\_rn
----------------------------




char `__float2char_rn`(float *a*)  

This function converts type of `a` from `float` to `char` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2char for more details.













3.21.67. \_\_float2char\_tz
----------------------------




char `__float2char_tz`(float *a*)  

This function converts type of `a` from `float` to `char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark**

**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2char for more details.













3.21.68. \_\_float2char\_up
----------------------------




char `__float2char_up`(float *a*)  

This function converts type of `a` from `float` to `char` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2char for more details.













3.21.69. \_\_float2half
------------------------




half `__float2half`(float *a*)  

This function converts type of `a` from `float` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2half\_tz for more details.













3.21.70. \_\_float2half\_dn
----------------------------




half `__float2half_dn`(float *a*)  

This function converts type of `a` from `float` to `half` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2half\_tz for more details.













3.21.71. \_\_float2half\_oz
----------------------------




half `__float2half_oz`(float *a*)  

This function converts type of `a` from `float` to `half` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2half\_tz for more details.













3.21.72. \_\_float2half\_rd
----------------------------




half `__float2half_rd`(float *a*)  

This function converts type of `a` from `float` to `half` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2half\_tz for more details.













3.21.73. \_\_float2half\_rm
----------------------------




half `__float2half_rm`(float *a*)  

This function converts type of `a` from `float` to `half` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2half\_tz for more details.













3.21.74. \_\_float2half\_rn
----------------------------




half `__float2half_rn`(float *a*)  

This function converts type of `a` from `float` to `half` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2half\_tz for more details.













3.21.75. \_\_float2half\_tz
----------------------------




half `__float2half_tz`(float *a*)  

This function converts type of `a` from `float` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  half result;
  result = \_\_float2half\_tz(a);
}

```













3.21.76. \_\_float2half\_up
----------------------------




half `__float2half_up`(float *a*)  

This function converts type of `a` from `float` to `half` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2half\_tz for more details.













3.21.77. \_\_float2int
-----------------------




int `__float2int`(float *a*)  

This function converts type of `a` from `float` to `int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2int\_tz for more details.













3.21.78. \_\_float2int\_dn
---------------------------




int `__float2int_dn`(float *a*)  

This function converts type of `a` from `float` to `int` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2int\_tz for more details.













3.21.79. \_\_float2int\_oz
---------------------------




int `__float2int_oz`(float *a*)  

This function converts type of `a` from `float` to `int` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2int\_tz for more details.













3.21.80. \_\_float2int\_rd
---------------------------




int `__float2int_rd`(float *a*)  

This function converts type of `a` from `float` to `int` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2int\_tz for more details.













3.21.81. \_\_float2int\_rm
---------------------------




int `__float2int_rm`(float *a*)  

This function converts type of `a` from `float` to `int` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2int\_tz for more details.













3.21.82. \_\_float2int\_rn
---------------------------




int `__float2int_rn`(float *a*)  

This function converts type of `a` from `float` to `int` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2int\_tz for more details.













3.21.83. \_\_float2int\_tz
---------------------------




int `__float2int_tz`(float *a*)  

This function converts type of `a` from `float` to `int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  int result;
  result = \_\_float2int\_tz(a);
}

```













3.21.84. \_\_float2int\_up
---------------------------




int `__float2int_up`(float *a*)  

This function converts type of `a` from `float` to `int` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2int\_tz for more details.













3.21.85. \_\_float2short
-------------------------




short `__float2short`(float *a*)  

This function converts type of `a` from `float` to `short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2short\_tz for more details.













3.21.86. \_\_float2short\_dn
-----------------------------




short `__float2short_dn`(float *a*)  

This function converts type of `a` from `float` to `short` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2short\_tz for more details.













3.21.87. \_\_float2short\_oz
-----------------------------




short `__float2short_oz`(float *a*)  

This function converts type of `a` from `float` to `short` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2short\_tz for more details.













3.21.88. \_\_float2short\_rd
-----------------------------




short `__float2short_rd`(float *a*)  

This function converts type of `a` from `float` to `short` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2short\_tz for more details.













3.21.89. \_\_float2short\_rm
-----------------------------




short `__float2short_rm`(float *a*)  

This function converts type of `a` from `float` to `short` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2short\_tz for more details.













3.21.90. \_\_float2short\_rn
-----------------------------




short `__float2short_rn`(float *a*)  

This function converts type of `a` from `float` to `short` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2short\_tz for more details.













3.21.91. \_\_float2short\_tz
-----------------------------




short `__float2short_tz`(float *a*)  

This function converts type of `a` from `float` to `short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  short result;
  result = \_\_float2short\_tz(a);
}

```













3.21.92. \_\_float2short\_up
-----------------------------




short `__float2short_up`(float *a*)  

This function converts type of `a` from `float` to `short` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2short\_tz for more details.













3.21.93. \_\_float2tf32
------------------------




float `__float2tf32`(float *a*)  

This function converts type of `a` from `float` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  float result;
  result = \_\_float2tf32(a);
}

```













3.21.94. \_\_float2tf32\_dn
----------------------------




float `__float2tf32_dn`(float *a*)  

This function converts type of `a` from `float` to `tf32` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2tf32 for more details.













3.21.95. \_\_float2tf32\_oz
----------------------------




float `__float2tf32_oz`(float *a*)  

This function converts type of `a` from `float` to `tf32` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2tf32 for more details.













3.21.96. \_\_float2tf32\_rd
----------------------------




float `__float2tf32_rd`(float *a*)  

This function converts type of `a` from `float` to `tf32` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2tf32 for more details.













3.21.97. \_\_float2tf32\_rm
----------------------------




float `__float2tf32_rm`(float *a*)  

This function converts type of `a` from `float` to `tf32` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2tf32 for more details.













3.21.98. \_\_float2tf32\_rn
----------------------------




float `__float2tf32_rn`(float *a*)  

This function converts type of `a` from `float` to `tf32` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2tf32 for more details.













3.21.99. \_\_float2tf32\_tz
----------------------------




float `__float2tf32_tz`(float *a*)  

This function converts type of `a` from `float` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2tf32 for more details.













3.21.100. \_\_float2tf32\_up
-----------------------------




float `__float2tf32_up`(float *a*)  

This function converts type of `a` from `float` to `tf32` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_float2tf32 for more details.













3.21.101. \_\_float2uchar
--------------------------




unsigned char `__float2uchar`(float *a*)  

This function converts type of `a` from `float` to `unsigned char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  unsigned char result;
  result = \_\_float2uchar(a);
}

```













3.21.102. \_\_float2uchar\_dn
------------------------------




unsigned char `__float2uchar_dn`(float *a*)  

This function converts type of `a` from `float` to `unsigned char` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uchar for more details.













3.21.103. \_\_float2uchar\_oz
------------------------------




unsigned char `__float2uchar_oz`(float *a*)  

This function converts type of `a` from `float` to `unsigned char` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uchar for more details.













3.21.104. \_\_float2uchar\_rd
------------------------------




unsigned char `__float2uchar_rd`(float *a*)  

This function converts type of `a` from `float` to `unsigned char` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uchar for more details.













3.21.105. \_\_float2uchar\_rm
------------------------------




unsigned char `__float2uchar_rm`(float *a*)  

This function converts type of `a` from `float` to `unsigned char` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2uchar for more details.













3.21.106. \_\_float2uchar\_rn
------------------------------




unsigned char `__float2uchar_rn`(float *a*)  

This function converts type of `a` from `float` to `unsigned char` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2uchar for more details.













3.21.107. \_\_float2uchar\_tz
------------------------------




unsigned char `__float2uchar_tz`(float *a*)  

This function converts type of `a` from `float` to `unsigned char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uchar for more details.













3.21.108. \_\_float2uchar\_up
------------------------------




unsigned char `__float2uchar_up`(float *a*)  

This function converts type of `a` from `float` to `unsigned char` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uchar for more details.













3.21.109. \_\_float2uint
-------------------------




unsigned int `__float2uint`(float *a*)  

This function converts type of `a` from `float` to `unsigned int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  unsigned int result;
  result = \_\_float2uint(a);
}

```













3.21.110. \_\_float2uint\_dn
-----------------------------




unsigned int `__float2uint_dn`(float *a*)  

This function converts type of `a` from `float` to `unsigned int` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uint for more details.













3.21.111. \_\_float2uint\_oz
-----------------------------




unsigned int `__float2uint_oz`(float *a*)  

This function converts type of `a` from `float` to `unsigned int` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uint for more details.













3.21.112. \_\_float2uint\_rd
-----------------------------




unsigned int `__float2uint_rd`(float *a*)  

This function converts type of `a` from `float` to `unsigned int` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uint for more details.













3.21.113. \_\_float2uint\_rm
-----------------------------




unsigned int `__float2uint_rm`(float *a*)  

This function converts type of `a` from `float` to `unsigned int` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2uint for more details.













3.21.114. \_\_float2uint\_rn
-----------------------------




unsigned int `__float2uint_rn`(float *a*)  

This function converts type of `a` from `float` to `unsigned int` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2uint for more details.













3.21.115. \_\_float2uint\_tz
-----------------------------




unsigned int `__float2uint_tz`(float *a*)  

This function converts type of `a` from `float` to `unsigned int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uint for more details.













3.21.116. \_\_float2uint\_up
-----------------------------




unsigned int `__float2uint_up`(float *a*)  

This function converts type of `a` from `float` to `unsigned int` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2uint for more details.













3.21.117. \_\_float2ushort
---------------------------




unsigned short `__float2ushort`(float *a*)  

This function converts type of `a` from `float` to `unsigned short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  unsigned short result;
  result = \_\_float2ushort(a);
}

```













3.21.118. \_\_float2ushort\_dn
-------------------------------




unsigned short `__float2ushort_dn`(float *a*)  

This function converts type of `a` from `float` to `unsigned short` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2ushort for more details.













3.21.119. \_\_float2ushort\_oz
-------------------------------




unsigned short `__float2ushort_oz`(float *a*)  

This function converts type of `a` from `float` to `unsigned short` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2ushort for more details.













3.21.120. \_\_float2ushort\_rd
-------------------------------




unsigned short `__float2ushort_rd`(float *a*)  

This function converts type of `a` from `float` to `unsigned short` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2ushort for more details.













3.21.121. \_\_float2ushort\_rm
-------------------------------




unsigned short `__float2ushort_rm`(float *a*)  

This function converts type of `a` from `float` to `unsigned short` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2ushort for more details.













3.21.122. \_\_float2ushort\_rn
-------------------------------




unsigned short `__float2ushort_rn`(float *a*)  

This function converts type of `a` from `float` to `unsigned short` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_float2ushort for more details.













3.21.123. \_\_float2ushort\_tz
-------------------------------




unsigned short `__float2ushort_tz`(float *a*)  

This function converts type of `a` from `float` to `unsigned short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2ushort for more details.













3.21.124. \_\_float2ushort\_up
-------------------------------




unsigned short `__float2ushort_up`(float *a*)  

This function converts type of `a` from `float` to `unsigned short` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_float2ushort for more details.













3.21.125. \_\_half2bfloat16
----------------------------




bfloat16\_t `__half2bfloat16`(half *a*)  

This function converts type of `a` from `half` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(half a) {
  bfloat16\_t result;
  result = \_\_half2bfloat16(a);
}

```













3.21.126. \_\_half2bfloat16\_dn
--------------------------------




bfloat16\_t `__half2bfloat16_dn`(half *a*)  

This function converts type of `a` from `half` to `bfloat16\_t` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2bfloat16 for more details.













3.21.127. \_\_half2bfloat16\_oz
--------------------------------




bfloat16\_t `__half2bfloat16_oz`(half *a*)  

This function converts type of `a` from `half` to `bfloat16\_t` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2bfloat16 for more details.













3.21.128. \_\_half2bfloat16\_rd
--------------------------------




bfloat16\_t `__half2bfloat16_rd`(half *a*)  

This function converts type of `a` from `half` to `bfloat16\_t` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2bfloat16 for more details.













3.21.129. \_\_half2bfloat16\_rm
--------------------------------




bfloat16\_t `__half2bfloat16_rm`(half *a*)  

This function converts type of `a` from `half` to `bfloat16\_t` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2bfloat16 for more details.













3.21.130. \_\_half2bfloat16\_rn
--------------------------------




bfloat16\_t `__half2bfloat16_rn`(half *a*)  

This function converts type of `a` from `half` to `bfloat16\_t` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2bfloat16 for more details.













3.21.131. \_\_half2bfloat16\_tz
--------------------------------




bfloat16\_t `__half2bfloat16_tz`(half *a*)  

This function converts type of `a` from `half` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2bfloat16 for more details.













3.21.132. \_\_half2bfloat16\_up
--------------------------------




bfloat16\_t `__half2bfloat16_up`(half *a*)  

This function converts type of `a` from `half` to `bfloat16\_t` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2bfloat16 for more details.













3.21.133. \_\_half2char
------------------------




char `__half2char`(half *a*)  

This function converts type of `a` from `half` to `char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(half a) {
  char result;
  result = \_\_half2char(a);
}

```













3.21.134. \_\_half2char\_dn
----------------------------




char `__half2char_dn`(half *a*)  

This function converts type of `a` from `half` to `char` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2char for more details.













3.21.135. \_\_half2char\_oz
----------------------------




char `__half2char_oz`(half *a*)  

This function converts type of `a` from `half` to `char` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2char for more details.













3.21.136. \_\_half2char\_rd
----------------------------




char `__half2char_rd`(half *a*)  

This function converts type of `a` from `half` to `char` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2char for more details.













3.21.137. \_\_half2char\_rm
----------------------------




char `__half2char_rm`(half *a*)  

This function converts type of `a` from `half` to `char` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2char for more details.













3.21.138. \_\_half2char\_rn
----------------------------




char `__half2char_rn`(half *a*)  

This function converts type of `a` from `half` to `char` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2char for more details.













3.21.139. \_\_half2char\_tz
----------------------------




char `__half2char_tz`(half *a*)  

This function converts type of `a` from `half` to `char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2char for more details.













3.21.140. \_\_half2char\_up
----------------------------




char `__half2char_up`(half *a*)  

This function converts type of `a` from `half` to `char` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2char for more details.













3.21.141. \_\_half2float
-------------------------




float `__half2float`(half *a*)  

This function converts type of `a` from `half` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(half a) {
  float result;
  result = \_\_half2float(a);
}

```













3.21.142. \_\_half2float\_dn
-----------------------------




float `__half2float_dn`(half *a*)  

This function converts type of `a` from `half` to `float` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2float for more details.













3.21.143. \_\_half2float\_oz
-----------------------------




float `__half2float_oz`(half *a*)  

This function converts type of `a` from `half` to `float` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2float for more details.













3.21.144. \_\_half2float\_rd
-----------------------------




float `__half2float_rd`(half *a*)  

This function converts type of `a` from `half` to `float` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2float for more details.













3.21.145. \_\_half2float\_rm
-----------------------------




float `__half2float_rm`(half *a*)  

This function converts type of `a` from `half` to `float` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2float for more details.













3.21.146. \_\_half2float\_rn
-----------------------------




float `__half2float_rn`(half *a*)  

This function converts type of `a` from `half` to `float` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2float for more details.













3.21.147. \_\_half2float\_tz
-----------------------------




float `__half2float_tz`(half *a*)  

This function converts type of `a` from `half` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2float for more details.













3.21.148. \_\_half2float\_up
-----------------------------




float `__half2float_up`(half *a*)  

This function converts type of `a` from `half` to `float` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2float for more details.













3.21.149. \_\_half2int
-----------------------




int `__half2int`(half *a*)  

This function converts type of `a` from `half` to `int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2int\_tz for more details.













3.21.150. \_\_half2int\_dn
---------------------------




int `__half2int_dn`(half *a*)  

This function converts type of `a` from `half` to `int` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2int\_tz for more details.













3.21.151. \_\_half2int\_oz
---------------------------




int `__half2int_oz`(half *a*)  

This function converts type of `a` from `half` to `int` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2int\_tz for more details.













3.21.152. \_\_half2int\_rd
---------------------------




int `__half2int_rd`(half *a*)  

This function converts type of `a` from `half` to `int` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2int\_tz for more details.













3.21.153. \_\_half2int\_rm
---------------------------




int `__half2int_rm`(half *a*)  

This function converts type of `a` from `half` to `int` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2int\_tz for more details.













3.21.154. \_\_half2int\_rn
---------------------------




int `__half2int_rn`(half *a*)  

This function converts type of `a` from `half` to `int` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2int\_tz for more details.













3.21.155. \_\_half2int\_tz
---------------------------




int `__half2int_tz`(half *a*)  

This function converts type of `a` from `half` to `int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

 \_\_mlu\_entry\_\_ void kernel(float a) {
   int result;
   result = \_\_half2int\_tz(a);
 }

```













3.21.156. \_\_half2int\_up
---------------------------




int `__half2int_up`(half *a*)  

This function converts type of `a` from `half` to `int` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2int\_tz for more details.













3.21.157. \_\_half2short
-------------------------




short `__half2short`(half *a*)  

This function converts type of `a` from `half` to `short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2short\_tz for more details.













3.21.158. \_\_half2short\_dn
-----------------------------




short `__half2short_dn`(half *a*)  

This function converts type of `a` from `half` to `short` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2short\_tz for more details.













3.21.159. \_\_half2short\_oz
-----------------------------




short `__half2short_oz`(half *a*)  

This function converts type of `a` from `half` to `short` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2short\_tz for more details.













3.21.160. \_\_half2short\_rd
-----------------------------




short `__half2short_rd`(half *a*)  

This function converts type of `a` from `half` to `short` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2short\_tz for more details.













3.21.161. \_\_half2short\_rm
-----------------------------




short `__half2short_rm`(half *a*)  

This function converts type of `a` from `half` to `short` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2short\_tz for more details.













3.21.162. \_\_half2short\_rn
-----------------------------




short `__half2short_rn`(half *a*)  

This function converts type of `a` from `half` to `short` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2short\_tz for more details.













3.21.163. \_\_half2short\_tz
-----------------------------




short `__half2short_tz`(half *a*)  

This function converts type of `a` from `half` to `short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(half a) {
  short result;
  result = \_\_half2short\_tz(a);
}

```













3.21.164. \_\_half2short\_up
-----------------------------




short `__half2short_up`(half *a*)  

This function converts type of `a` from `half` to `short` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2short\_tz for more details.













3.21.165. \_\_half2tf32
------------------------




float `__half2tf32`(half *a*)  

This function converts type of `a` from `half` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(half a) {
  float result;
  result = \_\_half2tf32(a);
}

```













3.21.166. \_\_half2tf32\_dn
----------------------------




float `__half2tf32_dn`(half *a*)  

This function converts type of `a` from `half` to `tf32` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2tf32 for more details.













3.21.167. \_\_half2tf32\_oz
----------------------------




float `__half2tf32_oz`(half *a*)  

This function converts type of `a` from `half` to `tf32` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2tf32 for more details.













3.21.168. \_\_half2tf32\_rd
----------------------------




float `__half2tf32_rd`(half *a*)  

This function converts type of `a` from `half` to `tf32` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2tf32 for more details.













3.21.169. \_\_half2tf32\_rm
----------------------------




float `__half2tf32_rm`(half *a*)  

This function converts type of `a` from `half` to `tf32` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2tf32 for more details.













3.21.170. \_\_half2tf32\_rn
----------------------------




float `__half2tf32_rn`(half *a*)  

This function converts type of `a` from `half` to `tf32` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2tf32 for more details.













3.21.171. \_\_half2tf32\_tz
----------------------------




float `__half2tf32_tz`(half *a*)  

This function converts type of `a` from `half` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2tf32 for more details.













3.21.172. \_\_half2tf32\_up
----------------------------




float `__half2tf32_up`(half *a*)  

This function converts type of `a` from `half` to `tf32` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_half2tf32 for more details.













3.21.173. \_\_half2uchar
-------------------------




unsigned char `__half2uchar`(half *a*)  

This function converts type of `a` from `half` to `unsigned char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(half a) {
  unsigned char result;
  result = \_\_half2uchar(a);
}

```













3.21.174. \_\_half2uchar\_dn
-----------------------------




unsigned char `__half2uchar_dn`(half *a*)  

This function converts type of `a` from `half` to `unsigned char` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uchar for more details.













3.21.175. \_\_half2uchar\_oz
-----------------------------




unsigned char `__half2uchar_oz`(half *a*)  

This function converts type of `a` from `half` to `unsigned char` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uchar for more details.













3.21.176. \_\_half2uchar\_rd
-----------------------------




unsigned char `__half2uchar_rd`(half *a*)  

This function converts type of `a` from `half` to `unsigned char` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uchar for more details.













3.21.177. \_\_half2uchar\_rm
-----------------------------




unsigned char `__half2uchar_rm`(half *a*)  

This function converts type of `a` from `half` to `unsigned char` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2uchar for more details.













3.21.178. \_\_half2uchar\_rn
-----------------------------




unsigned char `__half2uchar_rn`(half *a*)  

This function converts type of `a` from `half` to `unsigned char` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2uchar for more details.













3.21.179. \_\_half2uchar\_tz
-----------------------------




unsigned char `__half2uchar_tz`(half *a*)  

This function converts type of `a` from `half` to `unsigned char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uchar for more details.













3.21.180. \_\_half2uchar\_up
-----------------------------




unsigned char `__half2uchar_up`(half *a*)  

This function converts type of `a` from `half` to `unsigned char` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uchar for more details.













3.21.181. \_\_half2uint
------------------------




unsigned int `__half2uint`(half *a*)  

This function converts type of `a` from `half` to `unsigned int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(half a) {
  unsigned int result;
  result = \_\_half2uint(a);
}

```













3.21.182. \_\_half2uint\_dn
----------------------------




unsigned int `__half2uint_dn`(half *a*)  

This function converts type of `a` from `half` to `unsigned int` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uint for more details.













3.21.183. \_\_half2uint\_oz
----------------------------




unsigned int `__half2uint_oz`(half *a*)  

This function converts type of `a` from `half` to `unsigned int` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uint for more details.













3.21.184. \_\_half2uint\_rd
----------------------------




unsigned int `__half2uint_rd`(half *a*)  

This function converts type of `a` from `half` to `unsigned int` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uint for more details.













3.21.185. \_\_half2uint\_rm
----------------------------




unsigned int `__half2uint_rm`(half *a*)  

This function converts type of `a` from `half` to `unsigned int` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2uint for more details.













3.21.186. \_\_half2uint\_rn
----------------------------




unsigned int `__half2uint_rn`(half *a*)  

This function converts type of `a` from `half` to `unsigned int` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2uint for more details.













3.21.187. \_\_half2uint\_tz
----------------------------




unsigned int `__half2uint_tz`(half *a*)  

This function converts type of `a` from `half` to `unsigned int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uint for more details.













3.21.188. \_\_half2uint\_up
----------------------------




unsigned int `__half2uint_up`(half *a*)  

This function converts type of `a` from `half` to `unsigned int` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2uint for more details.













3.21.189. \_\_half2ushort
--------------------------




unsigned short `__half2ushort`(half *a*)  

This function converts type of `a` from `half` to `unsigned short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(half a) {
  unsigned short result;
  result = \_\_half2ushort(a);
}

```













3.21.190. \_\_half2ushort\_dn
------------------------------




unsigned short `__half2ushort_dn`(half *a*)  

This function converts type of `a` from `half` to `unsigned short` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2ushort for more details.













3.21.191. \_\_half2ushort\_oz
------------------------------




unsigned short `__half2ushort_oz`(half *a*)  

This function converts type of `a` from `half` to `unsigned short` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2ushort for more details.













3.21.192. \_\_half2ushort\_rd
------------------------------




unsigned short `__half2ushort_rd`(half *a*)  

This function converts type of `a` from `half` to `unsigned short` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2ushort for more details.













3.21.193. \_\_half2ushort\_rm
------------------------------




unsigned short `__half2ushort_rm`(half *a*)  

This function converts type of `a` from `half` to `unsigned short` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2ushort for more details.













3.21.194. \_\_half2ushort\_rn
------------------------------




unsigned short `__half2ushort_rn`(half *a*)  

This function converts type of `a` from `half` to `unsigned short` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_half2ushort for more details.













3.21.195. \_\_half2ushort\_tz
------------------------------




unsigned short `__half2ushort_tz`(half *a*)  

This function converts type of `a` from `half` to `unsigned short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2ushort for more details.













3.21.196. \_\_half2ushort\_up
------------------------------




unsigned short `__half2ushort_up`(half *a*)  

This function converts type of `a` from `half` to `unsigned short` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_half2ushort for more details.













3.21.197. \_\_int2bfloat16
---------------------------




bfloat16\_t `__int2bfloat16`(int *a*)  

This function converts type of `a` from `int` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int a) {
  bfloat16\_t result;
  result = \_\_int2bfloat16(a);
}

```













3.21.198. \_\_int2bfloat16\_dn
-------------------------------




bfloat16\_t `__int2bfloat16_dn`(int *a*)  

This function converts type of `a` from `int` to `bfloat16\_t` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2bfloat16 for more details.













3.21.199. \_\_int2bfloat16\_oz
-------------------------------




bfloat16\_t `__int2bfloat16_oz`(int *a*)  

This function converts type of `a` from `int` to `bfloat16\_t` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2bfloat16 for more details.













3.21.200. \_\_int2bfloat16\_rd
-------------------------------




bfloat16\_t `__int2bfloat16_rd`(int *a*)  

This function converts type of `a` from `int` to `bfloat16\_t` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2bfloat16 for more details.













3.21.201. \_\_int2bfloat16\_rm
-------------------------------




bfloat16\_t `__int2bfloat16_rm`(int *a*)  

This function converts type of `a` from `int` to `bfloat16\_t` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2bfloat16 for more details.













3.21.202. \_\_int2bfloat16\_rn
-------------------------------




bfloat16\_t `__int2bfloat16_rn`(int *a*)  

This function converts type of `a` from `int` to `bfloat16\_t` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2bfloat16 for more details.













3.21.203. \_\_int2bfloat16\_tz
-------------------------------




bfloat16\_t `__int2bfloat16_tz`(int *a*)  

This function converts type of `a` from `int` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2bfloat16 for more details.













3.21.204. \_\_int2bfloat16\_up
-------------------------------




bfloat16\_t `__int2bfloat16_up`(int *a*)  

This function converts type of `a` from `int` to `bfloat16\_t` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2bfloat16 for more details.













3.21.205. \_\_int2float
------------------------




float `__int2float`(int *a*)  

This function converts type of `a` from `int` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int a) {
  float result;
  result = \_\_int2float(a);
}

```













3.21.206. \_\_int2float\_dn
----------------------------




float `__int2float_dn`(int *a*)  

This function converts type of `a` from `int` to `float` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2float for more details.













3.21.207. \_\_int2float\_oz
----------------------------




float `__int2float_oz`(int *a*)  

This function converts type of `a` from `int` to `float` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2float for more details.













3.21.208. \_\_int2float\_rd
----------------------------




float `__int2float_rd`(int *a*)  

This function converts type of `a` from `int` to `float` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2float for more details.













3.21.209. \_\_int2float\_rm
----------------------------




float `__int2float_rm`(int *a*)  

This function converts type of `a` from `int` to `float` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_int2float for more details.













3.21.210. \_\_int2float\_rn
----------------------------




float `__int2float_rn`(int *a*)  

This function converts type of `a` from `int` to `float` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_int2float for more details.













3.21.211. \_\_int2float\_tz
----------------------------




float `__int2float_tz`(int *a*)  

This function converts type of `a` from `int` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2float for more details.













3.21.212. \_\_int2float\_up
----------------------------




float `__int2float_up`(int *a*)  

This function converts type of `a` from `int` to `float` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2float for more details.













3.21.213. \_\_int2half
-----------------------




half `__int2half`(int *a*)  

This function converts type of `a` from `int` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2half\_tz for more details.













3.21.214. \_\_int2half\_dn
---------------------------




half `__int2half_dn`(int *a*)  

This function converts type of `a` from `int` to `half` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2half\_tz for more details.













3.21.215. \_\_int2half\_oz
---------------------------




half `__int2half_oz`(int *a*)  

This function converts type of `a` from `int` to `half` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2half\_tz for more details.













3.21.216. \_\_int2half\_rd
---------------------------




half `__int2half_rd`(int *a*)  

This function converts type of `a` from `int` to `half` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2half\_tz for more details.













3.21.217. \_\_int2half\_rm
---------------------------




half `__int2half_rm`(int *a*)  

This function converts type of `a` from `int` to `half` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_int2half\_tz for more details.













3.21.218. \_\_int2half\_rn
---------------------------




half `__int2half_rn`(int *a*)  

This function converts type of `a` from `int` to `half` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_int2half\_tz for more details.













3.21.219. \_\_int2half\_tz
---------------------------




half `__int2half_tz`(int *a*)  

This function converts type of `a` from `int` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

 \_\_mlu\_entry\_\_ void kernel(int a) {
   half result;
   result = \_\_int2half\_tz(a);
 }

```













3.21.220. \_\_int2half\_up
---------------------------




half `__int2half_up`(int *a*)  

This function converts type of `a` from `int` to `half` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_int2half\_tz for more details.













3.21.221. \_\_int2tf32
-----------------------




float `__int2tf32`(int *a*)  

This function converts type of `a` from `int` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int a) {
  float result;
  result = \_\_int2tf32(a);
}

```













3.21.222. \_\_int2tf32\_dn
---------------------------




float `__int2tf32_dn`(int *a*)  

This function converts type of `a` from `int` to `tf32` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2tf32 for more details.













3.21.223. \_\_int2tf32\_oz
---------------------------




float `__int2tf32_oz`(int *a*)  

This function converts type of `a` from `int` to `tf32` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2tf32 for more details.













3.21.224. \_\_int2tf32\_rd
---------------------------




float `__int2tf32_rd`(int *a*)  

This function converts type of `a` from `int` to `tf32` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2tf32 for more details.













3.21.225. \_\_int2tf32\_rm
---------------------------




float `__int2tf32_rm`(int *a*)  

This function converts type of `a` from `int` to `tf32` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2tf32 for more details.













3.21.226. \_\_int2tf32\_rn
---------------------------




float `__int2tf32_rn`(int *a*)  

This function converts type of `a` from `int` to `tf32` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2tf32 for more details.













3.21.227. \_\_int2tf32\_tz
---------------------------




float `__int2tf32_tz`(int *a*)  

This function converts type of `a` from `int` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2tf32 for more details.













3.21.228. \_\_int2tf32\_up
---------------------------




float `__int2tf32_up`(int *a*)  

This function converts type of `a` from `int` to `tf32` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_int2tf32 for more details.













3.21.229. \_\_popcnt
---------------------




unsigned char `__popcnt`(unsigned char *src*)  




unsigned short `__popcnt`(unsigned short *src*)  




unsigned int `__popcnt`(unsigned int *src*)  

Counts the number of bits that are set to 1 in `<src>`.



**Parameters*** `[in] src`: The input data.



**Return*** `unsigned char/short/int`.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.4.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.21.230. \_\_short2bfloat16
-----------------------------




bfloat16\_t `__short2bfloat16`(short *a*)  

This function converts type of `a` from `short` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short a) {
  bfloat16\_t result;
  result = \_\_short2bfloat16(a);
}

```













3.21.231. \_\_short2bfloat16\_dn
---------------------------------




bfloat16\_t `__short2bfloat16_dn`(short *a*)  

This function converts type of `a` from `short` to `bfloat16\_t` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2bfloat16 for more details.













3.21.232. \_\_short2bfloat16\_oz
---------------------------------




bfloat16\_t `__short2bfloat16_oz`(short *a*)  

This function converts type of `a` from `short` to `bfloat16\_t` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2bfloat16 for more details.













3.21.233. \_\_short2bfloat16\_rd
---------------------------------




bfloat16\_t `__short2bfloat16_rd`(short *a*)  

This function converts type of `a` from `short` to `bfloat16\_t` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2bfloat16 for more details.













3.21.234. \_\_short2bfloat16\_rm
---------------------------------




bfloat16\_t `__short2bfloat16_rm`(short *a*)  

This function converts type of `a` from `short` to `bfloat16\_t` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2bfloat16 for more details.













3.21.235. \_\_short2bfloat16\_rn
---------------------------------




bfloat16\_t `__short2bfloat16_rn`(short *a*)  

This function converts type of `a` from `short` to `bfloat16\_t` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2bfloat16 for more details.













3.21.236. \_\_short2bfloat16\_tz
---------------------------------




bfloat16\_t `__short2bfloat16_tz`(short *a*)  

This function converts type of `a` from `short` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2bfloat16 for more details.













3.21.237. \_\_short2bfloat16\_up
---------------------------------




bfloat16\_t `__short2bfloat16_up`(short *a*)  

This function converts type of `a` from `short` to `bfloat16\_t` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2bfloat16 for more details.













3.21.238. \_\_short2float
--------------------------




float `__short2float`(short *a*)  

This function converts type of `a` from `short` to `float`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.21.239. \_\_short2half
-------------------------




half `__short2half`(short *a*)  

This function converts type of `a` from `short` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_short2half\_tz for more details.













3.21.240. \_\_short2half\_dn
-----------------------------




half `__short2half_dn`(short *a*)  

This function converts type of `a` from `short` to `half` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_short2half\_tz for more details.













3.21.241. \_\_short2half\_oz
-----------------------------




half `__short2half_oz`(short *a*)  

This function converts type of `a` from `short` to `half` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_short2half\_tz for more details.













3.21.242. \_\_short2half\_rd
-----------------------------




half `__short2half_rd`(short *a*)  

This function converts type of `a` from `short` to `half` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_short2half\_tz for more details.













3.21.243. \_\_short2half\_rm
-----------------------------




half `__short2half_rm`(short *a*)  

This function converts type of `a` from `short` to `half` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_short2half\_tz for more details.













3.21.244. \_\_short2half\_rn
-----------------------------




half `__short2half_rn`(short *a*)  

This function converts type of `a` from `short` to `half` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_short2half\_tz for more details.













3.21.245. \_\_short2half\_tz
-----------------------------




half `__short2half_tz`(short *a*)  

This function converts type of `a` from `short` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short a) {
  half result;
  result = \_\_short2half\_tz(a);
}

```













3.21.246. \_\_short2half\_up
-----------------------------




half `__short2half_up`(short *a*)  

This function converts type of `a` from `short` to `half` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_short2half\_tz for more details.













3.21.247. \_\_short2tf32
-------------------------




float `__short2tf32`(short *a*)  

This function converts type of `a` from `short` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(short a) {
  float result;
  result = \_\_short2tf32(a);
}

```













3.21.248. \_\_short2tf32\_dn
-----------------------------




float `__short2tf32_dn`(short *a*)  

This function converts type of `a` from `short` to `tf32` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2tf32 for more details.













3.21.249. \_\_short2tf32\_oz
-----------------------------




float `__short2tf32_oz`(short *a*)  

This function converts type of `a` from `short` to `tf32` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2tf32 for more details.













3.21.250. \_\_short2tf32\_rd
-----------------------------




float `__short2tf32_rd`(short *a*)  

This function converts type of `a` from `short` to `tf32` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2tf32 for more details.













3.21.251. \_\_short2tf32\_rm
-----------------------------




float `__short2tf32_rm`(short *a*)  

This function converts type of `a` from `short` to `tf32` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2tf32 for more details.













3.21.252. \_\_short2tf32\_rn
-----------------------------




float `__short2tf32_rn`(short *a*)  

This function converts type of `a` from `short` to `tf32` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2tf32 for more details.













3.21.253. \_\_short2tf32\_tz
-----------------------------




float `__short2tf32_tz`(short *a*)  

This function converts type of `a` from `short` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2tf32 for more details.













3.21.254. \_\_short2tf32\_up
-----------------------------




float `__short2tf32_up`(short *a*)  

This function converts type of `a` from `short` to `tf32` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_short2tf32 for more details.













3.21.255. \_\_tf322bfloat16
----------------------------




bfloat16\_t `__tf322bfloat16`(float *a*)  

This function converts type of `a` from `tf32` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  bfloat16\_t result;
  result = \_\_tf322bfloat16(a);
}

```













3.21.256. \_\_tf322bfloat16\_dn
--------------------------------




bfloat16\_t `__tf322bfloat16_dn`(float *a*)  

This function converts type of `a` from `tf32` to `bfloat16\_t` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322bfloat16 for more details.













3.21.257. \_\_tf322bfloat16\_oz
--------------------------------




bfloat16\_t `__tf322bfloat16_oz`(float *a*)  

This function converts type of `a` from `tf32` to `bfloat16\_t` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322bfloat16 for more details.













3.21.258. \_\_tf322bfloat16\_rd
--------------------------------




bfloat16\_t `__tf322bfloat16_rd`(float *a*)  

This function converts type of `a` from `tf32` to `bfloat16\_t` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322bfloat16 for more details.













3.21.259. \_\_tf322bfloat16\_rm
--------------------------------




bfloat16\_t `__tf322bfloat16_rm`(float *a*)  

This function converts type of `a` from `tf32` to `bfloat16\_t` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322bfloat16 for more details.













3.21.260. \_\_tf322bfloat16\_rn
--------------------------------




bfloat16\_t `__tf322bfloat16_rn`(float *a*)  

This function converts type of `a` from `tf32` to `bfloat16\_t` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322bfloat16 for more details.













3.21.261. \_\_tf322bfloat16\_tz
--------------------------------




bfloat16\_t `__tf322bfloat16_tz`(float *a*)  

This function converts type of `a` from `tf32` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322bfloat16 for more details.













3.21.262. \_\_tf322bfloat16\_up
--------------------------------




bfloat16\_t `__tf322bfloat16_up`(float *a*)  

This function converts type of `a` from `tf32` to `bfloat16\_t` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322bfloat16 for more details.













3.21.263. \_\_tf322char
------------------------




char `__tf322char`(float *a*)  

This function converts type of `a` from `tf32` to `char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  char result;
  result = \_\_tf322char(a);
}

```













3.21.264. \_\_tf322char\_dn
----------------------------




char `__tf322char_dn`(float *a*)  

This function converts type of `a` from `tf32` to `char` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322char for more details.













3.21.265. \_\_tf322char\_oz
----------------------------




char `__tf322char_oz`(float *a*)  

This function converts type of `a` from `tf32` to `char` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322char for more details.













3.21.266. \_\_tf322char\_rd
----------------------------




char `__tf322char_rd`(float *a*)  

This function converts type of `a` from `tf32` to `char` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322char for more details.













3.21.267. \_\_tf322char\_rm
----------------------------




char `__tf322char_rm`(float *a*)  

This function converts type of `a` from `tf32` to `char` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322char for more details.













3.21.268. \_\_tf322char\_rn
----------------------------




char `__tf322char_rn`(float *a*)  

This function converts type of `a` from `tf32` to `char` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322char for more details.













3.21.269. \_\_tf322char\_tz
----------------------------




char `__tf322char_tz`(float *a*)  

This function converts type of `a` from `tf32` to `char` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322char for more details.













3.21.270. \_\_tf322char\_up
----------------------------




char `__tf322char_up`(float *a*)  

This function converts type of `a` from `tf32` to `char` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322char for more details.













3.21.271. \_\_tf322float
-------------------------




float `__tf322float`(float *a*)  

This function converts type of `a` from `tf32` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  float result;
  result = \_\_tf322float(a);
}

```













3.21.272. \_\_tf322float\_dn
-----------------------------




float `__tf322float_dn`(float *a*)  

This function converts type of `a` from `tf32` to `float` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322float for more details.













3.21.273. \_\_tf322float\_oz
-----------------------------




float `__tf322float_oz`(float *a*)  

This function converts type of `a` from `tf32` to `float` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322float for more details.













3.21.274. \_\_tf322float\_rd
-----------------------------




float `__tf322float_rd`(float *a*)  

This function converts type of `a` from `tf32` to `float` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322float for more details.













3.21.275. \_\_tf322float\_rm
-----------------------------




float `__tf322float_rm`(float *a*)  

This function converts type of `a` from `tf32` to `float` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322float for more details.













3.21.276. \_\_tf322float\_rn
-----------------------------




float `__tf322float_rn`(float *a*)  

This function converts type of `a` from `tf32` to `float` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322float for more details.













3.21.277. \_\_tf322float\_tz
-----------------------------




float `__tf322float_tz`(float *a*)  

This function converts type of `a` from `tf32` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322float for more details.













3.21.278. \_\_tf322float\_up
-----------------------------




float `__tf322float_up`(float *a*)  

This function converts type of `a` from `tf32` to `float` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322float for more details.













3.21.279. \_\_tf322half
------------------------




half `__tf322half`(float *a*)  

This function converts type of `a` from `tf32` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  half result;
  result = \_\_tf322half(a);
}

```













3.21.280. \_\_tf322half\_dn
----------------------------




half `__tf322half_dn`(float *a*)  

This function converts type of `a` from `tf32` to `half` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322half for more details.













3.21.281. \_\_tf322half\_oz
----------------------------




half `__tf322half_oz`(float *a*)  

This function converts type of `a` from `tf32` to `half` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322half for more details.













3.21.282. \_\_tf322half\_rd
----------------------------




half `__tf322half_rd`(float *a*)  

This function converts type of `a` from `tf32` to `half` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322half for more details.













3.21.283. \_\_tf322half\_rm
----------------------------




half `__tf322half_rm`(float *a*)  

This function converts type of `a` from `tf32` to `half` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322half for more details.













3.21.284. \_\_tf322half\_rn
----------------------------




half `__tf322half_rn`(float *a*)  

This function converts type of `a` from `tf32` to `half` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322half for more details.













3.21.285. \_\_tf322half\_tz
----------------------------




half `__tf322half_tz`(float *a*)  

This function converts type of `a` from `tf32` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322half for more details.













3.21.286. \_\_tf322half\_up
----------------------------




half `__tf322half_up`(float *a*)  

This function converts type of `a` from `tf32` to `half` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322half for more details.













3.21.287. \_\_tf322int
-----------------------




int `__tf322int`(float *a*)  

This function converts type of `a` from `tf32` to `int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  int result;
  result = \_\_tf322int(a);
}

```













3.21.288. \_\_tf322int\_dn
---------------------------




int `__tf322int_dn`(float *a*)  

This function converts type of `a` from `tf32` to `int` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322int for more details.













3.21.289. \_\_tf322int\_oz
---------------------------




int `__tf322int_oz`(float *a*)  

This function converts type of `a` from `tf32` to `int` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322int for more details.













3.21.290. \_\_tf322int\_rd
---------------------------




int `__tf322int_rd`(float *a*)  

This function converts type of `a` from `tf32` to `int` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322int for more details.













3.21.291. \_\_tf322int\_rm
---------------------------




int `__tf322int_rm`(float *a*)  

This function converts type of `a` from `tf32` to `int` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322int for more details.













3.21.292. \_\_tf322int\_rn
---------------------------




int `__tf322int_rn`(float *a*)  

This function converts type of `a` from `tf32` to `int` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322int for more details.













3.21.293. \_\_tf322int\_tz
---------------------------




int `__tf322int_tz`(float *a*)  

This function converts type of `a` from `tf32` to `int` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322int for more details.













3.21.294. \_\_tf322int\_up
---------------------------




int `__tf322int_up`(float *a*)  

This function converts type of `a` from `tf32` to `int` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322int for more details.













3.21.295. \_\_tf322short
-------------------------




short `__tf322short`(float *a*)  

This function converts type of `a` from `tf32` to `short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(float a) {
  short result;
  result = \_\_tf322short(a);
}

```













3.21.296. \_\_tf322short\_dn
-----------------------------




short `__tf322short_dn`(float *a*)  

This function converts type of `a` from `tf32` to `short` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322short for more details.













3.21.297. \_\_tf322short\_oz
-----------------------------




short `__tf322short_oz`(float *a*)  

This function converts type of `a` from `tf32` to `short` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322short for more details.













3.21.298. \_\_tf322short\_rd
-----------------------------




short `__tf322short_rd`(float *a*)  

This function converts type of `a` from `tf32` to `short` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322short for more details.













3.21.299. \_\_tf322short\_rm
-----------------------------




short `__tf322short_rm`(float *a*)  

This function converts type of `a` from `tf32` to `short` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322short for more details.













3.21.300. \_\_tf322short\_rn
-----------------------------




short `__tf322short_rn`(float *a*)  

This function converts type of `a` from `tf32` to `short` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322short for more details.













3.21.301. \_\_tf322short\_tz
-----------------------------




short `__tf322short_tz`(float *a*)  

This function converts type of `a` from `tf32` to `short` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322short for more details.













3.21.302. \_\_tf322short\_up
-----------------------------




short `__tf322short_up`(float *a*)  

This function converts type of `a` from `tf32` to `short` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_tf322short for more details.













3.21.303. \_\_uchar2bfloat16
-----------------------------




bfloat16\_t `__uchar2bfloat16`(unsigned char *a*)  

This function converts type of `a` from `unsigned char` to `bfloat16\_t`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(unsigned char a) {
  bfloat16\_t result;
  result = \_\_uchar2bfloat16(a);
}

```













3.21.304. \_\_uchar2float
--------------------------




float `__uchar2float`(unsigned char *a*)  

This function converts type of `a` from `unsigned char` to `float`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.21.305. \_\_uchar2half
-------------------------




half `__uchar2half`(unsigned char *a*)  

This function converts type of `a` from `unsigned char` to `half`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.21.306. \_\_uchar2tf32
-------------------------




float `__uchar2tf32`(unsigned char *a*)  

This function converts type of `a` from `unsigned char` to `tf32`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(unsigned char a) {
  float result;
  result = \_\_uchar2tf32(a);
}

```













3.21.307. \_\_uint2bfloat16
----------------------------




bfloat16\_t `__uint2bfloat16`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(unsigned int a) {
  bfloat16\_t result;
  result = \_\_uint2bfloat16(a);
}

```













3.21.308. \_\_uint2bfloat16\_dn
--------------------------------




bfloat16\_t `__uint2bfloat16_dn`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `bfloat16\_t` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2bfloat16 for more details.













3.21.309. \_\_uint2bfloat16\_oz
--------------------------------




bfloat16\_t `__uint2bfloat16_oz`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `bfloat16\_t` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2bfloat16 for more details.













3.21.310. \_\_uint2bfloat16\_rd
--------------------------------




bfloat16\_t `__uint2bfloat16_rd`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `bfloat16\_t` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2bfloat16 for more details.













3.21.311. \_\_uint2bfloat16\_rm
--------------------------------




bfloat16\_t `__uint2bfloat16_rm`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `bfloat16\_t` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2bfloat16 for more details.













3.21.312. \_\_uint2bfloat16\_rn
--------------------------------




bfloat16\_t `__uint2bfloat16_rn`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `bfloat16\_t` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2bfloat16 for more details.













3.21.313. \_\_uint2bfloat16\_tz
--------------------------------




bfloat16\_t `__uint2bfloat16_tz`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2bfloat16 for more details.













3.21.314. \_\_uint2bfloat16\_up
--------------------------------




bfloat16\_t `__uint2bfloat16_up`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `bfloat16\_t` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2bfloat16 for more details.













3.21.315. \_\_uint2float
-------------------------




float `__uint2float`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2float\_tz for more details.













3.21.316. \_\_uint2float\_dn
-----------------------------




float `__uint2float_dn`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `float` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2float\_tz for more details.













3.21.317. \_\_uint2float\_oz
-----------------------------




float `__uint2float_oz`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `float` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2float\_tz for more details.













3.21.318. \_\_uint2float\_rd
-----------------------------




float `__uint2float_rd`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `float` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2float\_tz for more details.













3.21.319. \_\_uint2float\_rm
-----------------------------




float `__uint2float_rm`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `float` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_uint2float\_tz for more details.













3.21.320. \_\_uint2float\_rn
-----------------------------




float `__uint2float_rn`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `float` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_uint2float\_tz for more details.













3.21.321. \_\_uint2float\_tz
-----------------------------




float `__uint2float_tz`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `float` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(unsigned int a) {
  float result;
  result = \_\_uint2float\_tz(a);
}

```













3.21.322. \_\_uint2float\_up
-----------------------------




float `__uint2float_up`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `float` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2float\_tz for more details.













3.21.323. \_\_uint2half
------------------------




half `__uint2half`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2half\_tz for more details.













3.21.324. \_\_uint2half\_dn
----------------------------




half `__uint2half_dn`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `half` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2half\_tz for more details.













3.21.325. \_\_uint2half\_oz
----------------------------




half `__uint2half_oz`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `half` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2half\_tz for more details.













3.21.326. \_\_uint2half\_rd
----------------------------




half `__uint2half_rd`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `half` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2half\_tz for more details.













3.21.327. \_\_uint2half\_rm
----------------------------




half `__uint2half_rm`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `half` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_uint2half\_tz for more details.













3.21.328. \_\_uint2half\_rn
----------------------------




half `__uint2half_rn`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `half` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_uint2half\_tz for more details.













3.21.329. \_\_uint2half\_tz
----------------------------




half `__uint2half_tz`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(int a) {
  half result;
  result = \_\_uint2half\_tz(a);
}

```













3.21.330. \_\_uint2half\_up
----------------------------




half `__uint2half_up`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `half` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_uint2half\_tz for more details.













3.21.331. \_\_uint2tf32
------------------------




float `__uint2tf32`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(unsigned int a) {
  float result;
  result = \_\_uint2tf32(a);
}

```













3.21.332. \_\_uint2tf32\_dn
----------------------------




float `__uint2tf32_dn`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `tf32` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2tf32 for more details.













3.21.333. \_\_uint2tf32\_oz
----------------------------




float `__uint2tf32_oz`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `tf32` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2tf32 for more details.













3.21.334. \_\_uint2tf32\_rd
----------------------------




float `__uint2tf32_rd`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `tf32` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2tf32 for more details.













3.21.335. \_\_uint2tf32\_rm
----------------------------




float `__uint2tf32_rm`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `tf32` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2tf32 for more details.













3.21.336. \_\_uint2tf32\_rn
----------------------------




float `__uint2tf32_rn`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `tf32` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2tf32 for more details.













3.21.337. \_\_uint2tf32\_tz
----------------------------




float `__uint2tf32_tz`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2tf32 for more details.













3.21.338. \_\_uint2tf32\_up
----------------------------




float `__uint2tf32_up`(unsigned int *a*)  

This function converts type of `a` from `unsigned int` to `tf32` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_uint2tf32 for more details.













3.21.339. \_\_ushort2bfloat16
------------------------------




bfloat16\_t `__ushort2bfloat16`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(unsigned short a) {
  bfloat16\_t result;
  result = \_\_ushort2bfloat16(a);
}

```













3.21.340. \_\_ushort2bfloat16\_dn
----------------------------------




bfloat16\_t `__ushort2bfloat16_dn`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `bfloat16\_t` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2bfloat16 for more details.













3.21.341. \_\_ushort2bfloat16\_oz
----------------------------------




bfloat16\_t `__ushort2bfloat16_oz`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `bfloat16\_t` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2bfloat16 for more details.













3.21.342. \_\_ushort2bfloat16\_rd
----------------------------------




bfloat16\_t `__ushort2bfloat16_rd`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `bfloat16\_t` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2bfloat16 for more details.













3.21.343. \_\_ushort2bfloat16\_rm
----------------------------------




bfloat16\_t `__ushort2bfloat16_rm`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `bfloat16\_t` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2bfloat16 for more details.













3.21.344. \_\_ushort2bfloat16\_rn
----------------------------------




bfloat16\_t `__ushort2bfloat16_rn`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `bfloat16\_t` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2bfloat16 for more details.













3.21.345. \_\_ushort2bfloat16\_tz
----------------------------------




bfloat16\_t `__ushort2bfloat16_tz`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `bfloat16\_t` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2bfloat16 for more details.













3.21.346. \_\_ushort2bfloat16\_up
----------------------------------




bfloat16\_t `__ushort2bfloat16_up`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `bfloat16\_t` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2bfloat16 for more details.













3.21.347. \_\_ushort2float
---------------------------




float `__ushort2float`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `float`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.21.348. \_\_ushort2half
--------------------------




half `__ushort2half`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_ushort2half\_tz for more details.













3.21.349. \_\_ushort2half\_dn
------------------------------




half `__ushort2half_dn`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `half` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_ushort2half\_tz for more details.













3.21.350. \_\_ushort2half\_oz
------------------------------




half `__ushort2half_oz`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `half` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_ushort2half\_tz for more details.













3.21.351. \_\_ushort2half\_rd
------------------------------




half `__ushort2half_rd`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `half` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_ushort2half\_tz for more details.













3.21.352. \_\_ushort2half\_rm
------------------------------




half `__ushort2half_rm`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `half` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_ushort2half\_tz for more details.













3.21.353. \_\_ushort2half\_rn
------------------------------




half `__ushort2half_rn`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `half` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_ushort2half\_tz for more details.













3.21.354. \_\_ushort2half\_tz
------------------------------




half `__ushort2half_tz`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `half` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(unsigned short a) {
  half result;
  result = \_\_ushort2half\_tz(a);
}

```













3.21.355. \_\_ushort2half\_up
------------------------------




half `__ushort2half_up`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `half` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_ushort2half\_tz for more details.













3.21.356. \_\_ushort2tf32
--------------------------




float `__ushort2tf32`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

\_\_mlu\_entry\_\_ void kernel(unsigned short a) {
  float result;
  result = \_\_ushort2tf32(a);
}

```













3.21.357. \_\_ushort2tf32\_dn
------------------------------




float `__ushort2tf32_dn`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `tf32` in round-down mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2tf32 for more details.













3.21.358. \_\_ushort2tf32\_oz
------------------------------




float `__ushort2tf32_oz`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `tf32` in round-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2tf32 for more details.













3.21.359. \_\_ushort2tf32\_rd
------------------------------




float `__ushort2tf32_rd`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `tf32` in round-nearest-off-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2tf32 for more details.













3.21.360. \_\_ushort2tf32\_rm
------------------------------




float `__ushort2tf32_rm`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `tf32` in round-math mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2tf32 for more details.













3.21.361. \_\_ushort2tf32\_rn
------------------------------




float `__ushort2tf32_rn`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `tf32` in round-nearest-even mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2tf32 for more details.













3.21.362. \_\_ushort2tf32\_tz
------------------------------




float `__ushort2tf32_tz`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `tf32` in round-to-zero mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2tf32 for more details.













3.21.363. \_\_ushort2tf32\_up
------------------------------




float `__ushort2tf32_up`(unsigned short *a*)  

This function converts type of `a` from `unsigned short` to `tf32` in round-up mode. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[in] a`: The source data.



**Return*** The result of conversion.






**Remark*** None.






**Instruction Pipeline*** Scalar.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_ushort2tf32 for more details.

















3.22. Vector Active Functions
==============================



3.22.1. \_\_bang\_active\_abs
------------------------------




void `__bang_active_abs`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_abs`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function computes the absolute value of each element in vector `<src>` and saves the result to vector `<dst>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: 0;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` space;
* `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The range of `<src>` operand is \([-65504, 65504]\) when type is `half`, and \([-3.4 \* 10^{38}, 3.4 \* 10^{38}]\) when type is `float`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.2. \_\_bang\_active\_cos
------------------------------




void `__bang_active_cos`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_cos`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (cosine) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: within 0.01;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The element value of `<src>` is in the range [-2, 2] radian;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.3. \_\_bang\_active\_exp
------------------------------




void `__bang_active_exp`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_exp`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (exponent) operation on source operand `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The result is 5.96e-8, when the element value of `<src>` is less than -7.75;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `half`, the relative error refer to the table Relative Error of \_\_bang\_active\_exp(half) for accuracy information;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [-3.4e38, 11] the average relative error is within 0.01;




Table 3.34 Relative Error of `\_\_bang\_active\_exp(half)`





| Interval | Maximum absolute error | Maximum relative error | Average relative error |
| --- | --- | --- | --- |
| [-65504, -7.75) | 0.000426 | N/A | N/A |
| [-7.75, -5.12] | N/A | 0.003 | N/A |
| (-5.12, -0) | N/A | 0.008 | N/A |
| [-0, +0] | 0 | N/A | N/A |
| (0, 0.003] | N/A | 0.003 | N/A |
| (0.003, 9.12] | N/A | 0.01 | N/A |
| (9.12, 10.3] | N/A | 0.011 | N/A |
| (10.3, 11] | N/A | 0.05 | N/A |
| [-15.511] | N/A | N/A | 0.00687 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.4. \_\_bang\_active\_exp\_less\_0
---------------------------------------




void `__bang_active_exp_less_0`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_exp_less_0`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (exponent) operation on source operand `<src>` when the value of `<src>` is less than 0.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The result is 5.96e-8, when the element value of `<src>` is less than -15.5;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [-3.4e38, 0); when the data type of the elements of `<src>` is `half`, the element value is in the range [-65504, 0);
* When the data type of the elements of `<src>` is `float`, the average relative error is within 0.003; when the data type of the elements of `<src>` is `half`, the average relative error is within 0.01.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.5. \_\_bang\_active\_exphp
--------------------------------




void `__bang_active_exphp`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_exphp`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies high precision active (exponent) operation on source operand `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `half`, the relative error refer to the table Relative Error of \_\_bang\_active\_exphp(half) for accuracy information;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [-3.4e38, 16];
* When the element value of `<src>` is less than -15.5 for the data type of `float`, the result is 3e-7; when the element value of `<src>` is less than -7.75 for the data type of `half`, the result is 5.96e-8;
* When the data type of the elements of `<src>` is `float`, the average relative error is within 0.003;




Table 3.35 Relative Error of `\_\_bang\_active\_exphp(half)`





| Interval | Maximum absolute error | Maximum relative error | Average relative error |
| --- | --- | --- | --- |
| [-65504, -7.75) | 0.000426 | N/A | N/A |
| [-7.75, -5.12] | N/A | 0.003 | N/A |
| (-5.12, -0) | N/A | 0.008 | N/A |
| [-0, +0] | 0 | N/A | N/A |
| (0, 0.003] | N/A | 0.003 | N/A |
| (0.003, 9.12] | N/A | 0.01 | N/A |
| (9.12, 10.3] | N/A | 0.011 | N/A |
| (10.3, 11] | N/A | 0.05 | N/A |
| [-15.511] | N/A | N/A | 0.00687 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.6. \_\_bang\_active\_gelu
-------------------------------




void `__bang_active_gelu`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_gelu`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (gelu) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: within 0.003;
* `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `half`, the relative error refer to the table Relative Error of \_\_bang\_active\_gelu(half) for accuracy information;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [-3.4e38, 3.4e38], the average relative error is within 0.003;
* When the element value of `<src>` is less than -3.875, the result is -5.96e-8;




Table 3.36 Relative Error of `\_\_bang\_active\_gelu(half)`





| Interval | Maximum absolute error | Maximum relative error | Average relative error |
| --- | --- | --- | --- |
| [-65504, -3.875] | 0.0001258 | N/A | N/A |
| (-3.875, -2.91] | 0.0000653 | N/A | N/A |
| (-2.91, -1.69] | N/A | 0.0108 | N/A |
| (-1.69, -0.627] | N/A | 0.003 | N/A |
| (-0.627, -0.134] | N/A | 0.01 | N/A |
| (-0.137, -0) | 0.001571 | N/A | N/A |
| [-0, +0] | 0 | N/A | N/A |
| (0, 0.130) | 0.001556 | N/A | N/A |
| (0.130, 0.5] | N/A | 0.01 | N/A |
| (0.5, 65504] | N/A | 0.003 | N/A |
| [-4.85, 4.85] | N/A | N/A | 0.0023 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.7. \_\_bang\_active\_gelup
--------------------------------




void `__bang_active_gelup`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_gelup`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (gelup) operation on `<src>`, which has higher precision than active(gelu) does.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The result is -5.96e-8, when the element value of `<src>` is less than -3.875;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `half`, the relative error refer to the table Relative Error of \_\_bang\_active\_gelup(half) for accuracy information;
* When the data type of the elements of `<src>` is `float`, the element values of `<src>` are in the range [-3.4e38, 3.4e38];
* When the data type of the elements of `<src>` is `float`, the average relative error rate is within 0.003. Despite having higher average relative error than normal gelu operation, it has higher precision on critical interval;




Table 3.37 Relative Error of `\_\_bang\_active\_gelup(half)`





| Interval | Maximum absolute error | Maximum relative error | Average relative error |
| --- | --- | --- | --- |
| [-65504, -3.875] | 0.0001258 | N/A | N/A |
| (-3.875, -2.68] | 0.0001678 | N/A | N/A |
| (-2.68, -2.10] | N/A | 0.0108 | N/A |
| (-2.10, -0.347] | N/A | 0.003 | N/A |
| (-0.347, -0.154] | N/A | 0.01 | N/A |
| (-0.154, -0) | 0.001221 | N/A | N/A |
| [-0, +0] | 0 | N/A | N/A |
| (0, 0.453) | 0.003537 | N/A | N/A |
| [0.453, 1.45) | N/A | 0.0112 | N/A |
| [1.45, 65504] | N/A | 0.003 | N/A |
| [-4.85, 4.85] | N/A | N/A | 0.00411 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.8. \_\_bang\_active\_log
------------------------------




void `__bang_active_log`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_log`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (log base e) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: within 0.01;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The element value of `<src>` is in the range [6.1e-5, 63484];
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.9. \_\_bang\_active\_loghp
--------------------------------




void `__bang_active_loghp`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_loghp`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies high precision active (log base e) operation on source operand `<src>`. The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `half`, the relative error refer to the table Relative Error of \_\_bang\_active\_loghp(half) for accuracy information;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [7.2e-9, 507903];
* When the data type of the elements of `<src>` is `float`, the average relative error is within 0.001;




Table 3.38 Relative Error of `\_\_bang\_active\_loghp(half)`





| Interval | Maximum absolute error | Maximum relative error | Average relative error |
| --- | --- | --- | --- |
| [0.0000611, 0.000122] | N/A | 0.005 | N/A |
| (0.000122, 0.0619] | N/A | 0.003 | N/A |
| (0.0619, 0.325] | N/A | 0.01 | N/A |
| (0.325, 2.64] | 0.0121 | N/A | N/A |
| (2.64, 8.48] | N/A | 0.01 | N/A |
| (8.48, 18000] | N/A | 0.005 | N/A |
| (18000, 65504] | N/A | 0.003 | N/A |
| [0.0000611, 65504] | N/A | N/A | 0.00145 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.10. \_\_bang\_active\_pow2
--------------------------------




void `__bang_active_pow2`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_pow2`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (pow2) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: 0;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the element of `<src>` is `half` , the element values are integers in the range `[-24.0, 15.0]` , such as `-24.0, -23.0, ... 0.0, 1.0, 2.0, ... 15.0` ; when the data type of the element of `<src>` is `float`, the element values are integers in the range `[-31.0, 31.0]`, such as `-31.0, -30.0, ... 0.0, 1.0, 2.0, ... 31.0`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.11. \_\_bang\_active\_recip
---------------------------------




void `__bang_active_recip`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_recip`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (reciprocal) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









![../_images/11.4.png](../_images/11.4.png)

Fig. 3.9 Reciprocal Process











Hint



Recip means reciprocal.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The element values of `<src>` are in the range [0.0078125, 65472];
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `float`, the average relative error is within 0.003; when the data type of the elements of `<src>` is `half`, the average relative error is within 0.01.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define LEN 64

\_\_mlu\_entry\_\_ void kernel(half\* y, half\* x) {
  \_\_nram\_\_ half ny[LEN];
  \_\_nram\_\_ half nx[LEN];
  \_\_memcpy(ny, y, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(nx, x, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_active\_recip(ny, nx, LEN);
  \_\_memcpy(y, ny, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.22.12. \_\_bang\_active\_recip\_greater\_1
---------------------------------------------




void `__bang_active_recip_greater_1`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_recip_greater_1`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (reciprocal) operation on `<src>` when the value of `<src>` is greater than 1.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









Hint



Recip means reciprocal.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The element values of `<src>` are in the range [1, 63487];
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `float`, the average relative error is within 0.003; when the data type of the elements of `<src>` is `half`, the average relative error is within 0.01.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.13. \_\_bang\_active\_reciphp
-----------------------------------




void `__bang_active_reciphp`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_reciphp`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies high precision active (reciprocal) operation on source operand `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `half`, the relative error refer to the table Relative Error of \_\_bang\_active\_reciphp(half) for accuracy information;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [2.2205e-16, 2e6], and the average relative error is within 0.0004;




Table 3.39 Relative Error of `\_\_bang\_active\_reciphp(half)`





| Interval | Maximum absolute error | Maximum relative error | Average relative error |
| --- | --- | --- | --- |
| [0.00391, 16] | N/A | 0.003 | N/A |
| (16, 884] | N/A | 0.01 | N/A |
| (884, 65504] | 0.000134 | N/A | N/A |
| [0.00391, 65504] | N/A | N/A | 0.000325 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.14. \_\_bang\_active\_relu
--------------------------------




void `__bang_active_relu`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_relu`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (relu) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: 0;
* `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The range of `<src>` operand is \([-65504, 65504]\) when type is `half`, and \([-3.4 \* 10^{38}, 3.4 \* 10^{38}]\) when type is `float`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.15. \_\_bang\_active\_rsqrt
---------------------------------




void `__bang_active_rsqrt`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_rsqrt`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (rsqrt) operation on `<src>`, \(<dst> = 1 \div sqrt{<src>}\).


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: within 0.01;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The element value of `<src>` is in the range [0.005, 63487];
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.16. \_\_bang\_active\_rsqrthp
-----------------------------------




void `__bang_active_rsqrthp`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_rsqrthp`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies high precision active (rsqrt) operation on source operand `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `half`, the relative error refer to the table Relative Error of \_\_bang\_active\_rsqrthp(half) for accuracy information;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [0.000367, 1e6], the average relative error is within 0.0005;




Table 3.40 Relative Error of `\_\_bang\_active\_rsqrthp(half)`





| Interval | Maximum absolute error | Maximum relative error | Average relative error |
| --- | --- | --- | --- |
| [0.000367, 8.05] | N/A | 0.003 | N/A |
| (8.05, 6972] | N/A | 0.01 | N/A |
| (6972, 65504] | 0.000865 | N/A | N/A |
| [0.000367, 65504] | N/A | N/A | 0.00043566 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.17. \_\_bang\_active\_sigmoid
-----------------------------------




void `__bang_active_sigmoid`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_sigmoid`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (sigmoid) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: within 0.01;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The range of `<src>` operand is \([-65504, 65504]\) when type is `half`, and \([-3.4 \* 10^{38}, 3.4 \* 10^{38}]\) when type is `float`;
* The result is 0, when the element value of `<src>` is less than -7.75; the result is 1, when the element value of `<src>` is greater than 7.75.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.18. \_\_bang\_active\_sign
--------------------------------




void `__bang_active_sign`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_sign`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (sign) operation on `<src>`. If \(<src> \ge 0.0\), then, stores 1.0 in `<dst>`; otherwise, stores -1.0 in `<dst>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: 0;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the element value of `<src>` is -0 or +0, the corresponding result is 1;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [-3.4e38, 3.4e38]; when the data type of the elements of `<src>` is `half`, the element value is in the range [-65504, 65504].






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.19. \_\_bang\_active\_sin
-------------------------------




void `__bang_active_sin`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_sin`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (sine) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The element value of `<src>` is in the range [-2, 2] radian;
* Average relative error: within 0.01;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.20. \_\_bang\_active\_sqrt
--------------------------------




void `__bang_active_sqrt`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_sqrt`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (sqrt) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: within 0.01;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The element value of `<src>` is in the range [0, 63487];
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.21. \_\_bang\_active\_sqrthp
----------------------------------




void `__bang_active_sqrthp`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_sqrthp`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies high precision active (exponent) operation on source operand `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `half`, the relative error refer to the table Relative Error of \_\_bang\_active\_sqrthp(half) for accuracy information;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [0, 677268], the average relative error is within 0.003;




Table 3.41 Relative Error of `\_\_bang\_active\_sqrthp(half)`





| Interval | Maximum absolute error | Maximum relative error | Average relative error |
| --- | --- | --- | --- |
| [0, 0.000123] | 0.0025235 | N/A | N/A |
| (0.000123, 0.000244] | N/A | 0.01 | N/A |
| (0.000244, 0.0189] | N/A | 0.003 | N/A |
| (0.0189, 0.0501] | 0.003406 | N/A | N/A |
| (0.0501, 0.0813] | N/A | 0.01 | N/A |
| (0.0813, 8488] | N/A | 0.003 | N/A |
| (8488, 64704] | N/A | 0.01 | N/A |
| (64704, 65504] | N/A | 0.01539 | N/A |
| [0, 65504] | N/A | N/A | 0.00225 |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.22. \_\_bang\_active\_tanh
--------------------------------




void `__bang_active_tanh`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_active_tanh`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies active (tanh) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** Average relative error: within 0.01;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* When the data type of the elements of `<src>` is `float`, the element value is in the range [-3.4e38, 3.4e38]; when the data type of the elements of `<src>` is `half`, the element value is in the range [-65504, 65504].






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.23. \_\_bang\_taylor3\_cos
--------------------------------




void `__bang_taylor3_cos`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor3_cos`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor3 (cos) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.00001 for `half` and `float` type respectively;
* Refer to the following tables for special value of `\_\_bang\_taylor3\_cos`;




Table 3.42 Special Value of `\_\_bang\_taylor3\_cos(half)`








| Input | \(-NaN\) | \(-INF\) | [-65504, -7.75] | [7.75, 65504] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | +0.0 | +0.0 | \(+NaN\) | \(+NaN\) |




Table 3.43 Special Value of `\_\_bang\_taylor3\_cos(float)`








| Input | \(-NaN\) | \(-INF\) | [-3.4e38, -7.75] | [7.75, 3.4e38] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | +0.0 | +0.0 | \(+NaN\) | \(+NaN\) |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.24. \_\_bang\_taylor3\_sigmoid
------------------------------------




void `__bang_taylor3_sigmoid`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor3_sigmoid`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor3 (sigmoid) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for `half` and `float` type respectively;
* Refer to the following tables for special value of `\_\_bang\_taylor3\_\_sigmoid`;




Table 3.44 Special Value of `\_\_bang\_taylor3\_sigmoid(half)`








| Input | \(-NaN\) | \(-INF\) | [-65504, -7.75] | [7.75, 65504] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | 5.96e-8 | 5.96e-8 | 5.96e-8 | 1 | 1 | 1 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | 5.96e-8 | 1 | \(+NaN\) | \(+NaN\) |




Table 3.45 Special Value of `\_\_bang\_taylor3\_sigmoid(float)`








| Input | \(-NaN\) | \(-INF\) | [-3.4e38, -7.75] | [7.75, 3.4e38] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | 1.4e-45 | 1.4e-45 | 1.4e-45 | 0.99999994 | 0.99999994 | 0.99999994 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | 1.4e-45 | 0.99999994 | \(+NaN\) | \(+NaN\) |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.25. \_\_bang\_taylor3\_sin
--------------------------------




void `__bang_taylor3_sin`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor3_sin`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor3 (sine) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.00001 for `half` and `float` type respectively;
* Refer to the following tables for special value of `\_\_bang\_taylor3\_sin`;




Table 3.46 Special Value of `\_\_bang\_taylor3\_sin(half)`








| Input | \(-NaN\) | \(-INF\) | [-65504, -7.75] | [7.75, 65504] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | +0.0 | +0.0 | \(+NaN\) | \(+NaN\) |




Table 3.47 Special Value of `\_\_bang\_taylor3\_sin(float)`








| Input | \(-NaN\) | \(-INF\) | [-3.4e38, -7.75] | [7.75, 3.4e38] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | +0.0 | +0.0 | \(+NaN\) | \(+NaN\) |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.26. \_\_bang\_taylor3\_softplus
-------------------------------------




void `__bang_taylor3_softplus`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor3_softplus`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor3 (softplus) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for `half` and `float` type respectively;
* Refer to the following tables for special value of `\_\_bang\_taylor3\_softplus`;




Table 3.48 Special Value of `\_\_bang\_taylor3\_softplus(half)`








| Input | \(-NaN\) | \(-INF\) | [-65504, -7.75] | [7.75, 65504] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | 0.000215292 | 0.000215292 | 0.000215292 | y = x | 65504 | 65504 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | 0.000215292 | y = x | \(+NaN\) | \(+NaN\) |




Table 3.49 Special Value of `\_\_bang\_taylor3\_softplus(float)`








| Input | \(-NaN\) | \(-INF\) | [-3.4e38, -7.75] | [7.75, 3.4e38] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | 0.0002153
2489 | 0.0002153
2489 | 0.0002153
2489 | y = x +
4.76837e-7 | 3.4e38 | 3.4e38 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | 0.0002153
2489 | y = x +
4.76837e-7 | \(+NaN\) | \(+NaN\) |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.27. \_\_bang\_taylor3\_tanh
---------------------------------




void `__bang_taylor3_tanh`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor3_tanh`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor3 (tanh) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` must be in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.00001 for `half` and `float` type respectively.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.28. \_\_bang\_taylor4\_cos
--------------------------------




void `__bang_taylor4_cos`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor4_cos`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor4 (cos) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.000001 for `half` and `float` type respectively;
* Refer to the following tables for special value of `\_\_bang\_taylor4\_cos`;




Table 3.50 Special Value of `\_\_bang\_taylor4\_cos(half)`








| Input | \(-NaN\) | \(-INF\) | [-65504, -7.75] | [7.75, 65504] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | +0.0 | +0.0 | \(+NaN\) | \(+NaN\) |




Table 3.51 Special Value of `\_\_bang\_taylor4\_cos(float)`








| Input | \(-NaN\) | \(-INF\) | [-3.4e38, -7.75] | [7.75, 3.4e38] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | +0.0 | +0.0 | \(+NaN\) | \(+NaN\) |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.29. \_\_bang\_taylor4\_sigmoid
------------------------------------




void `__bang_taylor4_sigmoid`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor4_sigmoid`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor4 (sigmoid) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* The value of elements in `<src>` is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.0000001 for `half` and `float` type respectively;
* Refer to the following tables for special value of `\_\_bang\_taylor4\_sigmoid`;




Table 3.52 Special Value of `\_\_bang\_taylor4\_sigmoid(half)`








| Input | \(-NaN\) | \(-INF\) | [-65504, -7.75] | [7.75, 65504] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | 5.96e-8 | 5.96e-8 | 5.96e-8 | 1 | 1 | 1 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | 5.96e-8 | 1 | \(+NaN\) | \(+NaN\) |




Table 3.53 Special Value of `\_\_bang\_taylor4\_sigmoid(float)`








| Input | \(-NaN\) | \(-INF\) | [-3.4e38, -7.75] | [7.75, 3.4e38] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | 1.4e-45 | 1.4e-45 | 1.4e-45 | 0.99999994 | 0.99999994 | 0.99999994 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | 1.4e-45 | 0.99999994 | \(+NaN\) | \(+NaN\) |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.30. \_\_bang\_taylor4\_sin
--------------------------------




void `__bang_taylor4_sin`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor4_sin`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor4 (sine) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` is in the range (-7.75, 7.75) radian; the average relative error is within 0.0005 and 0.000001 for `half` and `float` type respectively;
* Refer to the following tables for special value of `\_\_bang\_taylor4\_sin`;




Table 3.54 Special Value of `\_\_bang\_taylor4\_sin(half)`








| Input | \(-NaN\) | \(-INF\) | [-65504, -7.75] | [7.75, 65504] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | +0.0 | +0.0 | \(+NaN\) | \(+NaN\) |




Table 3.55 Special Value of `\_\_bang\_taylor4\_sin(float)`








| Input | \(-NaN\) | \(-INF\) | [-3.4e38, -7.75] | [7.75, 3.4e38] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 | +0.0 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | +0.0 | +0.0 | \(+NaN\) | \(+NaN\) |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.31. \_\_bang\_taylor4\_softplus
-------------------------------------




void `__bang_taylor4_softplus`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor4_softplus`(float \**dst*, float \**src*, float \**aux1*, float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor4 (softplus) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` is in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.0000001 for `half` and `float` type respectively;
* Refer to the following tables for special value of `\_\_bang\_taylor4\_softplus`;




Table 3.56 Special Value of `\_\_bang\_taylor4\_softplus(half)`








| Input | \(-NaN\) | \(-INF\) | [-65504, -7.75] | [7.75, 65504] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | 0.000215292 | 0.000215292 | 0.000215292 | y = x | 65504 | 65504 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | 0.000215292 | y = x | \(+NaN\) | \(+NaN\) |




Table 3.57 Special Value of `\_\_bang\_taylor4\_softplus(float)`








| Input | \(-NaN\) | \(-INF\) | [-3.4e38, -7.75] | [7.75, 3.4e38] | \(+INF\) | \(+NaN\) |
| --- | --- | --- | --- | --- | --- | --- |
| Output on `(m)tp\_2xx` or earlier | 0.0002153
2489 | 0.0002153
2489 | 0.0002153
2489 | y = x +
4.76837e-7 | 3.4e38 | 3.4e38 |
| Output on `(m)tp\_3xx` or higher | \(+NaN\) | \(+NaN\) | 0.0002153
2489 | y = x +
4.76837e-7 | \(+NaN\) | \(+NaN\) |









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.22.32. \_\_bang\_taylor4\_tanh
---------------------------------




void `__bang_taylor4_tanh`(half \**dst*, *const* half \**src*, *const* half \**aux1*, *const* half \**aux2*, unsigned int *elem\_count*)  




void `__bang_taylor4_tanh`(float \**dst*, *const* float \**src*, *const* float \**aux1*, *const* float \**aux2*, unsigned int *elem\_count*)  

Applies active with taylor4 (tanh) operation on `<src>`.


The function requires auxiliary `\_\_nram\_\_` space internally. See the table Activation Table Space for the Activation Function for more information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] aux1`: The auxiliary `\_\_nram\_\_` space 1.
* `[in] aux2`: The auxiliary `\_\_nram\_\_` space 2.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` , `<aux1>` and `<aux2>` must have the same size as `<src>`;
* `<src>` , `<aux1>` , `<aux2>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` , `<aux1>` , `<aux2>` and `<src>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<aux1>`, `<aux2>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The value of elements in `<src>` must be in the range (-7.75, 7.75) ; the average relative error is within 0.0003 and 0.000001 for `half` and `float` type respectively.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.

















3.23. Vector Bitwise Functions
===============================



3.23.1. \_\_bang\_band
-----------------------




void `__bang_band`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  

Applies bit-wise AND operation on two vectors.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src0>`;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(char\* c, char\* a, char\* b) {
  \_\_nram\_\_ char a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ char c\_tmp[DATA\_SIZE];
  \_\_nram\_\_ char b\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE, GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, DATA\_SIZE, GDRAM2NRAM);
  \_\_bang\_band(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE, NRAM2GDRAM);
}

```













3.23.2. \_\_bang\_band\_scalar
-------------------------------




void `__bang_band_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_band_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  




void `__bang_band_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_band_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_band_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_band_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  

This function performs bit-wise AND operation between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int`, `short` and `char` are not supported on `tp\_520`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(int\* c, int\* a, intt b) {
  \_\_nram\_\_ int a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ int c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(int), GDRAM2NRAM);
  \_\_bang\_band\_scalar(c\_tmp, a\_tmp, b, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(int), NRAM2GDRAM);
}

```













3.23.3. \_\_bang\_bnot
-----------------------




void `__bang_bnot`(char \**dst*, *const* char \**src*, unsigned int *elem\_count*)  

Applies bit-wise NOT operation on a vector.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.23.4. \_\_bang\_bor
----------------------




void `__bang_bor`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  

Applies bit-wise OR operation on two vectors.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src0>`;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.23.5. \_\_bang\_bor\_scalar
------------------------------




void `__bang_bor_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_bor_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  




void `__bang_bor_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_bor_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_bor_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_bor_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  

This function performs bit-wise OR operation between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int`, `short` and `char` are not supported on `tp\_520`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_band\_scalar for more details.













3.23.6. \_\_bang\_bxor
-----------------------




void `__bang_bxor`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  

Applies bit-wise XOR operation on two vectors.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src0>`;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.23.7. \_\_bang\_bxor\_scalar
-------------------------------




void `__bang_bxor_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_bxor_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  




void `__bang_bxor_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_bxor_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_bxor_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_bxor_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  

This function performs bit-wise XOR operation between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int`, `short` and `char` are not supported on `tp\_520`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_band\_scalar for more details.













3.23.8. \_\_bang\_cycle\_band
------------------------------




void `__bang_cycle_band`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies bit-wise AND operation with the corresponding element in `<seg>`. The result is assigned to `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_elem\_count> \* sizeof(char)` and `<seg\_elem\_count> \* sizeof(char)` must be divisible by 128 on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.23.9. \_\_bang\_cycle\_bor
-----------------------------




void `__bang_cycle_bor`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies bit-wise OR operation with the corresponding element in `<seg>`. The result is assigned to `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_elem\_count> \* sizeof(char)` and `<seg\_elem\_count> \* sizeof(char)` must be divisible by 128 on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.23.10. \_\_bang\_cycle\_bxor
-------------------------------




void `__bang_cycle_bxor`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies bit-wise XOR operation with the corresponding element in `<seg>`. The result is assigned to `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_elem\_count> \* sizeof(char)` and `<seg\_elem\_count> \* sizeof(char)` must be divisible by 128 on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.

















3.24. Vector Comparison Functions
==================================



3.24.1. \_\_bang\_argmax
-------------------------




void `__bang_argmax`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_argmax`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_argmax`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Finds the maximum value and its corresponding index in `<src>` vector except NaN. The result is composed of two parts. The first part is the maximum value of corresponding type, and the second part is the index of the first maximum value position in `<src>` vector, whose data type is `unsigned int`. The maximum value and index are stored continuously in `<dst>`. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define DATA\_NUM 90

\_\_mlu\_entry\_\_ void kernel\_max(float\* dst, float\* src) {
  \_\_nram\_\_ float dst\_nram[DATA\_NUM];
  \_\_nram\_\_ float src\_nram[DATA\_NUM];
  \_\_memcpy(src\_nram, src, DATA\_NUM \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_argmax(dst\_nram, src\_nram, DATA\_NUM);
  \_\_memcpy(dst, dst\_nram, DATA\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.24.2. \_\_bang\_argmin
-------------------------




void `__bang_argmin`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_argmin`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_argmin`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Finds the minimum value and its corresponding index in `<src>` vector except NaN. The result is composed of two parts. The first part is the minimum value of corresponding data type, and the second part is the index of the first minimum value position in `<src>` vector, whose data type is `unsigned int`. The minimum value and index are stored continuously. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define DATA\_NUM 90

\_\_mlu\_entry\_\_ void kernel\_min(float\* dst, float\* src) {
  \_\_nram\_\_ float dst\_nram[DATA\_NUM];
  \_\_nram\_\_ float src\_nram[DATA\_NUM];
  \_\_memcpy(src\_nram, src, DATA\_NUM \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_argmin(dst\_nram, src\_nram, DATA\_NUM);
  \_\_memcpy(dst, dst\_nram, DATA\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.24.3. \_\_bang\_cycle\_eq
----------------------------




void `__bang_cycle_eq`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_eq`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_eq`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_eq`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_eq`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_eq`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part and the corresponding element in `<seg>` are equal. The result is assigned to `<dst>`. If the element of `<src>` is equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short` and `char`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define N1 128
#define N2 32640

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
  \_\_nram\_\_ float a\_tmp[N1];
  \_\_nram\_\_ float b\_tmp[N2];
  \_\_nram\_\_ float c\_tmp[N2];
  \_\_memcpy(a\_tmp, a, N1 \* sizeof(float), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, N2 \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_cycle\_eq(c\_tmp, b\_tmp, a\_tmp, N2, N1);
  \_\_memcpy(c, c\_tmp, N2 \* sizeof(float), NRAM2GDRAM);
}

```













3.24.4. \_\_bang\_cycle\_equ
-----------------------------




void `__bang_cycle_equ`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_equ`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_equ`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part and the corresponding element in `<seg>` are unordered or equal. The result is assigned to `<dst>`. If the element of `<src>` is unordered or equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define N1 128
#define N2 32640

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
  \_\_nram\_\_ float a\_tmp[N1];
  \_\_nram\_\_ float b\_tmp[N2];
  \_\_nram\_\_ float c\_tmp[N2];
  \_\_memcpy(a\_tmp, a, N1 \* sizeof(float), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, N2 \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_cycle\_equ(c\_tmp, b\_tmp, a\_tmp, N2, N1);
  \_\_memcpy(c, c\_tmp, N2 \* sizeof(float), NRAM2GDRAM);
}

```













3.24.5. \_\_bang\_cycle\_ge
----------------------------




void `__bang_cycle_ge`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ge`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ge`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ge`(unsigned int \**dst*, *const* unsigned int \**src*, *const* unsigned int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ge`(unsigned short \**dst*, *const* unsigned short \**src*, *const* unsigned short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ge`(unsigned char \**dst*, *const* unsigned char \**src*, *const* unsigned char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ge`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ge`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ge`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part is greater than or equal to the corresponding element in `<seg>`. The result is assigned to `<dst>`. If the element of `<src>` is greater than or equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.24.6. \_\_bang\_cycle\_geu
-----------------------------




void `__bang_cycle_geu`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_geu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_geu`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part is unordered or greater than or equal to the corresponding element in `<seg>`. The result is assigned to `<dst>`. If the element of `<src>` is unordered or greater than or equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_cycle\_equ for more details.













3.24.7. \_\_bang\_cycle\_gt
----------------------------




void `__bang_cycle_gt`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_gt`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_gt`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part is greater than the corresponding element in `<seg>`. The result is assigned to `<dst>`. If the element of `<src>` is greater than `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.24.8. \_\_bang\_cycle\_gtu
-----------------------------




void `__bang_cycle_gtu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_gtu`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_gtu`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part is unordered or greater than the corresponding element in `<seg>`. The result is assigned to `<dst>`. If the element of `<src>` is unordered or greater than `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_cycle\_equ for more details.













3.24.9. \_\_bang\_cycle\_le
----------------------------




void `__bang_cycle_le`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_le`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_le`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part is less than or equal to the corresponding element in `<seg>`. The result is assigned to `<dst>`. If the element of `<src>` is less than or equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.24.10. \_\_bang\_cycle\_leu
------------------------------




void `__bang_cycle_leu`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_leu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_leu`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part is unordered or less than or equal to the corresponding element in `<seg>`. The result is assigned to `<dst>`. If the element of `<src>` is unordered or less than or equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_cycle\_equ for more details.













3.24.11. \_\_bang\_cycle\_lt
-----------------------------




void `__bang_cycle_lt`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_lt`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_lt`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_lt`(unsigned int \**dst*, *const* unsigned int \**src*, *const* unsigned int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_lt`(unsigned short \**dst*, *const* unsigned short \**src*, *const* unsigned short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_lt`(unsigned char \**dst*, *const* unsigned char \**src*, *const* unsigned char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_lt`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_lt`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_lt`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part is less than the corresponding element in `<seg>`. The result is assigned to `<dst>`. If the element of `<src>` is less than `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.24.12. \_\_bang\_cycle\_ltu
------------------------------




void `__bang_cycle_ltu`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ltu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ltu`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part is unordered or less than the corresponding element in `<seg>`. The result is assigned to `<dst>`. If the element of `<src>` is unordered or less than `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_cycle\_equ for more details.













3.24.13. \_\_bang\_cycle\_maxequal
-----------------------------------




void `__bang_cycle_maxequal`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maxequal`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maxequal`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maxequal`(unsigned int \**dst*, *const* unsigned int \**src*, *const* unsigned int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maxequal`(unsigned short \**dst*, *const* unsigned short \**src*, *const* unsigned short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maxequal`(unsigned char \**dst*, *const* unsigned char \**src*, *const* unsigned char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maxequal`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maxequal`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maxequal`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies maxequal operation (select the maximum value) with the corresponding element in `<seg>`. The result is assigned to `<dst>`. If one of the elements being compared is a NaN, then the element in `<src>` is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define N1 128
#define N2 32640

\_\_mlu\_entry\_\_ void kernel(float \*c, float \*a, float \*b) {
  \_\_nram\_\_ float a\_tmp[N1];
  \_\_nram\_\_ float b\_tmp[N2];
  \_\_nram\_\_ float c\_tmp[N2];
  \_\_memcpy(a\_tmp, a, N1 \* sizeof(float), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, N2 \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_cycle\_maxequal(c\_tmp, b\_tmp, a\_tmp, N2, N1);
  \_\_memcpy(c, c\_tmp, N2 \* sizeof(float), NRAM2GDRAM);
}

```













3.24.14. \_\_bang\_cycle\_maximum
----------------------------------




void `__bang_cycle_maximum`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maximum`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_maximum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies max operation (select the maximum value) with the corresponding element in `<seg>`. The result is assigned to `<dst>`. If both of the elements being compared are NaN, then NaN is returned.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.24.15. \_\_bang\_cycle\_minequal
-----------------------------------




void `__bang_cycle_minequal`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minequal`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minequal`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minequal`(unsigned int \**dst*, *const* unsigned int \**src*, *const* unsigned int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minequal`(unsigned short \**dst*, *const* unsigned short \**src*, *const* unsigned short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minequal`(unsigned char \**dst*, *const* unsigned char \**src*, *const* unsigned char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minequal`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minequal`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minequal`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies minequal operation (select the minimum value) with the corresponding element in `<seg>`. The result is assigned to `<dst>`. If one of the elements being compared is a NaN, then the element in `<src>` is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.24.16. \_\_bang\_cycle\_minimum
----------------------------------




void `__bang_cycle_minimum`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minimum`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_minimum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies min operation (select the minimum value) with the corresponding element in `<seg>`. The result is assigned to `<dst>`. If both of the elements being compared are NaN, then NaN is returned.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.24.17. \_\_bang\_cycle\_nan\_maximum
---------------------------------------




void `__bang_cycle_nan_maximum`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_nan_maximum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_nan_maximum`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies max operation (select the maximum value) with the corresponding element in `<seg>`. The result is assigned to `<dst>`. If one of the elements being compared is a NaN, then that element is returned.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.24.18. \_\_bang\_cycle\_nan\_minimum
---------------------------------------




void `__bang_cycle_nan_minimum`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_nan_minimum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_nan_minimum`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies min operation (select the minimum value) with the corresponding element in `<seg>`. The result is assigned to `<dst>`. If one of the elements being compared is a NaN, then that element is returned.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.24.19. \_\_bang\_cycle\_ne
-----------------------------




void `__bang_cycle_ne`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ne`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ne`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ne`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ne`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_ne`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part and the corresponding element in `<seg>` are NOT equal. The result is assigned to `<dst>`. If the element of `<src>` is not equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short` and `char`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.24.20. \_\_bang\_cycle\_neu
------------------------------




void `__bang_cycle_neu`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_neu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_neu`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts, then judges whether each element in each part and the corresponding element in `<seg>` are unordered or not equal. The result is assigned to `<dst>`. If the element of `<src>` is unordered or not equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_cycle\_equ for more details.













3.24.21. \_\_bang\_eq
----------------------




void `__bang_eq`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_eq`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_eq`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_eq`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_eq`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_eq`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs equality comparison with `<src0>` and `<src1>` and saves the result in `<dst>`. If the element of `<src0>` and the element of `<src1>` are equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

 #define DATA\_SIZE 128

 \_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
   \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
   \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
   \_\_nram\_\_ float b\_tmp[DATA\_SIZE];
   \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
   \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
   \_\_bang\_eq(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
   \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
 }

```













3.24.22. \_\_bang\_eq\_bitindex
--------------------------------




void `__bang_eq_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_eq_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_eq_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs equality comparison with `<src0>` and `<src1>` element-wisely. If the two elements are equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.
The comparison process is illustrated in the figure below, the comparison result between the first element `<element0>` of `<src0>` and the first element `<element0>` of `<src1>` will be saved in `<bit0>` of `<dst>` . The other elements do the same comparison in turn.




Fig. 3.10 The Calculation Process of Half Type `\_\_bang\_eq\_bitindex`












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be divisible by 512 on `(m)tp\_2xx`;
* `<elem\_count>` must be divisible by 8 on `(m)tp\_3xx` or higher;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

 #define DATA\_SIZE 128

 \_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
   \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
   \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
   \_\_nram\_\_ float b\_tmp[DATA\_SIZE];
   \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
   \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
   \_\_bang\_eq\_bitindex(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
   \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
 }

```













3.24.23. \_\_bang\_eq\_scalar
------------------------------




void `__bang_eq_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_eq_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_eq_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_eq_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_eq_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_eq_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function performs equality comparison with `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If the element of `<src>` and `<value>` are equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `int`, `short` and `char` are not supported on `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_eq\_scalar(c\_tmp, a\_tmp, b, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.24.24. \_\_bang\_equ
-----------------------




void `__bang_equ`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_equ`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_equ`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs unordered or equality comparison with `<src0>` and `<src1>` and saves the result in `<dst>`. If the element of `<src0>` and the element of `<src1>` are unordered or equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

 #define DATA\_SIZE 128

 \_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
   \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
   \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
   \_\_nram\_\_ float b\_tmp[DATA\_SIZE];
   \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
   \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
   \_\_bang\_equ(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
   \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
 }

```













3.24.25. \_\_bang\_equ\_bitindex
---------------------------------




void `__bang_equ_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_equ_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_equ_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs unordered or equality comparison with `<src0>` and `<src1>` element-wisely. If the two elements are unordered or equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero and divisible by 8.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

 #define DATA\_SIZE 128

 \_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
   \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
   \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
   \_\_nram\_\_ float b\_tmp[DATA\_SIZE];
   \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
   \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
   \_\_bang\_equ\_bitindex(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
   \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
 }

```













3.24.26. \_\_bang\_equ\_scalar
-------------------------------




void `__bang_equ_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_equ_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_equ_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function performs unordered or equality comparison with `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If the element of `<src>` and `<value>` are unordered or equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_equ\_scalar(c\_tmp, a\_tmp, b, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.24.27. \_\_bang\_ge
----------------------




void `__bang_ge`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_ge`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_ge`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_ge`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_ge`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_ge`(unsigned char \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_ge`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_ge`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_ge`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely to determine whether the element in `<src0>` is greater than or equal to that in `<src1>` and saves the result in `<dst>`. If the element of `<src0>` is greater than or equal to the element of `<src1>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first vector.
* `[in] src1`: The address of the second vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq for more details.













3.24.28. \_\_bang\_ge\_bitindex
--------------------------------




void `__bang_ge_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_ge_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_ge_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely, if the element of `<src0>` is greater than or equal to that of `<src1>`, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.
The comparison process is illustrated in the figure below, the comparison result between the first element `<element0>` of `<src0>` and the first element `<element0>` of `<src1>` will be saved in `<bit0>` of `<dst>` . The other elements do the same comparison in turn.




Fig. 3.11 The Calculation Process of Half Type `\_\_bang\_ge\_bitindex`












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be divisible by 512 on `(m)tp\_2xx`;
* `<elem\_count>` must be divisible by 8 on `(m)tp\_3xx` or higher;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq\_bitindex for more details.













3.24.29. \_\_bang\_ge\_scalar
------------------------------




void `__bang_ge_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_ge_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_ge_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_ge_scalar`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *value*, unsigned int *elem\_count*)  




void `__bang_ge_scalar`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned short *value*, unsigned int *elem\_count*)  




void `__bang_ge_scalar`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned char *value*, unsigned int *elem\_count*)  




void `__bang_ge_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_ge_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_ge_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are greater than or equal to `<value>` and saves the result in `<dst>`. If the element of `<src>` is greater than or equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are not supported on `tp\_520`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_ge\_scalar(c\_tmp, a\_tmp, b, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.24.30. \_\_bang\_geu
-----------------------




void `__bang_geu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_geu`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_geu`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely to determine whether the element in `<src0>` is unordered or greater than or equal to that in `<src1>` and saves the result in `<dst>`. If the element of `<src0>` is unordered or greater than or equal to the element of `<src1>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first vector.
* `[in] src1`: The address of the second vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ for more details.













3.24.31. \_\_bang\_geu\_bitindex
---------------------------------




void `__bang_geu_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_geu_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_geu_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely, if the element of `<src0>` is unoredred or greater than or equal to that of `<src1>`, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero and divisible by 8.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_bitindex for more details.













3.24.32. \_\_bang\_geu\_scalar
-------------------------------




void `__bang_geu_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_geu_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_geu_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are unordered or greater than or equal to `<value>` and saves the result in `<dst>`. If the element of `<src>` is unordered or greater than or equal to `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_scalar for more details.













3.24.33. \_\_bang\_gt
----------------------




void `__bang_gt`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_gt`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_gt`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely to determine whether the element in `<src0>` is greater than that in `<src1>` and saves the result in `<dst>`. If the element of `<src0>` is greater than the element of `<src1>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first vector.
* `[in] src1`: The address of the second vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq for more details.













3.24.34. \_\_bang\_gt\_bitindex
--------------------------------




void `__bang_gt_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_gt_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_gt_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely, if the element of `<src0>` is greater than that of `<src1>`, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.
The comparison process is illustrated in the figure below, the comparison result between the first element `<element0>` of `<src0>` and the first element `<element0>` of `<src1>` will be saved in `<bit0>` of `<dst>` . The other elements do the same comparison in turn.




Fig. 3.12 The Calculation Process of Half Type `\_\_bang\_gt\_bitindex`












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be divisible by 512 on `(m)tp\_2xx`;
* `<elem\_count>` must be divisible by 8 on `(m)tp\_3xx` or higher;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq\_bitindex for more details.













3.24.35. \_\_bang\_gt\_scalar
------------------------------




void `__bang_gt_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_gt_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_gt_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are greater than `<value>` and saves the result in `<dst>`. If the element of `<src>` is greater than `<value>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.36. \_\_bang\_gtu
-----------------------




void `__bang_gtu`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_gtu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_gtu`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely to determine whether the element in `<src0>` is unordered or greater than that in `<src1>` and saves the result in `<dst>`. If the element of `<src0>` is unordered or greater than the element of `<src1>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first vector.
* `[in] src1`: The address of the second vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ for more details.













3.24.37. \_\_bang\_gtu\_bitindex
---------------------------------




void `__bang_gtu_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_gtu_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_gtu_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely, if the element of `<src0>` is unordered or greater than that of `<src1>`, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero and divisible by 8.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_bitindex for more details.













3.24.38. \_\_bang\_gtu\_scalar
-------------------------------




void `__bang_gtu_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_gtu_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_gtu_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are unordered or greater than `<value>` and saves the result in `<dst>`. If the element of `<src>` is unordered or greater than `<value>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_scalar for more details.













3.24.39. \_\_bang\_le
----------------------




void `__bang_le`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_le`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_le`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely to determine whether the element in `<src0>` is less than or equal to that in `<src1>` and saves the result in `<dst>`. If the element of `<src0>` is less than or equal to the element of `<src1>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first vector.
* `[in] src1`: The address of the second vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq for more details.













3.24.40. \_\_bang\_le\_bitindex
--------------------------------




void `__bang_le_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_le_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_le_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely, if the element of `<src0>` is less than or equal to that of `<src1>`, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.
The comparison process is illustrated in the figure below, the comparison result between the first element `<element0>` of `<src0>` and the first element `<element0>` of `<src1>` will be saved in `<bit0>` of `<dst>` . The other elements do the same comparison in turn.




Fig. 3.13 The Calculation Process of Half Type `\_\_bang\_le\_bitindex`












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be divisible by 512 on `(m)tp\_2xx`;
* `<elem\_count>` must be divisible by 8 on `(m)tp\_3xx` or higher;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq\_bitindex for more details.













3.24.41. \_\_bang\_le\_scalar
------------------------------




void `__bang_le_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_le_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_le_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are less than or equal to `<value>` and saves the result in `<dst>`. If the element of `<src>` is less than or equal to `<value>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.42. \_\_bang\_leu
-----------------------




void `__bang_leu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_leu`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_leu`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely to determine whether the element in `<src0>` is unordered or less than or equal to that in `<src1>` and saves the result in `<dst>`. If the element of `<src0>` is unordered or less than or equal to the element of `<src1>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first vector.
* `[in] src1`: The address of the second vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ for more details.













3.24.43. \_\_bang\_leu\_bitindex
---------------------------------




void `__bang_leu_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_leu_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_leu_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely, if the element of `<src0>` is unordered or less than or equal to that of `<src1>`, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero and divisible by 8.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_bitindex for more details.













3.24.44. \_\_bang\_leu\_scalar
-------------------------------




void `__bang_leu_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_leu_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_leu_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are unordered or less than or equal to `<value>` and saves the result in `<dst>`. If the element of `<src>` is unordered or less than or equal to `<value>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_scalar for more details.













3.24.45. \_\_bang\_lt
----------------------




void `__bang_lt`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_lt`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_lt`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_lt`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_lt`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_lt`(unsigned char \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_lt`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_lt`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_lt`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely to determine whether the element in `<src0>` is less than that in `<src1>` and saves the result in `<dst>`. If the element of `<src0>` is less than the element of `<src1>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first vector.
* `[in] src1`: The address of the second vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq for more details.













3.24.46. \_\_bang\_lt\_bitindex
--------------------------------




void `__bang_lt_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_lt_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_lt_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely, if the element of `<src0>` is less than that of `<src1>`, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.
The comparison process is illustrated in the figure below, the comparison result between the first element `<element0>` of `<src0>` and the first element `<element0>` of `<src1>` will be saved in `<bit0>` of `<dst>` . The other elements do the same comparison in turn.




Fig. 3.14 The Calculation Process of Half Type `\_\_bang\_lt\_bitindex`












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be divisible by 512 on `(m)tp\_2xx`;
* `<elem\_count>` must be divisible by 8 on `(m)tp\_3xx` or higher;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq\_bitindex for more details.













3.24.47. \_\_bang\_lt\_scalar
------------------------------




void `__bang_lt_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_lt_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_lt_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_lt_scalar`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *value*, unsigned int *elem\_count*)  




void `__bang_lt_scalar`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned short *value*, unsigned int *elem\_count*)  




void `__bang_lt_scalar`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned char *value*, unsigned int *elem\_count*)  




void `__bang_lt_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_lt_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_lt_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are less than `<value>` and saves the result in `<dst>`. If the element of `<src>` is less than `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are not supported on `tp\_520`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.48. \_\_bang\_ltu
-----------------------




void `__bang_ltu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_ltu`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_ltu`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely to determine whether the element in `<src0>` is unordered or less than that in `<src1>` and saves the result in `<dst>`. If the element of `<src0>` is unordered or less than the element of `<src1>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first vector.
* `[in] src1`: The address of the second vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ for more details.













3.24.49. \_\_bang\_ltu\_bitindex
---------------------------------




void `__bang_ltu_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_ltu_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_ltu_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function compares with `<elem\_count>` elements in `<src0>` and `<src1>` element-wisely, if the element of `<src0>` is unordered or less than that of `<src1>`, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero and divisible by 8.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_bitindex for more details.













3.24.50. \_\_bang\_ltu\_scalar
-------------------------------




void `__bang_ltu_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_ltu_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_ltu_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are unordered or less than `<value>` and saves the result in `<dst>`. If the element of `<src>` is unordered or less than `<value>`, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_scalar for more details.













3.24.51. \_\_bang\_maxeq\_scalar
---------------------------------




void `__bang_maxeq_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_maxeq_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_maxeq_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_maxeq_scalar`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *value*, unsigned int *elem\_count*)  




void `__bang_maxeq_scalar`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned short *value*, unsigned int *elem\_count*)  




void `__bang_maxeq_scalar`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned char *value*, unsigned int *elem\_count*)  




void `__bang_maxeq_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_maxeq_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_maxeq_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function finds the maximum between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If one of the elements being compared is a NaN, then the element in `<src>` is returned. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are not supported on `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.52. \_\_bang\_maxequal
----------------------------




void `__bang_maxequal`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_maxequal`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_maxequal`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_maxequal`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_maxequal`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_maxequal`(unsigned char \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_maxequal`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_maxequal`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_maxequal`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

Finds maximum value of each two corresponding elements in the two vectors. If one of the elements being compared are NaN, then the element in `<src0>` is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector
* `[in] src0`: The address of first source vector
* `[in] src1`: The address of second source vector
* `[in] elem\_count`: The number of elements in source vector



**Return*** `void`.






**Remark*** `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src0>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.24.53. \_\_bang\_maximum
---------------------------




void `__bang_maximum`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  




void `__bang_maximum`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_maximum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  

Compares two vectors and returns a new vector containing the element-wise maxima. If both of the elements being compared are NaN, then NaN is returned.









**Parameters*** `[out] dst`: The address of destination vector
* `[in] src0`: The address of first source vector
* `[in] src1`: The address of second source vector
* `[in] elem\_count`: The number of elements in source vector



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src0>` or `<src1>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.24.54. \_\_bang\_maximum\_scalar
-----------------------------------




void `__bang_maximum_scalar`(float \**dst*, float \**src*, float *value*, unsigned int *elem\_count*)  




void `__bang_maximum_scalar`(half \**dst*, half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_maximum_scalar`(bfloat16\_t \**dst*, bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  

This function finds the maximum between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If only one of the element in `<src>` and `<value>` is NaN, the result is the other. If both of the elements in `<src>` and `<value>` are NaN, the result is NaN. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.55. \_\_bang\_mineq\_scalar
---------------------------------




void `__bang_mineq_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_mineq_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_mineq_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_mineq_scalar`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *value*, unsigned int *elem\_count*)  




void `__bang_mineq_scalar`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned short *value*, unsigned int *elem\_count*)  




void `__bang_mineq_scalar`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned char *value*, unsigned int *elem\_count*)  




void `__bang_mineq_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_mineq_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_mineq_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function finds the minimum between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If one of the elements being compared is a NaN, then the element in `<src>` is returned. See the table :ref:`floating\_point\_calculation\_of\_stream\_and\_scalar\_binary\_operation\_functions` for accuracy information.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are not supported on `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.56. \_\_bang\_minequal
----------------------------




void `__bang_minequal`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_minequal`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_minequal`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_minequal`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_minequal`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_minequal`(unsigned char \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_minequal`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_minequal`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_minequal`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

Finds minimum value of each two corresponding elements in the two vectors. If one of the elements being compared are NaN, then the element in `<src0>` is returned. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector
* `[in] src0`: The address of first source vector
* `[in] src1`: The address of second source vector
* `[in] elem\_count`: The number of elements in source vector



**Return*** `void`.






**Remark*** `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `int`, `short`, `char`, `unsigned int`, `unsigned short` and `unsigned char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src0>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(half\* c, half\* a, half\* b) {
  \_\_nram\_\_ half a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ half c\_tmp[DATA\_SIZE];
  \_\_nram\_\_ half b\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_minequal(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.24.57. \_\_bang\_minimum
---------------------------




void `__bang_minimum`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  




void `__bang_minimum`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_minimum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  

Compares two vectors and returns a new vector containing the element-wise minima. If both of the elements being compared are NaN, then NaN is returned.









**Parameters*** `[out] dst`: The address of destination vector
* `[in] src0`: The address of first source vector
* `[in] src1`: The address of second source vector
* `[in] elem\_count`: The number of elements in source vector



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src0>` or `<src1>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.24.58. \_\_bang\_minimum\_scalar
-----------------------------------




void `__bang_minimum_scalar`(float \**dst*, float \**src*, float *value*, unsigned int *elem\_count*)  




void `__bang_minimum_scalar`(half \**dst*, half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_minimum_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  

This function finds the minimum between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If only one of the element in `<src>` and `<value>` is NaN, the result is the other. If both of the elements in `<src>` and `<value>` are NaN, the result is NaN. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.59. \_\_bang\_nan\_argmax
-------------------------------




void `__bang_nan_argmax`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_nan_argmax`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_nan_argmax`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Finds the maximum value and its corresponding index in `<src>` vector. The result is composed of two parts. The first part is the maximum value of corresponding type, and the second part is the index of the first maximum value position in `<src>` vector, whose data type is `unsigned int`. The maximum value and index are stored continuously in `<dst>`. If one of the elements being compared is a NaN, then that element and its corresponding index are returned. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define DATA\_NUM 90

\_\_mlu\_entry\_\_ void kernel\_max(float\* dst, float\* src) {
  \_\_nram\_\_ float dst\_nram[DATA\_NUM];
  \_\_nram\_\_ float src\_nram[DATA\_NUM];
  \_\_memcpy(src\_nram, src, DATA\_NUM \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_nan\_argmax(dst\_nram, src\_nram, DATA\_NUM);
  \_\_memcpy(dst, dst\_nram, DATA\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.24.60. \_\_bang\_nan\_argmin
-------------------------------




void `__bang_nan_argmin`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_nan_argmin`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_nan_argmin`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Finds the minimum value and its corresponding index in `<src>` vector. The result is composed of two parts. The first part is the minimum value of corresponding type, and the second part is the index of the first minimum value position in `<src>` vector, whose data type is `unsigned int`. The minimum value and index are stored continuously in `<dst>`. If one of the elements being compared is a NaN, then that element and its corresponding index are returned. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define DATA\_NUM 90

\_\_mlu\_entry\_\_ void kernel\_min(float\* dst, float\* src) {
  \_\_nram\_\_ float dst\_nram[DATA\_NUM];
  \_\_nram\_\_ float src\_nram[DATA\_NUM];
  \_\_memcpy(src\_nram, src, DATA\_NUM \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_nan\_argmin(dst\_nram, src\_nram, DATA\_NUM);
  \_\_memcpy(dst, dst\_nram, DATA\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.24.61. \_\_bang\_nan\_maximum
--------------------------------




void `__bang_nan_maximum`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_nan_maximum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_nan_maximum`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

Compares two vectors and returns a new vector containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned.









**Parameters*** `[out] dst`: The address of destination vector
* `[in] src0`: The address of first source vector
* `[in] src1`: The address of second source vector
* `[in] elem\_count`: The number of elements in source vector



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src0>` or `<src1>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.24.62. \_\_bang\_nan\_maximum\_scalar
----------------------------------------




void `__bang_nan_maximum_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  




void `__bang_nan_maximum_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_nan_maximum_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  

This function finds the maximum between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If only one of the element in `<src>` and `<value>` is NaN, the result is NaN. If both of the elements in `<src>` and `<value>` are NaN, the result is NaN. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.63. \_\_bang\_nan\_minimum
--------------------------------




void `__bang_nan_minimum`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_nan_minimum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_nan_minimum`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

Compares two vectors and returns a new vector containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned.









**Parameters*** `[out] dst`: The address of destination vector
* `[in] src0`: The address of first source vector
* `[in] src1`: The address of second source vector
* `[in] elem\_count`: The number of elements in source vector



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src0>` or `<src1>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.24.64. \_\_bang\_nan\_minimum\_scalar
----------------------------------------




void `__bang_nan_minimum_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  




void `__bang_nan_minimum_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_nan_minimum_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  

This function finds the minimum between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If only one of the element in `<src>` and `<value>` is NaN, the result is NaN. If both of the elements in `<src>` and `<value>` are NaN, the result is NaN. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.3.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.65. \_\_bang\_ne
----------------------




void `__bang_ne`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_ne`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_ne`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_ne`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_ne`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_ne`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs inequality comparison with `<src0>` and `<src1>` element-wisely and saves the result in `<dst>`. If the element of `<src0>` and the element of `<src1>` are not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq for more details.













3.24.66. \_\_bang\_ne\_bitindex
--------------------------------




void `__bang_ne_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_ne_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_ne_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs inequality comparison with `<src0>` and `<src1>` element-wisely. If the two elements are not equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.
The comparison process is illustrated in the figure below, the comparison result between the first element `<element0>` of `<src0>` and the first element `<element0>` of `<src1>` will be saved in `<bit0>` of `<dst>` . The other elements do the same comparison in turn.




Fig. 3.15 The Calculation Process of Half Type `\_\_bang\_ne\_bitindex`












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be divisible by 512 on `(m)tp\_2xx`;
* `<elem\_count>` must be divisible by 8 on `(m)tp\_3xx` or higher;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_eq\_bitindex for more details.













3.24.67. \_\_bang\_ne\_scalar
------------------------------




void `__bang_ne_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_ne_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_ne_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_ne_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_ne_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_ne_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function performs inequality comparison with `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. The type of result is same as the type of `<src>`. If the element of `<src>` and `<value>` are not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `int`, `short` and `char` are not supported on `tp\_520`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_eq\_scalar for more details.













3.24.68. \_\_bang\_neu
-----------------------




void `__bang_neu`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_neu`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_neu`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs unoredred or inequality comparison with `<src0>` and `<src1>` element-wisely and saves the result in `<dst>`. If the element of `<src0>` and the element of `<src1>` are unordered or not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ for more details.













3.24.69. \_\_bang\_neu\_bitindex
---------------------------------




void `__bang_neu_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_neu_bitindex`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_neu_bitindex`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs unordered or inequality comparison with `<src0>` and `<src1>` element-wisely. If the two elements are unordered or not equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` , `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero and divisible by 8.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_bitindex for more details.













3.24.70. \_\_bang\_neu\_scalar
-------------------------------




void `__bang_neu_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_neu_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_neu_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function performs unordered or inequality comparison with `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. The type of result is same as the type of `<src>`. If the element of `<src>` and `<value>` are unordered or not equal, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** See the example of \_\_bang\_equ\_scalar for more details.

















3.25. Vector Fusion Functions
==============================



3.25.1. \_\_bang\_fcmpfilter
-----------------------------




void `__bang_fcmpfilter`(CompareMode *mode*, half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_fcmpfilter`(CompareMode *mode*, half \**dst*, *const* half \**src0*, half *src1*, unsigned int *elem\_count*)  




void `__bang_fcmpfilter`(CompareMode *mode*, float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  




void `__bang_fcmpfilter`(CompareMode *mode*, bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, bfloat16\_t *src1*, unsigned int *elem\_count*)  




void `__bang_fcmpfilter`(CompareMode *mode*, bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_fcmpfilter`(CompareMode *mode*, float \**dst*, *const* float \**src0*, float *src1*, unsigned int *elem\_count*)  

This function performs element-wise comparison with `<src0>` and `<src1>` according to `<mode>`. `<mode>` indicates the type of comparison. `<mode>` is assigned to an enumerated type called `CompareMode` that contains six enumerators listed in the table below. The elements in `<src0>` that meet the given comparison criteria `<mode>` will be selected and written to `<dst>` continuously. The result is composed of two parts. The first part is the number of selected elements in `<src0>`, whose data type is `unsigned int`, and the second part is the selected elements.




Table 3.58 Semantics of `CompareMode`



| `CompareMode` Type | Semantic |
| --- | --- |
| `CMP\_EQ` | \(=\) |
| `CMP\_NE` | \(\neq\) |
| `CMP\_LT` | \(<\) |
| `CMP\_LE` | \(\leq\) |
| `CMP\_GT` | \(>\) |
| `CMP\_GE` | \(\geq\) |








See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[in] mode`: The comparison mode.
* `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector or the second source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>` and `<dst>` must point to `\_\_nram\_\_` address space. `<src1>` must also point to `\_\_nram\_\_` address space if it is a vector;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src1>` can be either vectors or scalars. When `<src1>` is a vector, the length of `<src1>` must be the same as that of `<src0>`;
* `<dst>` can be overlapped with `<src0>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
 #include <bang.h>

 #define ELEM\_NUM 128
 #define RES\_ELEM\_NUM (ELEM\_NUM + 1)

 \_\_mlu\_entry\_\_ void kernel\_fabs(CompareMode mode, float\* dst,
                                float \*src0, float \*src1) {
   \_\_nram\_\_ float dst\_nram[RES\_ELEM\_NUM];
   \_\_nram\_\_ float src0\_nram[ELEM\_NUM];
   \_\_nram\_\_ float src1\_nram[ELEM\_NUM];
   \_\_memcpy(src0\_nram, src0, ELEM\_NUM \* sizeof(float), GDRAM2NRAM);
   \_\_memcpy(src1\_nram, src1, ELEM\_NUM \* sizeof(float), GDRAM2NRAM);
   \_\_bang\_fcmpfilter(mode, dst\_nram, src0\_nram, src1\_nram, ELEM\_NUM);
   \_\_memcpy(dst, dst\_nram, RES\_ELEM\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.25.2. \_\_bang\_fusion
-------------------------




void `__bang_fusion`(mluFusionOpCode *op\_code*, half \**dst*, *const* half \**src0*, half *src1*, half *src2*, unsigned int *src\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, float \**dst*, *const* float \**src0*, *const* float \**src1*, float *src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, float \**dst*, *const* float \**src0*, float *src1*, *const* float \**src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, float \**dst*, *const* float \**src0*, float *src1*, float *src2*, unsigned int *src\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, half \**dst*, *const* half \**src0*, *const* half \**src1*, *const* half \**src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, half \**dst*, *const* half \**src0*, *const* half \**src1*, half *src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, half \**dst*, *const* half \**src0*, half *src1*, *const* half \**src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, *const* bfloat16\_t \**src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, bfloat16\_t *src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, bfloat16\_t *src1*, *const* bfloat16\_t \**src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, bfloat16\_t *src1*, bfloat16\_t *src2*, unsigned int *src\_elem\_count*)  




void `__bang_fusion`(mluFusionOpCode *op\_code*, float \**dst*, *const* float \**src0*, *const* float \**src1*, *const* float \**src2*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

This function performs fused arithmetic calculation on vectors `<src0>` , `<src1>` and `<src2>` element-wisely according to `<op\_code>` and saves the result in `<dst>`. `<op\_code>` indicates the type of operator. `<op\_code>` is assigned to an enumerated type called `mluFusionOpCode` that contains eight enumerators listed in the table below. 

Table 3.59 Semantics of `mluFusionOpCode`



| `mluFusionOpCode` Type | Semantic |
| --- | --- |
| `FUSION\_FMA` | \(<dst> = <src0> \times <src1> + <src2>\) |
| `FUSION\_FMS` | \(<dst> = <src0> \times <src1> - <src2>\) |
| `FUSION\_FAM` | \(<dst> = (<src0> + <src1>) \times <src2>\) |
| `FUSION\_FSM` | \(<dst> = (<src0> - <src1>) \times <src2>\) |
| `FUSION\_FAA` | \(<dst> = <src0> + <src1> + <src2>\) |
| `FUSION\_FAS` | \(<dst> = <src0> + <src1> - <src2>\) |
| `FUSION\_FSS` | \(<dst> = <src0> - <src1> - <src2>\) |
| `FUSION\_FSA` | \(<dst> = <src0> - <src1> + <src2>\) |



Note


For the last two characters of enumerators, M means multiplication, A means addition and S means subtraction.









See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[in] op\_code`: The type of operator.
* `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The second source scalar or the address of the second source vector.
* `[in] src2`: The third source scalar or the address of the third source vector.
* `[in] src\_elem\_count`: The number of elements in `<dst>` and `<src0>`.
* `[in] seg\_elem\_count`: The number of elements in `<src1>` and `<src2>`.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src0>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src1>` or `<src2>` must also point to `\_\_nram\_\_` address space if it is a vector;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define BUF\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*mlu\_dst,
                          float \*mlu\_src0,
                          float \*mlu\_src1,
                          float \*mlu\_src2) {
    \_\_nram\_\_ float nram\_output[BUF\_SIZE];
    \_\_nram\_\_ float nram\_input0[BUF\_SIZE];
    \_\_nram\_\_ float nram\_input1[BUF\_SIZE];
    \_\_nram\_\_ float nram\_input2[BUF\_SIZE];
    \_\_memcpy(nram\_input0, mlu\_src0, BUF\_SIZE \* sizeof(float), GDRAM2NRAM);
    \_\_memcpy(nram\_input1, mlu\_src1, BUF\_SIZE \* sizeof(float), GDRAM2NRAM);
    \_\_memcpy(nram\_input2, mlu\_src2, BUF\_SIZE \* sizeof(float), GDRAM2NRAM);
    \_\_bang\_fusion(FUSION\_FMA, nram\_output, nram\_input0,
                  nram\_input1, nram\_input2, BUF\_SIZE, BUF\_SIZE);
    \_\_memcpy(mlu\_dst, nram\_output, BUF\_SIZE, NRAM2GDRAM);
}

```

















3.26. Vector Logic Functions
=============================



3.26.1. \_\_bang\_and
----------------------




void `__bang_and`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_and`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_and`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_and`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_and`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_and`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

Performs logical AND operation between elements in two vectors. If both the elements of `<src0>` and `<src1>` are non-zero, the result is 1. Otherwise, the result is 0. The type of result is the same as that of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src0>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(half\* c, half\* a, half\* b) {
  \_\_nram\_\_ half a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ half c\_tmp[DATA\_SIZE];
  \_\_nram\_\_ half b\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_and(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.26.2. \_\_bang\_and\_scalar
------------------------------




void `__bang_and_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_and_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_and_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_and_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_and_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_and_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function performs logical AND operation between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If both the elements of `<src>` and `<value>` are non-zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `int`, `short` and `char` are not supported on `tp\_520`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_and\_scalar(c\_tmp, a\_tmp, b, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.26.3. \_\_bang\_cycle\_and
-----------------------------




void `__bang_cycle_and`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_and`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_and`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_and`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_and`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_and`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part AND the corresponding element in `<seg>`. The result is assigned to `<dst>`. If both the elements of `<src0>` and `<src1>` are non-zero, the result is 1. Otherwise, the result is 0. The type of result is the same as that of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short` and `char`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define N1 128
#define N2 32640

\_\_mlu\_entry\_\_ void kernel(float \*c, float \*a, float \*b) {
  \_\_nram\_\_ float a\_tmp[N1];
  \_\_nram\_\_ float b\_tmp[N2];
  \_\_nram\_\_ float c\_tmp[N2];
  \_\_memcpy(a\_tmp, a, N1 \* sizeof(float), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, N2 \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_cycle\_and(c\_tmp, b\_tmp, a\_tmp, N2, N1);
  \_\_memcpy(c, c\_tmp, N2 \* sizeof(float), NRAM2GDRAM);
}

```













3.26.4. \_\_bang\_cycle\_or
----------------------------




void `__bang_cycle_or`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_or`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_or`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_or`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_or`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_or`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part OR the corresponding element in `<seg>`. The result is assigned to `<dst>`. If both the elements of `<src0>` and `<src1>` are zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short` and `char`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.26.5. \_\_bang\_cycle\_xor
-----------------------------




void `__bang_cycle_xor`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_xor`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_xor`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_xor`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_xor`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_xor`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part XOR the corresponding element in `<seg>`. The result is assigned to `<dst>`. If both the elements of `<src0>` and `<src1>` are zero or non-zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher, except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short` and `char`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.26.6. \_\_bang\_not
----------------------




void `__bang_not`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_not`(int \**dst*, *const* int \**src*, unsigned int *elem\_count*)  




void `__bang_not`(short \**dst*, *const* short \**src*, unsigned int *elem\_count*)  




void `__bang_not`(char \**dst*, *const* char \**src*, unsigned int *elem\_count*)  




void `__bang_not`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_not`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies element-wisely NOT operation on a vector. For each element in `<src>`, if it equals to zero, then stores 1 at the corresponding position in `<dst>`; otherwise, stores 0 at the position in `<dst>`. The type of result is the same as that of `<src>`. See the table Floating Point Calculation of Stream and Scalar Unary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.26.7. \_\_bang\_or
---------------------




void `__bang_or`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_or`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_or`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_or`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_or`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_or`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

Performs logical OR operation between elements in two vectors. If both the elements of `<src0>` and `<src1>` are zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.26.8. \_\_bang\_or\_scalar
-----------------------------




void `__bang_or_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_or_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_or_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_or_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_or_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_or_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function performs logical OR operation between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If either the element of `<src>` or `<value>` is non-zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `int`, `short` and `char` are not supported on `tp\_520`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_and\_scalar for more details.













3.26.9. \_\_bang\_xor
----------------------




void `__bang_xor`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_xor`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_xor`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_xor`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_xor`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_xor`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

Performs logical XOR operation between elements in two vectors. If both the elements of `<src0>` and `<src1>` are zero or non-zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of `<src0>` and `<src1>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src0>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(half\* c, half\* a, half\* b) {
  \_\_nram\_\_ half a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ half c\_tmp[DATA\_SIZE];
  \_\_nram\_\_ half b\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_xor(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.26.10. \_\_bang\_xor\_scalar
-------------------------------




void `__bang_xor_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_xor_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_xor_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_xor_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_xor_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_xor_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function performs logical OR operation between `<elem\_count>` elements of `<src>` and `<value>` and saves the result in `<dst>`. If the element of `<src>` is zero and `<value>` is non-zero, or the element of `<src>` is non-zero and `<value>` is zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* `int`, `short` and `char` are not supported on `tp\_520`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_and\_scalar for more details.

















3.27. Vector Movement Functions
================================



3.27.1. \_\_bang\_filter
-------------------------




unsigned int `__bang_filter`(half \**dst*, *const* half \**src*, *const* half \**index*, unsigned int *elem\_count*)  




unsigned int `__bang_filter`(float \**dst*, *const* float \**src*, *const* float \**index*, unsigned int *elem\_count*)  




unsigned int `__bang_filter`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**index*, unsigned int *elem\_count*)  

Copies elements from `<src>` to `<dst>` if the corresponding values in `<index>` is not equal to zero, and returns the number of selected elements. The selected elements are stored continuously in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] index`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `unsigned int`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* The `<src>`, `<index>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be a multiple of 128 bytes on `(m)tp\_2xx`;
* The address of `<src>`, `<index>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* On `(m)tp\_2xx`, if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;
* On `(m)tp\_2xx`, the reserved space for selected data in `<dst>` cannot be smaller than the size of `<src>` and if the selected elements(including pad) does not fill the entire `<dst>` space, the remaining data in `<dst>` may also be changed.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.2. \_\_bang\_filter\_bitindex
-----------------------------------




unsigned int `__bang_filter_bitindex`(half \**dst*, *const* half \**src*, *const* void \**bitmask*, unsigned int *elem\_count*)  




unsigned int `__bang_filter_bitindex`(float \**dst*, *const* float \**src*, *const* void \**bitmask*, unsigned int *elem\_count*)  




unsigned int `__bang_filter_bitindex`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* void \**bitmask*, unsigned int *elem\_count*)  

Copies elements from `<src>` to `<dst>` if the corresponding bit values in `<bitmask>` is not equal to zero, and returns the number of selected elements. The selected elements are stored continuously in `<dst>`. The behavior is illustrated in the figure below, in this example, `<bitmask>` is 0x41100000.




Fig. 3.16 The Calculation Process of Floating-point Type `\_\_bang\_filter\_bitindex`












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] bitmask`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `unsigned int`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<elem\_count>` must be divisible by 512 on `(m)tp\_2xx` and by 8 on `mtp\_372`;
* `<dst>` can be overlapped with `<src>`;
* The `<src>`, `<bitmask>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<bitmask>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* On `(m)tp\_2xx`, if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;
* On `(m)tp\_2xx`, the reserved space for selected data in `<dst>` cannot be smaller than the size of `<src>` and if the selected elements(including pad) does not fill the entire `<dst>` space, the remaining data in `<dst>` may also be changed.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.3. \_\_bang\_maskmove
---------------------------




void `__bang_maskmove`(void \**dst*, *const* void \**src*, *const* void \**mask*, unsigned int *size*)  

Selects bytes in `<src>`, whose length is `<size>`, according to the bit value of the vector `<mask>`, and stores the result in `<dst>`. The bytes in `<src>` will be selected if corresponding bit in `<mask>` is 1, otherwise, keeps the corresponding byte in `<dst>` unchanged.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] mask`: The address of mask vector.
* `[in] size`: The length of source vector.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<size>` must be divisible by 1024 on `(m)tp\_2xx`;
* `<size>` must be divisible by 8 on `(m)tp\_3xx`;
* `<src>`, `<mask>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<mask>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.4. \_\_bang\_mirror
-------------------------




void `__bang_mirror`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_mirror`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_mirror`(char \**dst*, *const* char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_mirror`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_mirror`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_mirror`(short \**dst*, *const* short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_mirror`(half \**dst*, *const* half \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_mirror`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *height*, unsigned int *width*)  

Flips `<src>`, a matrix whose size is `<height>` \* `<width>`, in the left/right direction, and stores the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination matrix.
* `[in] src`: The address of source matrix.
* `[in] height`: The width of `<src>`.
* `[in] width`: The height of `<src>`.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<height>` \* sizeof(type) must be divisible by 64 on `(m)tp\_2xx`;
* `<width>` \* sizeof(type) must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* `<height>` and `<width>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define WIDTH 64
#define HEIGHT 32
#define LEN (WIDTH \* HEIGHT)

\_\_mlu\_entry\_\_ void kernel(short\* dst, short\* src) {
  \_\_nram\_\_ short ny[LEN];
  \_\_nram\_\_ short nx[LEN];
  \_\_memcpy(nx, src, LEN \* sizeof(short), GDRAM2NRAM);
  \_\_bang\_mirror(ny, nx, HEIGHT, WIDTH);
  \_\_memcpy(dst, ny, sizeof(short) \* LEN, NRAM2GDRAM);
}

```













3.27.5. \_\_bang\_pad
----------------------




void `__bang_pad`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  




void `__bang_pad`(short \**dst*, *const* short \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  




void `__bang_pad`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  




void `__bang_pad`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  




void `__bang_pad`(char \**dst*, *const* char \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  




void `__bang_pad`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  




void `__bang_pad`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  




void `__bang_pad`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  




void `__bang_pad`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*, half *pad\_value*)  




void `__bang_pad`(short \**dst*, *const* short \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*, short *pad\_value*)  




void `__bang_pad`(char \**dst*, *const* char \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*, char *pad\_value*)  




void `__bang_pad`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*, float *pad\_value*)  




void `__bang_pad`(int \**dst*, *const* int \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*, unsigned int *pad\_value*)  




void `__bang_pad`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*, bfloat16\_t *pad\_value*)  




void `__bang_pad`(int \**dst*, *const* int \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_top*, unsigned int *pad\_bottom*, unsigned int *pad\_left*, unsigned int *pad\_right*)  

Applies padding operation on `<src>`.



**Parameters*** `[out] dst`: The destination vector, whose data layout is HWC.
* `[in] src`: The source vector, whose data layout is HWC.
* `[in] channel`: Number of channels.
* `[in] height`: The height of `<src>`.
* `[in] width`: The width of `<src>`.
* `[in] pad\_top`: Number of rows whose elements is all zero or `<pad\_value>` on the top of pad.
* `[in] pad\_bottom`: Number of rows whose elements is all zero or `<pad\_value>` on the bottom of pad.
* `[in] pad\_left`: Number of columns whose elements is all zero or `<pad\_value>` on the left of pad.
* `[in] pad\_right`: Number of columns whose elements is all zero or `<pad\_value>` on the right of pad.
* `[in] pad\_value`: The value of padding.



**Return*** `void`.






**Remark*** `<height>` and `<width>` must be greater than 0;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` cannot be overlapped with `<src>`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* If `<height> == 1`, `<pad\_left>` and `<pad\_right>` must be equal to 0;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel> \* <width> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* `<pad\_left> \* <channel> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* `<pad\_right> \* <channel> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* `<pad\_value>` are only supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include<bang.h>

#define PAD\_H 1
#define PAD\_W 2
#define INPUT\_H 4
#define INPUT\_W 4
#define CHANNEL 64

\_\_mlu\_entry\_\_ void kernel(half \*out, half \*in) {
  \_\_nram\_\_ half nx[CHANNEL \* INPUT\_H \* INPUT\_W];
  \_\_nram\_\_ half ny[CHANNEL \* (INPUT\_H + 2 \* PAD\_H) \* (INPUT\_W + 2 \* PAD\_W)];
  \_\_memcpy(nx, in, CHANNEL \* INPUT\_H \* INPUT\_W \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_pad(ny, nx, CHANNEL, INPUT\_H, INPUT\_W, PAD\_H, PAD\_H, PAD\_W, PAD\_W);
  \_\_memcpy(out, ny, CHANNEL \* (INPUT\_H + 2 \* PAD\_H) \* (INPUT\_W + 2 \* PAD\_W) \* sizeof(half), NRAM2GDRAM);
}

```













3.27.6. \_\_bang\_rotate180
----------------------------




void `__bang_rotate180`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(char \**dst*, *const* char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(half \**dst*, *const* half \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(short \**dst*, *const* short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(float \**dst*, *const* float \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(int \**dst*, *const* int \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate180`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *height*, unsigned int *width*)  

Rotates `<src>` , a matrix, whose size is `<height>` \* `<width>` , by 180 degrees in clockwise direction, and stores the result in `<dst>` .



**Parameters*** `[out] dst`: The address of destination matrix.
* `[in] src`: The address of source matrix.
* `[in] height`: The height of `<src>`.
* `[in] width`: The width of `<src>`.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<height>` \* sizeof(type) and `<width>` \* sizeof(type) must be divisible by 128 bytes on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* `<height>` and `<width>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.7. \_\_bang\_rotate270
----------------------------




void `__bang_rotate270`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(char \**dst*, *const* char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(half \**dst*, *const* half \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(short \**dst*, *const* short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(float \**dst*, *const* float \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(int \**dst*, *const* int \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate270`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *height*, unsigned int *width*)  

Rotates `<src>` , a matrix, whose size is `<height>` \* `<width>` , by 270 degrees in clockwise direction, and stores the result in `<dst>` .



**Parameters*** `[out] dst`: The address of destination matrix.
* `[in] src`: The address of source matrix.
* `[in] height`: The height of `<src>`.
* `[in] width`: The width of `<src>`.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<height>` \* sizeof(type) and `<width>` \* sizeof(type) must be divisible by 128 bytes on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* `<height>` and `<width>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.8. \_\_bang\_rotate90
---------------------------




void `__bang_rotate90`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(char \**dst*, *const* char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(half \**dst*, *const* half \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(short \**dst*, *const* short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(float \**dst*, *const* float \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(int \**dst*, *const* int \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_rotate90`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *height*, unsigned int *width*)  

Rotates `<src>` , a matrix, whose size is `<height>` \* `<width>` , by 90 degrees in clockwise direction, and stores the result in `<dst>` .



**Parameters*** `[out] dst`: The address of destination matrix.
* `[in] src`: The address of source matrix.
* `[in] height`: The height of `<src>`.
* `[in] width`: The width of `<src>`.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<height> \* sizeof(type)` and `<width>` \* sizeof(type) must be divisible by 128 bytes on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* `<height>` and `<width>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define WIDTH 128
#define HEIGHT 64
#define LEN (HEIGHT \* WIDTH)

\_\_mlu\_entry\_\_ void kernel(unsigned char\* dst, unsigned char\* src) {
  \_\_nram\_\_ unsigned char ny[LEN];
  \_\_nram\_\_ unsigned char nx[LEN];
  \_\_memcpy(nx, src, LEN \* sizeof(unsigned char), GDRAM2NRAM);
  \_\_bang\_rotate90(ny, nx, HEIGHT, WIDTH);
  \_\_memcpy(dst, ny, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.27.9. \_\_bang\_tiling\_2d\_b128
-----------------------------------




void `__bang_tiling_2d_b128`(void \**dst*, *const* void \**src*, unsigned int *n2*, unsigned int *s2*, unsigned int *n1*, unsigned int *s1*, unsigned int *n7*, unsigned int *s7*, unsigned int *n6*, unsigned int *s6*)  

Applies 2D tiling operation on `<src>` for matrix transpose and store the matrix to the `<dst>`.


As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. `<s1>` of data in each segment are copied to destination area `<n1>` times. There are 4 segments in the second dimension. `<s2>` of data in each segment are copied to destination area `<n2>` times. Then, calculate matrix transpose based on 128-bit as one element and store the matrix into corresponding segments and dimensions of `<dst>`.









**Parameters*** `[out] dst`: The address of output matrix.
* `[in] src`: The address of input matrix.
* `[in] n2`: Tiling input iteration 2.
* `[in] s2`: Tiling input stride 2.
* `[in] n1`: Tiling input iteration 1.
* `[in] s1`: Tiling input stride 1.
* `[in] n7`: Tiling output iteration 7.
* `[in] s7`: Tiling output stride 7.
* `[in] n6`: Tiling output iteration 6.
* `[in] s6`: Tiling output stride 6.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* \(<n1> \times <n2> = <n6> \times <n7> = 4\);
* `<n1>`, `<n2>`, `<n6>` and `<n7>` must be an immediate integer on `(m)tp\_2xx`;
* `<s1>`, `<s2>`, `<s6>` and `<s7>` must be greater than or equal to zero;
* Unit of `<s1>`, `<s2>`, `<s6>`, `<s7>` is 64 bytes;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.10. \_\_bang\_tiling\_2d\_b16
-----------------------------------




void `__bang_tiling_2d_b16`(void \**dst*, *const* void \**src*, unsigned int *n2*, unsigned int *s2*, unsigned int *n1*, unsigned int *s1*, unsigned int *n7*, unsigned int *s7*, unsigned int *n6*, unsigned int *s6*)  

Applies 2D tiling operation on `<src>` for matrix transpose and store the matrix to the `<dst>`.


As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. `<s1>` of data in each segment are copied to destination area `<n1>` times. There are 4 segments in the second dimension. `<s2>` of data in each segment are copied to destination area `<n2>` times. Then, calculate matrix transpose based on 16-bit as one element and store the matrix into corresponding segments and dimensions of `<dst>`.









**Parameters*** `[out] dst`: The address of output matrix.
* `[in] src`: The address of input matrix.
* `[in] n2`: Tiling input iteration 2.
* `[in] s2`: Tiling input stride 2.
* `[in] n1`: Tiling input iteration 1.
* `[in] s1`: Tiling input stride 1.
* `[in] n7`: Tiling output iteration 7.
* `[in] s7`: Tiling output stride 7.
* `[in] n6`: Tiling output iteration 6.
* `[in] s6`: Tiling output stride 6.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* \(<n1> \times <n2> = <n6> \times <n7> = 32\);
* `<n1>`, `<n2>`, `<n6>` and `<n7>` must be an immediate integer on `(m)tp\_2xx`;
* `<s1>`, `<s2>`, `<s6>` and `<s7>` must be greater than or equal to zero;
* Unit of `<s1>`, `<s2>`, `<s6>`, `<s7>` is 64 bytes;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.11. \_\_bang\_tiling\_2d\_b256
------------------------------------




void `__bang_tiling_2d_b256`(void \**dst*, *const* void \**src*, unsigned int *n2*, unsigned int *s2*, unsigned int *n1*, unsigned int *s1*, unsigned int *n7*, unsigned int *s7*, unsigned int *n6*, unsigned int *s6*)  

Applies 2D tiling operation on `<src>` for matrix transpose and store the matrix to the `<dst>`.


As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. `<s1>` of data in each segment are copied to destination area `<n1>` times. There are 4 segments in the second dimension. `<s2>` of data in each segment are copied to destination area `<n2>` times. Then, calculate matrix transpose based on 256-bit as one element and store the matrix into corresponding segments and dimensions of `<dst>`.









**Parameters*** `[out] dst`: The address of output matrix.
* `[in] src`: The address of input matrix.
* `[in] n2`: Tiling input iteration 2.
* `[in] s2`: Tiling input stride 2.
* `[in] n1`: Tiling input iteration 1.
* `[in] s1`: Tiling input stride 1.
* `[in] n7`: Tiling output iteration 7.
* `[in] s7`: Tiling output stride 7.
* `[in] n6`: Tiling output iteration 6.
* `[in] s6`: Tiling output stride 6.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* \(<n1> \times <n2> = <n6> \times <n7> = 2\);
* `<n1>`, `<n2>`, `<n6>` and `<n7>` must be an immediate integer on `(m)tp\_2xx`;
* `<s1>`, `<s2>`, `<s6>` and `<s7>` must be greater than or equal to zero;
* Unit of `<s1>`, `<s2>`, `<s6>`, `<s7>` is 64 bytes;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.12. \_\_bang\_tiling\_2d\_b32
-----------------------------------




void `__bang_tiling_2d_b32`(void \**dst*, *const* void \**src*, unsigned int *n2*, unsigned int *s2*, unsigned int *n1*, unsigned int *s1*, unsigned int *n7*, unsigned int *s7*, unsigned int *n6*, unsigned int *s6*)  

Applies 2D tiling operation on `<src>` for matrix transpose and store the matrix to the `<dst>`.


As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. `<s1>` of data in each segment are copied to destination area `<n1>` times. There are 4 segments in the second dimension. `<s2>` of data in each segment are copied to destination area `<n2>` times. Then, calculate matrix transpose based on 32-bit as one element and store the matrix into corresponding segments and dimensions of `<dst>`.









**Parameters*** `[out] dst`: The address of output matrix.
* `[in] src`: The address of input matrix.
* `[in] n2`: Tiling input iteration 2.
* `[in] s2`: Tiling input stride 2.
* `[in] n1`: Tiling input iteration 1.
* `[in] s1`: Tiling input stride 1.
* `[in] n7`: Tiling output iteration 7.
* `[in] s7`: Tiling output stride 7.
* `[in] n6`: Tiling output iteration 6.
* `[in] s6`: Tiling output stride 6.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* \(<n1> \times <n2> = <n6> \times <n7> = 16\);
* `<n1>`, `<n2>`, `<n6>` and `<n7>` must be an immediate integer on `(m)tp\_2xx`;
* `<s1>`, `<s2>`, `<s6>` and `<s7>` must be greater than or equal to zero;
* Unit of `<s1>`, `<s2>`, `<s6>`, `<s7>` is 64 bytes;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.13. \_\_bang\_tiling\_2d\_b64
-----------------------------------




void `__bang_tiling_2d_b64`(void \**dst*, *const* void \**src*, unsigned int *n2*, unsigned int *s2*, unsigned int *n1*, unsigned int *s1*, unsigned int *n7*, unsigned int *s7*, unsigned int *n6*, unsigned int *s6*)  

Applies 2D tiling operation on `<src>` for matrix transpose and store the matrix to the `<dst>`.


As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. `<s1>` of data in each segment are copied to destination area `<n1>` times. There are 4 segments in the second dimension. `<s2>` of data in each segment are copied to destination area `<n2>` times. Then, calculate matrix transpose based on 64-bit as one element and store the matrix into corresponding segments and dimensions of `<dst>`.









**Parameters*** `[out] dst`: The address of output matrix.
* `[in] src`: The address of input matrix.
* `[in] n2`: Tiling input iteration 2.
* `[in] s2`: Tiling input stride 2.
* `[in] n1`: Tiling input iteration 1.
* `[in] s1`: Tiling input stride 1.
* `[in] n7`: Tiling output iteration 7.
* `[in] s7`: Tiling output stride 7.
* `[in] n6`: Tiling output iteration 6.
* `[in] s6`: Tiling output stride 6.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* \(<n1> \times <n2> = <n6> \times <n7> = 8\);
* `<n1>`, `<n2>`, `<n6>` and `<n7>` must be an immediate integer on `(m)tp\_2xx`;
* `<s1>`, `<s2>`, `<s6>` and `<s7>` must be greater than or equal to zero;
* Unit of `<s1>`, `<s2>`, `<s6>`, `<s7>` is 64 bytes;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.14. \_\_bang\_tiling\_2d\_b8
----------------------------------




void `__bang_tiling_2d_b8`(void \**dst*, *const* void \**src*, unsigned int *n2*, unsigned int *s2*, unsigned int *n1*, unsigned int *s1*, unsigned int *n7*, unsigned int *s7*, unsigned int *n6*, unsigned int *s6*)  

Applies 2D tiling operation on `<src>` for matrix transpose and stores the matrix to the `<dst>`.


As shown in Figure The Process of 2 Dimensional Tiling Function , the cells with blue background indicate 64 bytes of data to be copied in each segment, and red blocks indicate basic element unit. In this case, there are 4 segments in the first dimension. `<s1>` of data in each segment are copied to destination area `<n1>` times. There are 4 segments in the second dimension. `<s2>` of data in each segment are copied to destination area `<n2>` times. Then, calculate matrix transpose based on 8-bit as one element and store the matrix into corresponding segments and dimensions of `<dst>`.



![../_images/tiling2d.png](../_images/tiling2d.png)

Fig. 3.17 The Process of 2 Dimensional Tiling Function












**Parameters*** `[out] dst`: The address of output matrix.
* `[in] src`: The address of input matrix.
* `[in] n2`: Tiling input iteration 2.
* `[in] s2`: Tiling input stride 2.
* `[in] n1`: Tiling input iteration 1.
* `[in] s1`: Tiling input stride 1.
* `[in] n7`: Tiling output iteration 7.
* `[in] s7`: Tiling output stride 7.
* `[in] n6`: Tiling output iteration 6.
* `[in] s6`: Tiling output stride 6.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* \(<n1> \times <n2> = <n6> \times <n7> = 64\);
* `<n1>`, `<n2>`, `<n6>` and `<n7>` must be an immediate integer on `(m)tp\_2xx`;
* `<s1>`, `<s2>`, `<s6>` and `<s7>` must be greater than or equal to zero;
* Unit of `<s1>`, `<s2>`, `<s6>`, `<s7>` is 64 bytes;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.15. \_\_bang\_tiling\_3d\_b1024
-------------------------------------




void `__bang_tiling_3d_b1024`(void \**dst*, *const* void \**src*, unsigned int *n5*, unsigned int *s5*, unsigned int *n4*, unsigned int *s4*, unsigned int *n3*, unsigned int *s3*, unsigned int *n10*, unsigned int *s10*, unsigned int *n9*, unsigned int *s9*, unsigned int *n8*, unsigned int *s8*, unsigned int *op*)  

Copies data from `<src>` to `<dst>` in 3 dimensions.


As shown in Figure The Process of 3 Dimensional Tiling Function ,the cells with blue background indicate `<op>` of data to be copied in each segment. In this case, there are 3 segments in the first dimension. `<s3>` of data in each segment are copied to destination area `<n3>` times. There are 2 segments in the second dimension. `<s4>` of data in each segment are copied to destination area `<n4>` times. And there are 2 segments in the third dimension. `<s5>` of data in each segment are copied to destination area `<n5>` times. Then, copy the data into corresponding segments and dimensions of `<dst>`.



![../_images/3d_tiling.png](../_images/3d_tiling.png)

Fig. 3.18 The Process of 3 Dimensional Tiling Function












**Parameters*** `[out] dst`: The address of output tensor.
* `[in] src`: The address of input tensor.
* `[in] n5`: Tiling input outer iteration 5.
* `[in] s5`: Tiling input outer stride 5.
* `[in] n4`: Tiling input outer iteration 4.
* `[in] s4`: Tiling input outer stride 4.
* `[in] n3`: Tiling input outer iteration 3.
* `[in] s3`: Tiling input outer stride 3.
* `[in] n10`: Tiling output outer iteration 10.
* `[in] s10`: Tiling output outer stride 10.
* `[in] n9`: Tiling output outer iteration 9.
* `[in] s9`: Tiling output outer stride 9.
* `[in] n8`: Tiling output outer iteration 8.
* `[in] s8`: Tiling output outer stride 8.
* `[in] op`: The number of tiling unit (128 bytes).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<op>` must be an immediate integer;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* Unit of `<s3>`, `<s4>`, `<s5>`, `<s8>`, `<s9>` and `<s10>` is 64 bytes;
* `<s3>`, `<s4>`, `<s5>`, `<s8>`, `<s9>` and `<s10>` must be greater than or equal to zero;
* \(<n3> \times <n4> \times <n5> == <n8> \times <n9> \times <n10>\);
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.27.16. \_\_bang\_transpose
-----------------------------




void `__bang_transpose`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(half \**dst*, *const* half \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(short \**dst*, *const* short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(char \**dst*, *const* char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(float \**dst*, *const* float \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(int \**dst*, *const* int \**src*, unsigned int *height*, unsigned int *width*)  




void `__bang_transpose`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *height*, unsigned int *width*)  

Transposes operand `src[height][width]`, a matrix, to `dst[width][height]`.



**Parameters*** `[out] dst`: The address of destination matrix, and the matrix has WH data layout.
* `[in] src`: The address of source matrix, and the matrix has HW data layout.
* `[in] height`: The height of `<src>`.
* `[in] width`: The width of `<src>`.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<height> \* sizeof(type)` and `<width> \* sizeof(type)` must be divisible by 64 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* `<height>` and `<width>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
 #include <bang.h>

 #define WIDTH 128
 #define HEIGHT 64
 #define LEN (HEIGHT \* WIDTH)

 \_\_mlu\_entry\_\_ void kernel(short\* dst, short\* src) {
   \_\_nram\_\_ short ny[LEN];
   \_\_nram\_\_ short nx[LEN];
  \_\_memcpy(nx, src, LEN \* sizeof(short), GDRAM2NRAM);
  \_\_bang\_transpose(ny, nx, HEIGHT, WIDTH);
  \_\_memcpy(dst, ny, LEN \* sizeof(short), NRAM2GDRAM);
}

```

















3.28. Vector Operation Functions
=================================



3.28.1. \_\_bang\_abs
----------------------




void `__bang_abs`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_abs`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_abs`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  




void `__bang_abs`(char \**dst*, *const* char \**src*, unsigned int *elem\_count*)  




void `__bang_abs`(short \**dst*, *const* short \**src*, unsigned int *elem\_count*)  




void `__bang_abs`(int \**dst*, *const* int \**src*, unsigned int *elem\_count*)  

This function computes the absolute value of `<src>` element-wisely and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char`are not supported on `tp\_520`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count>` must be greater than zero;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** None.













3.28.2. \_\_bang\_add
----------------------




void `__bang_add`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_add`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_add`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_add`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_add`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs addition operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `float` is the supported on `(m)tp\_2xx` or higher;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float b\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_add(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.28.3. \_\_bang\_add\_scalar
------------------------------




void `__bang_add_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_add_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_add_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_add_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_add_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_add_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function adds `<value>` to `<elem\_count>` elements of `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_add\_scalar(c\_tmp, a\_tmp, b, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.28.4. \_\_bang\_add\_tz
--------------------------




void `__bang_add_tz`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_add_tz`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_add_tz`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs addition operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float b\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_add\_tz(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.28.5. \_\_bang\_adds
-----------------------




void `__bang_adds`(unsigned char \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_adds`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_adds`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_adds`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_adds`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_adds`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  

This function performs saturated addition operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372` and `tp\_520`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.6. \_\_bang\_adds\_scalar
-------------------------------




void `__bang_adds_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_adds_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_adds_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  

This function adds `<value>` to `<elem\_count>` elements of `<src>` and saves the saturated result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.7. \_\_bang\_count
------------------------




unsigned int `__bang_count`(*const* half \**src*, unsigned int *elem\_count*)  




unsigned int `__bang_count`(*const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




unsigned int `__bang_count`(*const* float \**src*, unsigned int *elem\_count*)  

Counts the number of non-zero elements in the input vector.



**Parameters*** `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `unsigned int` The number of non-zero elements in the input vector.






**Remark*** `<elem\_count>` must be greater than zero;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(float\* src, unsigned int elem\_count) {
  unsigned int counter = \_\_bang\_count(src, elem\_count);
}

```













3.28.8. \_\_bang\_count\_bitindex
----------------------------------




unsigned int `__bang_count_bitindex`(*const* half \**src*, unsigned int *elem\_count*)  




unsigned int `__bang_count_bitindex`(*const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




unsigned int `__bang_count_bitindex`(*const* float \**src*, unsigned int *elem\_count*)  

Counts the number of non-zero bit in the input vector.



**Parameters*** `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `unsigned int` The number of non-zero bit in the input vector.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src>`must point to `\_\_nram\_\_` address space;
* The address of `<src>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(float\* src, unsigned int elem\_count) {
  unsigned int counter = \_\_bang\_count\_bitindex(src, elem\_count);
}

```













3.28.9. \_\_bang\_cycle\_add
-----------------------------




void `__bang_cycle_add`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_add`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_add`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_add`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_add`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_add`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

This function divides `<src>` into N parts ( `N = <src\_elem\_count> / <seg\_elem\_count>` ), adds each element in each part of `<src>` and the corresponding element in `<seg>`, and assigns the result to `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









![../_images/11.7.png](../_images/11.7.png)

Fig. 3.19 Description of `\_\_bang\_cycle\_add`











**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short` and `char`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define N1 256
#define N2 65280

\_\_mlu\_entry\_\_ void kernel(half\* c, half\* a, half\* b) {
  \_\_nram\_\_ half a\_tmp[N1];
  \_\_nram\_\_ half b\_tmp[N2];
  \_\_nram\_\_ half c\_tmp[N2];
  \_\_memcpy(a\_tmp, a, N1 \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, N2 \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_cycle\_add(c\_tmp, b\_tmp, a\_tmp, N2, N1);
  \_\_memcpy(c, c\_tmp, N2 \* sizeof(half), NRAM2GDRAM);
}

```













3.28.10. \_\_bang\_cycle\_add\_tz
----------------------------------




void `__bang_cycle_add_tz`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_add_tz`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_add_tz`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Adds two input vectors segment by segment in round-to-zero mode. This function is calculated in the same way as ::\_\_bang\_cycle\_add function. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define N1 256
#define N2 65280

\_\_mlu\_entry\_\_ void kernel(half\* c, half\* a, half\* b) {
  \_\_nram\_\_ half a\_tmp[N1];
  \_\_nram\_\_ half b\_tmp[N2];
  \_\_nram\_\_ half c\_tmp[N2];
  \_\_memcpy(a\_tmp, a, N1 \* sizeof(half), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, N2 \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_cycle\_add\_tz(c\_tmp, b\_tmp, a\_tmp, N2, N1);
  \_\_memcpy(c, c\_tmp, N2 \* sizeof(half), NRAM2GDRAM);
}

```













3.28.11. \_\_bang\_cycle\_adds
-------------------------------




void `__bang_cycle_adds`(unsigned int \**dst*, *const* unsigned int \**src*, *const* unsigned int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_adds`(unsigned short \**dst*, *const* unsigned short \**src*, *const* unsigned short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_adds`(unsigned char \**dst*, *const* unsigned char \**src*, *const* unsigned char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_adds`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_adds`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_adds`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

This function divides `<src>` into N parts ( `N = <src\_elem\_count> / <seg\_elem\_count>` ), adds each element in each part of `<src>` and the corresponding element in `<seg>`, and assigns the saturated result to `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.12. \_\_bang\_cycle\_mul
------------------------------




void `__bang_cycle_mul`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mul`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mul`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mul`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mul`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mul`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

This function divides `<src>` into N parts ( `N = <src\_elem\_count> / <seg\_elem\_count>` ), multiplies each element in each part of `<src>` and the corresponding element in `<seg>`, and assigns the result to `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short` and `char`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.28.13. \_\_bang\_cycle\_mulh
-------------------------------




void `__bang_cycle_mulh`(unsigned int \**dst*, *const* unsigned int \**src*, *const* unsigned int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mulh`(unsigned short \**dst*, *const* unsigned short \**src*, *const* unsigned short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mulh`(unsigned char \**dst*, *const* unsigned char \**src*, *const* unsigned char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mulh`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mulh`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_mulh`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

This function divides `<src>` into N parts ( `N = <src\_elem\_count> / <seg\_elem\_count>` ), multiplies each element in each part of `<src>` and the corresponding element in `<seg>`, and assigns the upper half of result to `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.14. \_\_bang\_cycle\_muls
-------------------------------




void `__bang_cycle_muls`(unsigned short \**dst*, *const* unsigned char \**src*, *const* unsigned char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_muls`(unsigned int \**dst*, *const* unsigned short \**src*, *const* unsigned short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_muls`(int \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_muls`(short \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

This function divides `<src>` into N parts ( `N = <src\_elem\_count> / <seg\_elem\_count>` ), multiplies each element in each part of `<src>` and the corresponding element in `<seg>`, and assigns the result to `<dst>`. The size of `<dst>` is twice as long as that of `<src>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<seg\_elem\_count> \* sizeof(source type)` cannot be greater than 65536 on `tp\_322`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.15. \_\_bang\_cycle\_sub
------------------------------




void `__bang_cycle_sub`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_sub`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_sub`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_sub`(half \**dst*, *const* half \**src*, *const* half \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_sub`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_sub`(float \**dst*, *const* float \**src*, *const* float \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

This function divides `<src>` into N parts ( `N = <src\_elem\_count> / <seg\_elem\_count>` ), subtracts each element in each part of `<src>` and the corresponding element in `<seg>`, and assigns the result to `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src\_elem\_count> \* sizeof(type)` and `<seg\_elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322` when vector type is `int`, `short` and `char`;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<seg>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.28.16. \_\_bang\_cycle\_subs
-------------------------------




void `__bang_cycle_subs`(unsigned int \**dst*, *const* unsigned int \**src*, *const* unsigned int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_subs`(unsigned short \**dst*, *const* unsigned short \**src*, *const* unsigned short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_subs`(unsigned char \**dst*, *const* unsigned char \**src*, *const* unsigned char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_subs`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_subs`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_subs`(char \**dst*, *const* char \**src*, *const* char \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

This function divides `<src>` into N parts ( `N = <src\_elem\_count> / <seg\_elem\_count>` ), subtracts each element in each part of `<src>` and the corresponding element in `<seg>`, and assigns the saturated result to `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.17. \_\_bang\_findfirst1
------------------------------




unsigned int `__bang_findfirst1`(*const* half \**src*, unsigned int *elem\_count*)  




unsigned int `__bang_findfirst1`(*const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




unsigned int `__bang_findfirst1`(*const* float \**src*, unsigned int *elem\_count*)  

Finds the first non-zero data in the values of `<src>`, and returns the index of the first non-zero data. If `<src>` is all zero, returns 0xffff-ffff.



**Parameters*** `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `unsigned int`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof (type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(half\* a) {
  \_\_nram\_\_ half a\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  unsigned int num = \_\_bang\_findfirst1(a\_tmp, DATA\_SIZE);
}

```













3.28.18. \_\_bang\_findlast1
-----------------------------




unsigned int `__bang_findlast1`(*const* half \**src*, unsigned int *elem\_count*)  




unsigned int `__bang_findlast1`(*const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




unsigned int `__bang_findlast1`(*const* float \**src*, unsigned int *elem\_count*)  

Finds the last non-zero data in the values of `<src>`, and returns the index of the last non-zero data. If `<src>` is all zero, returns 0xffff-ffff.



**Parameters*** `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `unsigned int`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof (type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` must be 64-byte aligned on `(m)tp\_2xx`;






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.28.19. \_\_bang\_floor
-------------------------




void `__bang_floor`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function performs floor operation element-wisely on `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.20. \_\_bang\_histogram
-----------------------------




void `__bang_histogram`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *size*)  




void `__bang_histogram`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *size*)  




void `__bang_histogram`(int16\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *size*)  




void `__bang_histogram`(int32\_t \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *size*)  




void `__bang_histogram`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *size*)  




void `__bang_histogram`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *size*)  




void `__bang_histogram`(int16\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *size*)  




void `__bang_histogram`(int32\_t \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *size*)  




void `__bang_histogram`(float \**dst*, *const* half \**src*, *const* half \**kernel*, unsigned int *size*)  




void `__bang_histogram`(float \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**kernel*, unsigned int *size*)  

Generates a histogram of `<src>` according to kernel. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information;
The data layout of `<kernel>` is 64 rows. Every row is 64 bytes, and the value of each row is corresponding to the histogram of x-axis. There are 32 values in each row when data type is `int16\_t`, `half` or `bfloat16\_t`, and 64 values when data type is `int8\_t`.









**Parameters*** `[out] dst`: The address of destination vector
* `[in] src`: The address of source vector
* `[in] kernel`: The address of kernel vector
* `[in] size`: The elements number of source vector



**Return*** `void`.






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<kernel>` must point to `\_\_wram\_\_` address space;
* The address of `<dst>` and `<src>` must be 64-byte aligned;
* The address of `<kernel>` must be 32-byte aligned;
* `<size> \* sizeof(typeof<src>)` must be 64-byte aligned on `(m)tp\_2xx`;
* The element number of `<dst>` is 64;
* `<size>` must be greater than 0;
* `<dst>` cannot be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 220` except 270 and 290;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20` except `(m)tp\_270` and `mtp\_290`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_220` except `(m)tp\_270`.






**Compatibility between Various Architectures**



Table 3.60 Histogram Data Types Supported on `(m)tp\_220`




| Src Type | Kernel Type | Dst Type |
| --- | --- | --- |
| int8\_t | int8\_t | int16\_t |
| int8\_t | int8\_t | int32\_t |
| int8\_t | int8\_t | half |
| int8\_t | int8\_t | float |
| int16\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | int32\_t |
| int16\_t | int16\_t | half |
| int16\_t | int16\_t | float |




Table 3.61 Histogram Data Types Supported on `mtp\_372`




| Src Type | Kernel Type | Dst Type |
| --- | --- | --- |
| int8\_t | int8\_t | half |
| int8\_t | int8\_t | float |
| int8\_t | int8\_t | int16\_t |
| int8\_t | int8\_t | int32\_t |
| int16\_t | int16\_t | half |
| int16\_t | int16\_t | float |
| int16\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | int32\_t |
| half | half | float |
| bfloat16\_t | bfloat16\_t | float |




Table 3.62 Histogram Data Types Supported on `tp\_322` and `tp\_520`




| Src Type | Kernel Type | Dst Type |
| --- | --- | --- |
| int8\_t | int8\_t | half |
| int8\_t | int8\_t | float |
| int8\_t | int8\_t | int16\_t |
| int8\_t | int8\_t | int32\_t |
| int16\_t | int16\_t | half |
| int16\_t | int16\_t | float |
| int16\_t | int16\_t | int16\_t |
| int16\_t | int16\_t | int32\_t |




Table 3.63 Histogram Data Types Supported on `(m)tp\_59x`




| Src Type | Kernel Type | Dst Type |
| --- | --- | --- |
| int8\_t | int8\_t | half |
| int8\_t | int8\_t | float |
| int8\_t | int8\_t | int16\_t |
| int8\_t | int8\_t | int32\_t |
| half | half | float |
| bfloat16\_t | bfloat16\_t | float |









**Example**

For example, `<src>` is `[0, 1, 2, 3, 0, 1, 2, 3, 3]` and data type of `<src>` is `int16\_t`. If all numbers in kernels first line are 1, all numbers in kernels second line are 3, all numbers in kernels third line are 9, data type of `<kernel>` is `int16\_t`. For `<dst>`, `dst[0]` is 2, which is equal to how many number 1(data of first line of kernel) in the `<src>`.`dst[2]` is 0, because there is no number 9(data of third line of kernel) in`<src>`. So `<dst>` is `[2, 3, 0, 0, 0, ...]` and the number of elements of `<dst>` is 64 and data type of `<dst>` is `int32\_t`.




```
#include <bang.h>

#define SRC\_NUM 512
#define DST\_NUM 64
#define KERNEL\_NUM (64 \* (64 / sizeof(int16\_t)))
#define KERNEL\_COLUMN (64 / sizeof(int16\_t))

\_\_mlu\_entry\_\_ void kernel(int32\_t\* dst, int16\_t\* src, int16\_t\* kernel, int size) {
  \_\_nram\_\_ int32\_t dst\_tmp[DST\_NUM];
  \_\_nram\_\_ int16\_t src\_tmp[SRC\_NUM];
  \_\_wram\_\_ int16\_t kernel\_tmp[KERNEL\_NUM];
  \_\_memcpy(src\_tmp, src, SRC\_NUM \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_memcpy(kernel\_tmp, kernel, KERNEL\_NUM \* sizeof(int16\_t), GDRAM2WRAM);
  \_\_bang\_write\_zero((half\*)dst\_tmp, DST\_NUM \* 2);
  \_\_bang\_histogram(dst\_tmp, src\_tmp, kernel\_tmp, size);
  \_\_memcpy(dst, dst\_tmp, DST\_NUM \* sizeof(int32\_t), NRAM2GDRAM);
}

int main() {
  ...
  for (int i = 0; i < 64; i++) {
    cpu\_kernel[i][0] = ...;  // value of cpu\_kernel[i][0] can calculate how many cpu\_kernel[i][0] in the src
    for (int j = 1; j < KERNEL\_COLUMN; j++) {
      cpu\_kernel[i][j] = cpu\_kernel[i][j-1];
    }
  }
  ...
  int16\_t\* mlu\_kernel;
  CNRT\_CHECK(cnrtMalloc((void \*\*)&mlu\_kernel, KERNEL\_NUM \* sizeof(int16\_t)));
  CNRT\_CHECK(cnrtMemcpy(mlu\_kernel, cpu\_kernel, KERNEL\_NUM \* sizeof(int16\_t), CNRT\_MEM\_TRANS\_DIR\_HOST2DEV));
  kernel<<<dim, func\_type, pQueue>>>(mlu\_dst, mlu\_src, mlu\_kernel, SRC\_NUM);
  ...
}

```













3.28.21. \_\_bang\_integral
----------------------------




void `__bang_integral`(int \**dst*, *const* short \**src*, *const* short \**kernel*, unsigned int *size*)  




void `__bang_integral`(short \**dst*, *const* short \**src*, *const* short \**kernel*, unsigned int *size*)  




void `__bang_integral`(half \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *size*, int *fix\_position*)  




void `__bang_integral`(float \**dst*, *const* int16\_t \**src*, *const* int16\_t \**kernel*, unsigned int *size*, int *fix\_position*)  




void `__bang_integral`(int \**dst*, *const* char \**src*, *const* char \**kernel*, unsigned int *size*)  




void `__bang_integral`(short \**dst*, *const* char \**src*, *const* char \**kernel*, unsigned int *size*)  




void `__bang_integral`(half \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *size*, int *fix\_position*)  




void `__bang_integral`(float \**dst*, *const* int8\_t \**src*, *const* int8\_t \**kernel*, unsigned int *size*, int *fix\_position*)  




void `__bang_integral`(float \**dst*, *const* float \**src*, *const* float \**kernel*, unsigned int *size*)  




void `__bang_integral`(float \**dst*, *const* bfloat16\_t \**src*, *const* bfloat16\_t \**kernel*, unsigned int *size*)  




void `__bang_integral`(float \**dst*, *const* half \**src*, *const* half \**kernel*, unsigned int *size*)  

Generates integral of the input vector `<src>` according to `<kernel>`. When the value of Lower Triangular Matrix(LTM) of `<kernel>` are 1 and the other values are 0, it is equivalent to the prefix sum of the input vector `<src>`;
Generally, the value of elements in the LTM of `<kernel>` should be `1`, so `<dst>[n]` is the sum of `<src>[0]` to `<src>[n]`. More details can be found in the example.






**Parameters*** `[out] dst`: The address of destination vector
* `[in] src`: The address of source vector
* `[in] kernel`: The address of kernel vector
* `[in] size`: The elements number of source vector
* `[in] fix\_position`: Sum of scale factor of `<src>` and `<kernel>`.



**Return*** `void`.






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<kernel>` must point to `\_\_wram\_\_` address space;
* The address of `<dst>` and `<src>` must be 64-byte aligned;
* The address of `<kernel>` must be 32-byte aligned;
* `<size> \* sizeof(typeof<src>)` must be 64-byte aligned;
* `<size> \* sizeof(typeof<src>)` cannot be greater than `65472`;
* `<dst>` cannot be overlapped with `<src>`;
* When data type of `<src>` is `int8\_t` or `char`, `<kernel>` should be \(64 \times 64\) Lower Triangular Matrix(LTM); when data type of `<src>` is `int16\_t`, `short` or `half`, `<kernel>` should be \(32 \times 32\) LTM; when datatype of `<src>` is `float`, `<kernel>` should be \(16 \times 16\) LTM; `kernel` always requires 4096 bytes of memory, LTM should be placed at the beginning of the memory;
* `<fix\_position>` must be in the range `[-127, 127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Compatibility between Various Architectures**



Table 3.64 Integral Data Types Supported on `mtp\_372`




| Src Type | Kernel Type | Dst Type |
| --- | --- | --- |
| int8\_t | int8\_t | int16\_t |
| int8\_t | int8\_t | float |
| int8\_t | int8\_t | half |
| int16\_t | int16\_t | float |
| int16\_t | int16\_t | half |
| short | short | int |
| short | short | short |
| char | char | int |
| char | char | short |
| float | float | float |
| half | half | float |
| bfloat16\_t | bfloat16\_t | float |




Table 3.65 Integral Data Types Supported on `tp\_322` and tp\_520``




| Src Type | Kernel Type | Dst Type |
| --- | --- | --- |
| int8\_t | int8\_t | int16\_t |
| int8\_t | int8\_t | float |
| int8\_t | int8\_t | half |
| int16\_t | int16\_t | float |
| int16\_t | int16\_t | half |
| short | short | int |
| short | short | short |
| char | char | int |
| char | char | short |




Table 3.66 Integral Data Types Supported on `(m)tp\_59x`




| Src Type | Kernel Type | Dst Type |
| --- | --- | --- |
| int8\_t | int8\_t | float |
| int8\_t | int8\_t | half |
| char | char | int |
| char | char | short |
| float | float | float |
| half | half | float |
| bfloat16\_t | bfloat16\_t | float |









**Example**

When Lower Triangular Matrix of `<kernel>` value to `k` and the other value to `0`. `<dst>[n]` is k times the sum of `<src>[0]` to `<src>[n]`; If `k` is 1, `<size>` is 64, `<src>` is `[1, 1, ... , 1, 1]` and data type of `<src>` is `short`, `<dst>` should be `[1, 2, 3, ..., 63, 64]` and data type of `<dst>` is `int`; If `k` is 2, `<size>` is 64, `<src>` is `[1, 1, ... , 1, 1]` and data type of `<src>` is `short`, `<dst>` should be `[2, 4, 6, ... 126, 128]` and data type of `<dst>` is `int`.




```
#include <bang.h>

#define DATA\_NUM 64
#define KERNEL\_NUM (4096 / sizeof(short))
#define KERNEL\_SIDE\_LENGTH (64 / sizeof(short))

\_\_mlu\_entry\_\_ void kernel(int\* dst, short\* src, short\* kernel, int size) {
  \_\_nram\_\_ int dst\_tmp[DATA\_NUM];
  \_\_nram\_\_ short src\_tmp[DATA\_NUM];
  \_\_wram\_\_ short kernel\_tmp[KERNEL\_NUM];
  \_\_memcpy(src\_tmp, src, DATA\_NUM \* sizeof(short), GDRAM2NRAM);
  \_\_memcpy(kernel\_tmp, kernel, KERNEL\_NUM \* sizeof(short), GDRAM2WRAM);
  \_\_bang\_integral(dst\_tmp, src\_tmp, kernel\_tmp, size);
  \_\_memcpy(dst, dst\_tmp, DATA\_NUM \* sizeof(int), NRAM2GDRAM);
}

int main() {
  ...
// detailed layout, value of LTM of kernel is 1 and the other is 0
  short cpu\_kernel[KERNEL\_SIDE\_LENGTH][KERNEL\_SIDE\_LENGTH];
  for (int i = 0; i < KERNEL\_SIDE\_LENGTH; i++) {
    for (int j = 0; j < KERNEL\_SIDE\_LENGTH; j++) {
      if( i >= j ) cpu\_kernel[i][j] = 1;
      else cpu\_kernel[i][j] = 0;
    }
  }
  ...
  short \*mlu\_kernel;
  CNRT\_CHECK(cnrtMalloc((void \*\*)&mlu\_kernel, KERNEL\_NUM \* sizeof(short)));
  CNRT\_CHECK(cnrtMemcpy(mlu\_kernel, cpu\_kernel, KERNEL\_NUM \* sizeof(short), CNRT\_MEM\_TRANS\_DIR\_HOST2DEV));
  kernel<<<dim, func\_type, pQueue>>>(mlu\_dst, mlu\_src, mlu\_kernel, DATA\_NUM);
  ...
}

```













3.28.22. \_\_bang\_lut
-----------------------




void `__bang_lut`(int32\_t \**dst*, *const* uint32\_t \**index*, *const* int32\_t \**table*, unsigned int *elem\_count*, unsigned int *table\_length*)  




void `__bang_lut`(int32\_t \**dst*, *const* uint16\_t \**index*, *const* int32\_t \**table*, unsigned int *elem\_count*, unsigned int *table\_length*)  




void `__bang_lut`(int32\_t \**dst*, *const* uint8\_t \**index*, *const* int32\_t \**table*, unsigned int *elem\_count*, unsigned int *table\_length*)  




void `__bang_lut`(int16\_t \**dst*, *const* uint16\_t \**index*, *const* int16\_t \**table*, unsigned int *elem\_count*, unsigned int *table\_length*)  




void `__bang_lut`(int16\_t \**dst*, *const* uint8\_t \**index*, *const* int16\_t \**table*, unsigned int *elem\_count*, unsigned int *table\_length*)  

Applies lookup-table operation on `<index>`, value in `<dst>` remains unchanged if the corresponding value in `<index>` is greater than or equal to `<table\_length>`.




Table 3.67 Data Types Supported on `(m)tp\_220`, `tp\_322`, `mtp\_372` and `mtp\_592`





| Index Type | Table Type | Dst Type | table\_length |
| --- | --- | --- | --- |
| uint16\_t | int16\_t | int16\_t | 64 aligned |
| uint32\_t | int32\_t | int32\_t | 64 aligned |




Table 3.68 Data Types Supported on `tp\_520`





| Index Type | Table Type | Dst Type | table\_length |
| --- | --- | --- | --- |
| uint16\_t | int16\_t | int16\_t | 64 aligned |
| uint32\_t | int32\_t | int32\_t | 64 aligned |
| uint8\_t | int16\_t | int16\_t | 128 aligned |
| uint8\_t | int32\_t | int32\_t | 128 aligned |
| uint16\_t | int32\_t | int32\_t | 128 aligned |






**Parameters*** `[out] dst`: The address of destination vector.
* `[in] index`: The address of index vector.
* `[in] table`: The address of table vector.
* `[in] elem\_count`: Number of elements in index vector.
* `[in] table\_length`: Number of elements in table vector.



**Return*** `void`.






**Remark*** `<index>`, `<table>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<index>`, `<table>` and `<dst>` must be 64-byte aligned on `(m)tp\_220`;
* `<elem\_count>` and `<table\_length>` must be greater than zero;
* `<elem\_count>` must be divisible by 64 on `(m)tp\_220`;
* `<dst>`, `<table>` and `<index>` cannot be overlapped.











**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 220` except 270 and 290;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20` except `(m)tp\_270` and `mtp\_290`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_220` except `(m)tp\_270` and `mtp\_290`.






**Example**
```
  #include <bang.h>

\_\_mlu\_entry\_\_ void kernel() {
  \_\_nram\_\_ int dst[128] = {0,0,0,0,0,100,100};
  \_\_nram\_\_ int idx[128] = {0,1,2,3,4,5,2277};
  \_\_nram\_\_ int tbl[128] = {5,4,3,2,1};
  \_\_bang\_lut(dst, idx, tbl, 8, 64);
  // output: 5,4,3,2,1,0,100,5
  printf("%d,%d,%d,%d,%d,%d,%d,%d\n",
         dst[0], dst[1], dst[2], dst[3],
         dst[4], dst[5], dst[6], dst[7]);
}

```













3.28.23. \_\_bang\_lut\_s16
----------------------------




void `__bang_lut_s16`(int16\_t \**dst*, *const* int16\_t \**index*, *const* int16\_t \**table*, unsigned int *elem\_count*, unsigned int *table\_length*)  

Applies lookup-table operation on `<index>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] index`: The address of index vector.
* `[in] table`: The address of table vector.
* `[in] elem\_count`: Number of elements in index vector.
* `[in] table\_length`: Number of elements in table vector.



**Return*** `void`.






**Remark*** `<index>`, `<table>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<index>`, `<table>` and `<dst>` must be 64-byte aligned on `(m)tp\_220`;
* The data type of `<dst>` and `<table>` can be any type with the same size as that of `<src>`;
* `<elem\_count>` and `<table\_length>` must be greater than zero;
* `<elem\_count>` must be divisible by 64 on `(m)tp\_220`;
* `<dst>`, `<table>` and `<index>` cannot be overlapped;
* `<table\_length>` must be divisible by 64.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 220` except 270 and 290;
* CNCC Version: `cncc --version >= 3.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20` except `(m)tp\_270` and `mtp\_290`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_220` except `(m)tp\_270` and `mtp\_290`.






**Example*** None.













3.28.24. \_\_bang\_lut\_s32
----------------------------




void `__bang_lut_s32`(int \**dst*, *const* int \**index*, *const* int \**table*, unsigned int *elem\_count*, unsigned int *table\_length*)  

Applies lookup-table operation on `<index>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] index`: The address of index vector.
* `[in] table`: The address of table vector.
* `[in] elem\_count`: Number of elements in index vector.
* `[in] table\_length`: Number of elements in table vector.



**Return*** `void`.






**Remark*** `<index>`, `<table>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<index>`, `<table>` and `<dst>` must be 64-byte aligned on `(m)tp\_220`;
* The data type of `<dst>` and `<table>` can be any type with the same size as that of `<src>`;
* `<elem\_count>` and `<table\_length>` must be greater than zero;
* `<elem\_count>` must be divisible by 64 on `(m)tp\_220`;
* `<dst>`, `<table>` and `<index>` cannot be overlapped;
* `<table\_length>` must be divisible by 64.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 220` except 270 and 290;
* CNCC Version: `cncc --version >= 3.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20` except `(m)tp\_270` and `mtp\_290`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_220` except `(m)tp\_270` and `mtp\_290`.






**Example*** None.













3.28.25. \_\_bang\_mul
-----------------------




void `__bang_mul`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_mul`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_mul`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_mul`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_mul`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_mul`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs multiplication operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_add for more details.













3.28.26. \_\_bang\_mul\_scalar
-------------------------------




void `__bang_mul_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_mul_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_mul_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_mul_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_mul_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_mul_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function multiplies `<elem\_count>` elements of `<src>` by `<value>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_add\_scalar for more details.













3.28.27. \_\_bang\_mulh
------------------------




void `__bang_mulh`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_mulh`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_mulh`(unsigned char \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_mulh`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_mulh`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_mulh`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  

This function performs multiplication operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`. Only upper half of each result is stored in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.28. \_\_bang\_mulh\_scalar
--------------------------------




void `__bang_mulh_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_mulh_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_mulh_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  

This function multiplies `<value>` by `<elem\_count>` elements of `<src>` and saves the result in `<dst>`. Only the upper half of each result is stored in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.29. \_\_bang\_muls
------------------------




void `__bang_muls`(unsigned short \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_muls`(unsigned int \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_muls`(short \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_muls`(int \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  

This function performs multiplication operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`. The size of `<dst>` is twice as long as that of `<src0>` and `<src1>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.30. \_\_bang\_muls\_scalar
--------------------------------




void `__bang_muls_scalar`(unsigned short \**dst*, *const* unsigned char \**src*, unsigned char *value*, unsigned int *elem\_count*)  




void `__bang_muls_scalar`(unsigned int \**dst*, *const* unsigned short \**src*, unsigned short *value*, unsigned int *elem\_count*)  




void `__bang_muls_scalar`(short \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_muls_scalar`(int \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  

This function multiplies `<value>` by `<elem\_count>` elements of `<src>` and saves the result in `<dst>`. The size of `<dst>` is twice as long as that of `<src>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.31. \_\_bang\_nearbyint
-----------------------------




void `__bang_nearbyint`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function performs round operation element-wisely on `<src>` in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.32. \_\_bang\_neg
-----------------------




void `__bang_neg`(char \**dst*, *const* char \**src*, unsigned int *elem\_count*)  




void `__bang_neg`(short \**dst*, *const* short \**src*, unsigned int *elem\_count*)  




void `__bang_neg`(int \**dst*, *const* int \**src*, unsigned int *elem\_count*)  

This function computes the opposite value of `<src>` element-wisely and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.33. \_\_bang\_nsa
-----------------------




void `__bang_nsa`(char \**dst*, *const* char \**src*, unsigned int *elem\_count*)  




void `__bang_nsa`(short \**dst*, *const* short \**src*, unsigned int *elem\_count*)  




void `__bang_nsa`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *elem\_count*)  




void `__bang_nsa`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *elem\_count*)  




void `__bang_nsa`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *elem\_count*)  




void `__bang_nsa`(int \**dst*, *const* int \**src*, unsigned int *elem\_count*)  

This function counts the leading zeros or ones in `<src>` element-wisely and saves the result in `<dst>`. A leading zero is any digit that comes before the first nonzero digit in binary without the signed bit. If the value of element in `<src>` is a signed positive number, the result is the number of leading zeros minus one; if it is a negative number, the result is the number of leading ones minus one; if it is an unsigned number, the result is the number of leading zeros.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.34. \_\_bang\_popcnt
--------------------------




int `__bang_popcnt`(*const* unsigned int \**src*, unsigned int *elem\_count*)  




int `__bang_popcnt`(*const* unsigned short \**src*, unsigned int *elem\_count*)  




int `__bang_popcnt`(*const* unsigned char \**src*, unsigned int *elem\_count*)  

Counts the number of bits that are set to 1 in `<src>`.



**Parameters*** `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `int`.






**Remark*** `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.4.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.28.35. \_\_bang\_rand
------------------------




void `__bang_rand`(short \**dst*, unsigned int *elem\_count*)  

Generates a vector of uniformly distributed random number of short type.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements in destination vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero and divisible by 64;
* `<dst>` must point to `\_\_nram\_\_` address space;
* The address of must be 64-byte aligned on `(m)tp\_2xx`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200` except 520;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx` except `tp\_520`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(short \*output) {
  \_\_nram\_\_ short result[DATA\_SIZE];
  \_\_bang\_rand(result, DATA\_SIZE);
  \_\_memcpy(output, result, DATA\_SIZE \* sizeof(short), NRAM2GDRAM);
}

```













3.28.36. \_\_bang\_reduce\_sum
-------------------------------




void `__bang_reduce_sum`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_reduce_sum`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_reduce_sum`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Takes every 128-byte data from `<src>` to add them up and stores the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* The total number of bytes of `<dst>` is at least 128;
* `<elem\_count> \* sizeof(type)` must be divisible by 128;
* The first element of every 128 bytes in destination operand `<dst>` is the sum of every 128-byte data, the other elements in destination operand `<dst>` of every 128 bytes will be set to zero on `(m)tp\_2xx`, and they will not be changed on `(m)tp\_3xx`;
* This instruction takes every 128 bytes to calculate each time. When vector type is float, This function will take the 32 elements to calculate. When vector type is half, This function will take the 64 elements to calculate.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













3.28.37. \_\_bang\_rol
-----------------------




void `__bang_rol`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_rol`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_rol`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  

This function performs left rotation operation on `<src>` element-wisely with `<shift\_bits>` bits and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the source vector.
* `[in] shift\_bits`: The number of bits left shifted.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<shift\_bits>` must be greater than or equal to zero;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.38. \_\_bang\_ror
-----------------------




void `__bang_ror`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_ror`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_ror`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  

This function performs right rotation operation on `<src>` element-wisely with `<shift\_bits>` bits and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the source vector.
* `[in] shift\_bits`: The number of bits right shifted.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<shift\_bits>` must be greater than or equal to zero;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.39. \_\_bang\_round
-------------------------




void `__bang_round`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function performs round operation element-wisely on `<src>` in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.40. \_\_bang\_set0in32
----------------------------




void `__bang_set0in32`(void \**dst*, *const* void \**src*, int *position*, unsigned int *elem\_count*)  

Set the specified bit to 0.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] position`: The specified position to be set to 0.
* `[in] elem\_count`: Number of elements in source.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* The bit width of element in `<src>` and `<dst>` is 32 bits;
* `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.41. \_\_bang\_set1in32
----------------------------




void `__bang_set1in32`(void \**dst*, *const* void \**src*, int *position*, unsigned int *elem\_count*)  

Set the specified bit to 1.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] position`: The specified position to be set to 1.
* `[in] elem\_count`: Number of elements in source.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* The bit width of element in `<src>` and `<dst>` is 32 bits;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.42. \_\_bang\_sll
-----------------------




void `__bang_sll`(char \**dst*, *const* char \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_sll`(short \**dst*, *const* short \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_sll`(int \**dst*, *const* int \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  

This function performs logical left shift element-wisely on `<src>` with `<shift\_bits>` bits and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the first source vector.
* `[in] shift\_bits`: The number of bits left shifted.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<shift\_bits>` must be greater than or equal to zero;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.43. \_\_bang\_square
--------------------------




void `__bang_square`(unsigned short \**dst*, *const* unsigned char \**src*, unsigned int *elem\_count*)  




void `__bang_square`(unsigned int \**dst*, *const* unsigned short \**src*, unsigned int *elem\_count*)  




void `__bang_square`(short \**dst*, *const* char \**src*, unsigned int *elem\_count*)  




void `__bang_square`(int \**dst*, *const* short \**src*, unsigned int *elem\_count*)  




void `__bang_square`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_square`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_square`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Applies square activation operation on `<src>` element-wisely, and stores the result in `<dst>`. \(<dst> = <src>^2\). See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `int`, `short`, `unsigned int` and `unsigned short` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(half\* c, half\* a) {
  \_\_nram\_\_ half a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ half c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_square(c\_tmp, a\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.28.44. \_\_bang\_sra
-----------------------




void `__bang_sra`(char \**dst*, *const* char \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_sra`(short \**dst*, *const* short \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_sra`(int \**dst*, *const* int \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  

This function performs arithmetic right shift element-wisely on `<src>` with `<shift\_bits>` bits and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the first source vector.
* `[in] shift\_bits`: The number of bits right shifted.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<shift\_bits>` must be greater than or equal to zero;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.45. \_\_bang\_srl
-----------------------




void `__bang_srl`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_srl`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  




void `__bang_srl`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *shift\_bits*, unsigned int *elem\_count*)  

This function performs logical right shift element-wisely on `<src>` with `<shift\_bits>` bits and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of the first source vector.
* `[in] shift\_bits`: The number of bits right shifted.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<shift\_bits>` must be greater than or equal to zero;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example*** None.













3.28.46. \_\_bang\_sub
-----------------------




void `__bang_sub`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_sub`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_sub`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_sub`(unsigned char \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_sub`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_sub`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_sub`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  

This function performs subtraction operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_add for more details.













3.28.47. \_\_bang\_sub\_scalar
-------------------------------




void `__bang_sub_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_sub_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_sub_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  




void `__bang_sub_scalar`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_sub_scalar`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, bfloat16\_t *value*, unsigned int *elem\_count*)  




void `__bang_sub_scalar`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function subtracts `<value>` from `<elem\_count>` elements of `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero;
* `int`, `short` and `char` are supported on `(m)tp\_3xx` or higher except `tp\_520`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_add\_scalar for more details.













3.28.48. \_\_bang\_subs
------------------------




void `__bang_subs`(unsigned char \**dst*, *const* unsigned char \**src0*, *const* unsigned char \**src1*, unsigned int *elem\_count*)  




void `__bang_subs`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_subs`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_subs`(char \**dst*, *const* char \**src0*, *const* char \**src1*, unsigned int *elem\_count*)  




void `__bang_subs`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_subs`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  

This function performs saturated subtraction operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>`, `<src0>` and `<src1>` can be overlapped;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.49. \_\_bang\_subs\_scalar
--------------------------------




void `__bang_subs_scalar`(char \**dst*, *const* char \**src*, char *value*, unsigned int *elem\_count*)  




void `__bang_subs_scalar`(short \**dst*, *const* short \**src*, short *value*, unsigned int *elem\_count*)  




void `__bang_subs_scalar`(int \**dst*, *const* int \**src*, int *value*, unsigned int *elem\_count*)  

This function subtracts `<value>` from `<elem\_count>` elements of `<src>` and saves the saturated result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372 and 520;
* CNCC Version: `cncc --version >= 3.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372` and `tp\_520`.






**Example*** None.













3.28.50. \_\_bang\_sum
-----------------------




half `__bang_sum`(*const* half \**src*, unsigned int *elem\_count*)  




bfloat16\_t `__bang_sum`(*const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




float `__bang_sum`(*const* float \**src*, unsigned int *elem\_count*)  

Accumulates all data from source operand `<src>`.



**Parameters*** `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source vector.



**Return*** The result of accumulation.






**Remark*** `<src>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520` ;
* CNCC Version: `cncc --version >= 3.5.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx` .






**Example*** None.

















3.29. Vector Surpass Functions
===============================



3.29.1. \_\_bang\_cos
----------------------




void `__bang_cos`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_cos`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function computes the cosine of each element in `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example*** See the example of \_\_bang\_sin for more details.













3.29.2. \_\_bang\_div
----------------------




void `__bang_div`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, *const* bfloat16\_t \**src1*, unsigned int *elem\_count*)  




void `__bang_div`(half \**dst*, *const* half \**src0*, *const* half \**src1*, unsigned int *elem\_count*)  




void `__bang_div`(float \**dst*, *const* float \**src0*, *const* float \**src1*, unsigned int *elem\_count*)  




void `__bang_div`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_div`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_div`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_div`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_div`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src0*, bfloat16\_t *src1*, unsigned int *elem\_count*)  




void `__bang_div`(half \**dst*, *const* half \**src0*, half *src1*, unsigned int *elem\_count*)  




void `__bang_div`(float \**dst*, *const* float \**src0*, float *src1*, unsigned int *elem\_count*)  




void `__bang_div`(short \**dst*, *const* short \**src0*, short *src1*, unsigned int *elem\_count*)  




void `__bang_div`(int \**dst*, *const* int \**src0*, int *src1*, unsigned int *elem\_count*)  




void `__bang_div`(unsigned short \**dst*, *const* unsigned short \**src0*, unsigned short *src1*, unsigned int *elem\_count*)  




void `__bang_div`(unsigned int \**dst*, *const* unsigned int \**src0*, unsigned int *src1*, unsigned int *elem\_count*)  

This function computes the division of each element in `<src0>` and `<src1>`, and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Div Operation Function for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector, or the value of second source scalar.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` and `<src0>` must point to `\_\_nram\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space if it is a vector;
* The value of `<src1>` cannot be equal to zero;
* `<dst>`, `<src0>` and `<src1>` (vector address) can be overlapped;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372`.






**Example**
```
#include <bang.h>

#define DATA\_NUM 128

\_\_mlu\_entry\_\_ void kernel(int \*output, int \*src) {
  \_\_nram\_\_ int \_src[DATA\_NUM];
  \_\_nram\_\_ int \_output[DATA\_NUM];
  \_\_memcpy(\_src, src, DATA\_NUM \* sizeof(int), GDRAM2NRAM);
  \_\_bang\_div(\_output, \_src, 10, DATA\_NUM);
  \_\_memcpy(output, \_output, DATA\_NUM \* sizeof(int), NRAM2GDRAM);
}

```













3.29.3. \_\_bang\_log
----------------------




void `__bang_log`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_log`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function computes the binary logarithm of each element in `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example*** See the example of \_\_bang\_sin for more details.













3.29.4. \_\_bang\_pow2
-----------------------




void `__bang_pow2`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_pow2`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function computes the value of 2 to the power of `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example*** See the example of \_\_bang\_sin for more details.













3.29.5. \_\_bang\_recip
------------------------




void `__bang_recip`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_recip`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function computes the reciprocal of each element in `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example*** See the example of \_\_bang\_sin for more details.













3.29.6. \_\_bang\_rem
----------------------




void `__bang_rem`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  




void `__bang_rem`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_rem`(unsigned short \**dst*, *const* unsigned short \**src0*, *const* unsigned short \**src1*, unsigned int *elem\_count*)  




void `__bang_rem`(unsigned int \**dst*, *const* unsigned int \**src0*, *const* unsigned int \**src1*, unsigned int *elem\_count*)  




void `__bang_rem`(short \**dst*, *const* short \**src0*, short *src1*, unsigned int *elem\_count*)  




void `__bang_rem`(int \**dst*, *const* int \**src0*, int *src1*, unsigned int *elem\_count*)  




void `__bang_rem`(unsigned short \**dst*, *const* unsigned short \**src0*, unsigned short *src1*, unsigned int *elem\_count*)  




void `__bang_rem`(unsigned int \**dst*, *const* unsigned int \**src0*, unsigned int *src1*, unsigned int *elem\_count*)  

This function computes the remainder of each element in `<src>` and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector, or the value of second source scalar.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` and `<src0>` must point to `\_\_nram\_\_` address space;
* `<src1>` must point to `\_\_nram\_\_` address space if it is a vector;
* The value of `<src1>` cannot be equal to zero;
* `<dst>`, `<src0>` and `<src1>` (vector address) can be overlapped.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 372;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` except `mtp\_372`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `mtp\_372`.






**Example**
```
#include <bang.h>

#define DATA\_NUM 128

\_\_mlu\_entry\_\_ void kernel(int \*output, int \*src) {
  \_\_nram\_\_ int \_src[DATA\_NUM];
  \_\_nram\_\_ int \_output[DATA\_NUM];
  \_\_memcpy(\_src, src, DATA\_NUM \* sizeof(int), GDRAM2NRAM);
  \_\_bang\_rem(\_output, \_src, 10, DATA\_NUM);
  \_\_memcpy(output, \_output, DATA\_NUM \* sizeof(int), NRAM2GDRAM);
}

```













3.29.7. \_\_bang\_rsqrt
------------------------




void `__bang_rsqrt`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_rsqrt`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function computes the reciprocal of square root of each element in `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example*** See the example of \_\_bang\_sin for more details.













3.29.8. \_\_bang\_sin
----------------------




void `__bang_sin`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_sin`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function computes the sine of each element in `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example**
```
#include <bang.h>

#define DATA\_NUM 128

\_\_mlu\_entry\_\_ void kernel(float \*output, float \*src) {
  \_\_nram\_\_ float \_src[DATA\_NUM];
  \_\_nram\_\_ float \_output[DATA\_NUM];
  \_\_memcpy(\_src, src, DATA\_NUM \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_sin(\_output, \_src, DATA\_NUM);
  \_\_memcpy(output, \_output, DATA\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













3.29.9. \_\_bang\_sqrt
-----------------------




void `__bang_sqrt`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_sqrt`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function computes the square root of each element in `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Unary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: Number of elements in source and destination.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` .






**Example*** See the example of \_\_bang\_sin for more details.

















3.30. Vector Type Conversion Functions
=======================================



3.30.1. \_\_bang\_bfloat162float
---------------------------------




void `__bang_bfloat162float`(float \**dst*, *const* bfloat16\_t \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `bfloat16\_t` to `float` element-wisely and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162float(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.2. \_\_bang\_bfloat162half
--------------------------------




void `__bang_bfloat162half`(half \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162half(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.3. \_\_bang\_bfloat162half\_dn
------------------------------------




void `__bang_bfloat162half_dn`(half \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `half` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162half\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.4. \_\_bang\_bfloat162half\_oz
------------------------------------




void `__bang_bfloat162half_oz`(half \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `half` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162half\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.5. \_\_bang\_bfloat162half\_rd
------------------------------------




void `__bang_bfloat162half_rd`(half \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `half` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162half\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.6. \_\_bang\_bfloat162half\_rm
------------------------------------




void `__bang_bfloat162half_rm`(half \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `half` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162half\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.7. \_\_bang\_bfloat162half\_rn
------------------------------------




void `__bang_bfloat162half_rn`(half \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `half` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162half\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.8. \_\_bang\_bfloat162half\_tz
------------------------------------




void `__bang_bfloat162half_tz`(half \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162half\_tz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.9. \_\_bang\_bfloat162half\_up
------------------------------------




void `__bang_bfloat162half_up`(half \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `half` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162half\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.10. \_\_bang\_bfloat162int16
----------------------------------




void `__bang_bfloat162int16`(int16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int16(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.11. \_\_bang\_bfloat162int16\_dn
--------------------------------------




void `__bang_bfloat162int16_dn`(int16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int16\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.12. \_\_bang\_bfloat162int16\_oz
--------------------------------------




void `__bang_bfloat162int16_oz`(int16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int16\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.13. \_\_bang\_bfloat162int16\_rd
--------------------------------------




void `__bang_bfloat162int16_rd`(int16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int16\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.14. \_\_bang\_bfloat162int16\_rm
--------------------------------------




void `__bang_bfloat162int16_rm`(int16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int16\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.15. \_\_bang\_bfloat162int16\_rn
--------------------------------------




void `__bang_bfloat162int16_rn`(int16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int16\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.16. \_\_bang\_bfloat162int16\_tz
--------------------------------------




void `__bang_bfloat162int16_tz`(int16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int16\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.17. \_\_bang\_bfloat162int16\_up
--------------------------------------




void `__bang_bfloat162int16_up`(int16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int16\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.18. \_\_bang\_bfloat162int32
----------------------------------




void `__bang_bfloat162int32`(int32\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int32(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.19. \_\_bang\_bfloat162int32\_dn
--------------------------------------




void `__bang_bfloat162int32_dn`(int32\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int32\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int32\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.20. \_\_bang\_bfloat162int32\_oz
--------------------------------------




void `__bang_bfloat162int32_oz`(int32\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int32\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.21. \_\_bang\_bfloat162int32\_rd
--------------------------------------




void `__bang_bfloat162int32_rd`(int32\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int32\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int32\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.22. \_\_bang\_bfloat162int32\_rm
--------------------------------------




void `__bang_bfloat162int32_rm`(int32\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int32\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int32\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.23. \_\_bang\_bfloat162int32\_rn
--------------------------------------




void `__bang_bfloat162int32_rn`(int32\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int32\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int32\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.24. \_\_bang\_bfloat162int32\_tz
--------------------------------------




void `__bang_bfloat162int32_tz`(int32\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.25. \_\_bang\_bfloat162int32\_up
--------------------------------------




void `__bang_bfloat162int32_up`(int32\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int32\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int32\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.26. \_\_bang\_bfloat162int4\_dn
-------------------------------------




void `__bang_bfloat162int4_dn`(int4x2\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int4` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int4\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.27. \_\_bang\_bfloat162int4\_oz
-------------------------------------




void `__bang_bfloat162int4_oz`(int4x2\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int4` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int4\_oz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.28. \_\_bang\_bfloat162int4\_rd
-------------------------------------




void `__bang_bfloat162int4_rd`(int4x2\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int4` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int4\_rd(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.29. \_\_bang\_bfloat162int4\_rm
-------------------------------------




void `__bang_bfloat162int4_rm`(int4x2\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int4` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int4\_rm(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.30. \_\_bang\_bfloat162int4\_rn
-------------------------------------




void `__bang_bfloat162int4_rn`(int4x2\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int4` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int4\_rn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.31. \_\_bang\_bfloat162int4\_tz
-------------------------------------




void `__bang_bfloat162int4_tz`(int4x2\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int4` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int4\_tz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.32. \_\_bang\_bfloat162int4\_up
-------------------------------------




void `__bang_bfloat162int4_up`(int4x2\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int4` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int4\_up(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.33. \_\_bang\_bfloat162int8
---------------------------------




void `__bang_bfloat162int8`(int8\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int8(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.34. \_\_bang\_bfloat162int8\_dn
-------------------------------------




void `__bang_bfloat162int8_dn`(int8\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int8\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int8\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.35. \_\_bang\_bfloat162int8\_oz
-------------------------------------




void `__bang_bfloat162int8_oz`(int8\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int8\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int8\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.36. \_\_bang\_bfloat162int8\_rd
-------------------------------------




void `__bang_bfloat162int8_rd`(int8\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int8\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int8\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.37. \_\_bang\_bfloat162int8\_rm
-------------------------------------




void `__bang_bfloat162int8_rm`(int8\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int8\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int8\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.38. \_\_bang\_bfloat162int8\_rn
-------------------------------------




void `__bang_bfloat162int8_rn`(int8\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int8\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int8\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.39. \_\_bang\_bfloat162int8\_tz
-------------------------------------




void `__bang_bfloat162int8_tz`(int8\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int8\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.40. \_\_bang\_bfloat162int8\_up
-------------------------------------




void `__bang_bfloat162int8_up`(int8\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `bfloat16\_t` to `int8\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162int8\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.41. \_\_bang\_bfloat162tf32
---------------------------------




void `__bang_bfloat162tf32`(float \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `tf32` element-wisely and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162tf32(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.42. \_\_bang\_bfloat162uchar
----------------------------------




void `__bang_bfloat162uchar`(unsigned char \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162uchar(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.43. \_\_bang\_bfloat162uchar\_dn
--------------------------------------




void `__bang_bfloat162uchar_dn`(unsigned char \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162uchar\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.44. \_\_bang\_bfloat162uchar\_oz
--------------------------------------




void `__bang_bfloat162uchar_oz`(unsigned char \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `unsigned char` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162uchar\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.45. \_\_bang\_bfloat162uchar\_rd
--------------------------------------




void `__bang_bfloat162uchar_rd`(unsigned char \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `unsigned char` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162uchar\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.46. \_\_bang\_bfloat162uchar\_rm
--------------------------------------




void `__bang_bfloat162uchar_rm`(unsigned char \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `unsigned char` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162uchar\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.47. \_\_bang\_bfloat162uchar\_rn
--------------------------------------




void `__bang_bfloat162uchar_rn`(unsigned char \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `unsigned char` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162uchar\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.48. \_\_bang\_bfloat162uchar\_tz
--------------------------------------




void `__bang_bfloat162uchar_tz`(unsigned char \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162uchar\_tz(dst\_nram, src\_nram);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.49. \_\_bang\_bfloat162uchar\_up
--------------------------------------




void `__bang_bfloat162uchar_up`(unsigned char \**dst*, *const* bfloat16\_t \**src*, unsigned int *count*)  

This function converts type of `<src>` from `bfloat16\_t` to `unsigned char` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, bfloat16\_t \*src) {
  \_\_nram\_\_ bfloat16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(bfloat16\_t), GDRAM2NRAM);
  \_\_bang\_bfloat162uchar\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.50. \_\_bang\_float2bfloat16\_dn
--------------------------------------




void `__bang_float2bfloat16_dn`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `float` to `bfloat16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2bfloat16\_rm for more details.













3.30.51. \_\_bang\_float2bfloat16\_oz
--------------------------------------




void `__bang_float2bfloat16_oz`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `float` to `bfloat16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2bfloat16\_rm for more details.













3.30.52. \_\_bang\_float2bfloat16\_rd
--------------------------------------




void `__bang_float2bfloat16_rd`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `float` to `bfloat16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2bfloat16\_rm for more details.













3.30.53. \_\_bang\_float2bfloat16\_rm
--------------------------------------




void `__bang_float2bfloat16_rm`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `float` to `bfloat16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ bfloat16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2bfloat16\_rm(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.54. \_\_bang\_float2bfloat16\_rn
--------------------------------------




void `__bang_float2bfloat16_rn`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `float` to `bfloat16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2bfloat16\_rm for more details.













3.30.55. \_\_bang\_float2bfloat16\_tz
--------------------------------------




void `__bang_float2bfloat16_tz`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `float` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2bfloat16\_rm for more details.













3.30.56. \_\_bang\_float2bfloat16\_up
--------------------------------------




void `__bang_float2bfloat16_up`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `float` to `bfloat16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2bfloat16\_rm for more details.













3.30.57. \_\_bang\_float2half\_dn
----------------------------------




void `__bang_float2half_dn`(half \**dst*, *const* float \**src*, unsigned int *src\_count*)  




void `__bang_float2half_dn`(half \**dst*, *const* float \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `float` to `half` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-down mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(float);
* \(<src\\_stride> \div sizeof(float) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2half\_tz for more details.













3.30.58. \_\_bang\_float2half\_oz
----------------------------------




void `__bang_float2half_oz`(half \**dst*, *const* float \**src*, unsigned int *src\_count*)  




void `__bang_float2half_oz`(half \**dst*, *const* float \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `float` to `half` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-off-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(float);
* \(<src\\_stride> \div sizeof(float) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2half\_tz for more details.













3.30.59. \_\_bang\_float2half\_rd
----------------------------------




void `__bang_float2half_rd`(half \**dst*, *const* float \**src*, unsigned int *src\_count*)  




void `__bang_float2half_rd`(half \**dst*, *const* float \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `float` to `half` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-nearest-off-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(float);
* \(<src\\_stride> \div sizeof(float) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2half\_tz for more details.













3.30.60. \_\_bang\_float2half\_rm
----------------------------------




void `__bang_float2half_rm`(half \**dst*, *const* float \**src*, unsigned int *src\_count*)  




void `__bang_float2half_rm`(half \**dst*, *const* float \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `float` to `half` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-math mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(float);
* \(<src\\_stride> \div sizeof(float) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2half\_rm(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.61. \_\_bang\_float2half\_rn
----------------------------------




void `__bang_float2half_rn`(half \**dst*, *const* float \**src*, unsigned int *src\_count*)  




void `__bang_float2half_rn`(half \**dst*, *const* float \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `float` to `half` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-nearest-even mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(float);
* \(<src\\_stride> \div sizeof(float) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2half\_rm for more details.













3.30.62. \_\_bang\_float2half\_sr
----------------------------------




void `__bang_float2half_sr`(half \**dst*, *const* float \**src*, int \**srv*, unsigned int *count*)  

Converts source vector with element type `float` to destination vector with element type `half` in round-stochastic mode. The number of elements in the source and destination vectors is `<count>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] srv`: The address of stochastic vector.
* `[in] count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<src>`, `<srv>` and `<dst>` must point to `\_\_nram\_\_` address space.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.30.63. \_\_bang\_float2half\_tz
----------------------------------




void `__bang_float2half_tz`(half \**dst*, *const* float \**src*, unsigned int *src\_count*)  




void `__bang_float2half_tz`(half \**dst*, *const* float \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `float` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-to-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(float);
* \(<src\\_stride> \div sizeof(float) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SRC\_STRIDE 160
#define DST\_STRIDE 320
#define LEN 128
#define SEG\_NUM 20

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src, int size) {
  \_\_nram\_\_ float src\_tmp[SRC\_STRIDE \* SEG\_NUM + LEN];
  \_\_nram\_\_ half dst\_tmp[DST\_STRIDE / sizeof(half) \* SEG\_NUM + LEN];
  \_\_memcpy(src\_tmp, src, size \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2half\_tz(dst\_tmp, src\_tmp, LEN, DST\_STRIDE, SRC\_STRIDE, SEG\_NUM);
  \_\_memcpy(dst, dst\_tmp, (DST\_STRIDE \* SEG\_NUM + LEN \* sizeof(half)), NRAM2GDRAM);
}

```













3.30.64. \_\_bang\_float2half\_up
----------------------------------




void `__bang_float2half_up`(half \**dst*, *const* float \**src*, unsigned int *src\_count*)  




void `__bang_float2half_up`(half \**dst*, *const* float \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `float` to `half` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-up mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(float);
* \(<src\\_stride> \div sizeof(float) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2half\_tz for more details.













3.30.65. \_\_bang\_float2int16\_dn
-----------------------------------




void `__bang_float2int16_dn`(int16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int16\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int16\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.66. \_\_bang\_float2int16\_oz
-----------------------------------




void `__bang_float2int16_oz`(int16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2int16\_dn for more details.













3.30.67. \_\_bang\_float2int16\_rd
-----------------------------------




void `__bang_float2int16_rd`(int16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2int16\_dn for more details.













3.30.68. \_\_bang\_float2int16\_rm
-----------------------------------




void `__bang_float2int16_rm`(int16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int16\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int16\_dn for more details.













3.30.69. \_\_bang\_float2int16\_rn
-----------------------------------




void `__bang_float2int16_rn`(int16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int16\_dn for more details.













3.30.70. \_\_bang\_float2int16\_tz
-----------------------------------




void `__bang_float2int16_tz`(int16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2int16\_dn for more details.













3.30.71. \_\_bang\_float2int16\_up
-----------------------------------




void `__bang_float2int16_up`(int16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int16\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2int16\_dn for more details.













3.30.72. \_\_bang\_float2int32
-------------------------------




void `__bang_float2int32`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int32(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.73. \_\_bang\_float2int32\_dn
-----------------------------------




void `__bang_float2int32_dn`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int32\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.74. \_\_bang\_float2int32\_oz
-----------------------------------




void `__bang_float2int32_oz`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int32\_oz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.75. \_\_bang\_float2int32\_rd
-----------------------------------




void `__bang_float2int32_rd`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int32\_rd(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.76. \_\_bang\_float2int32\_rm
-----------------------------------




void `__bang_float2int32_rm`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int32\_rm(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.77. \_\_bang\_float2int32\_rn
-----------------------------------




void `__bang_float2int32_rn`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int32\_rn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.78. \_\_bang\_float2int32\_tz
-----------------------------------




void `__bang_float2int32_tz`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int32\_tz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.79. \_\_bang\_float2int32\_up
-----------------------------------




void `__bang_float2int32_up`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int32\_up(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.80. \_\_bang\_float2int4\_dn
----------------------------------




void `__bang_float2int4_dn`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `float` to `int4` element-wisely in round-down mode. and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int4\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.81. \_\_bang\_float2int4\_oz
----------------------------------




void `__bang_float2int4_oz`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `float` to `int4` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int4\_oz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.82. \_\_bang\_float2int4\_rd
----------------------------------




void `__bang_float2int4_rd`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `float` to `int4` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int4\_rd(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.83. \_\_bang\_float2int4\_rm
----------------------------------




void `__bang_float2int4_rm`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `float` to `int4` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int4\_rm(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.84. \_\_bang\_float2int4\_rn
----------------------------------




void `__bang_float2int4_rn`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `float` to `int4` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int4\_rn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.85. \_\_bang\_float2int4\_tz
----------------------------------




void `__bang_float2int4_tz`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `float` to `int4` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int4\_tz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.86. \_\_bang\_float2int4\_up
----------------------------------




void `__bang_float2int4_up`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `float` to `int4` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int4\_up(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.87. \_\_bang\_float2int8\_dn
----------------------------------




void `__bang_float2int8_dn`(int8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int8\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int8\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.88. \_\_bang\_float2int8\_oz
----------------------------------




void `__bang_float2int8_oz`(int8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int8\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2int8\_dn for more details.













3.30.89. \_\_bang\_float2int8\_rd
----------------------------------




void `__bang_float2int8_rd`(int8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int8\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2int8\_dn for more details.













3.30.90. \_\_bang\_float2int8\_rm
----------------------------------




void `__bang_float2int8_rm`(int8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int8\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int8\_dn for more details.













3.30.91. \_\_bang\_float2int8\_rn
----------------------------------




void `__bang_float2int8_rn`(int8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int8\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int8\_dn for more details.













3.30.92. \_\_bang\_float2int8\_tz
----------------------------------




void `__bang_float2int8_tz`(int8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2int8\_dn for more details.













3.30.93. \_\_bang\_float2int8\_up
----------------------------------




void `__bang_float2int8_up`(int8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int8\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_float2int8\_dn for more details.













3.30.94. \_\_bang\_float2tf32
------------------------------




void `__bang_float2tf32`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2tf32(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.95. \_\_bang\_float2tf32\_dn
----------------------------------




void `__bang_float2tf32_dn`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `tf32` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2tf32\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.96. \_\_bang\_float2tf32\_oz
----------------------------------




void `__bang_float2tf32_oz`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `tf32` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2tf32\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.97. \_\_bang\_float2tf32\_rd
----------------------------------




void `__bang_float2tf32_rd`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `tf32` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2tf32\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.98. \_\_bang\_float2tf32\_rm
----------------------------------




void `__bang_float2tf32_rm`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `tf32` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2tf32\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.99. \_\_bang\_float2tf32\_rn
----------------------------------




void `__bang_float2tf32_rn`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `tf32` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2tf32\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.100. \_\_bang\_float2tf32\_sr
-----------------------------------




void `__bang_float2tf32_sr`(float \**dst*, *const* float \**src*, *const* int \**srv*, unsigned int *count*)  

Converts source vector with element type `float` to destination vector with element type `tf32` in round-stochastic mode. The number of elements in the source and destination vectors is `<count>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] srv`: The address of stochastic vector.
* `[in] count`: The elements number of conversion.



**Return*** `void`.






**Remark*** `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<src>`, `<srv>` and `<dst>` must point to `\_\_nram\_\_` address space.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example*** None.













3.30.101. \_\_bang\_float2tf32\_tz
-----------------------------------




void `__bang_float2tf32_tz`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2tf32\_tz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.102. \_\_bang\_float2tf32\_up
-----------------------------------




void `__bang_float2tf32_up`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `tf32` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2tf32\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.103. \_\_bang\_float2uchar
--------------------------------




void `__bang_float2uchar`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uchar(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.104. \_\_bang\_float2uchar\_dn
------------------------------------




void `__bang_float2uchar_dn`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uchar\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.105. \_\_bang\_float2uchar\_oz
------------------------------------




void `__bang_float2uchar_oz`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `unsigned char` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uchar\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.106. \_\_bang\_float2uchar\_rd
------------------------------------




void `__bang_float2uchar_rd`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `unsigned char` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uchar\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.107. \_\_bang\_float2uchar\_rm
------------------------------------




void `__bang_float2uchar_rm`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `unsigned char` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uchar\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.108. \_\_bang\_float2uchar\_rn
------------------------------------




void `__bang_float2uchar_rn`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `unsigned char` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uchar\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.109. \_\_bang\_float2uchar\_tz
------------------------------------




void `__bang_float2uchar_tz`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uchar\_tz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.110. \_\_bang\_float2uchar\_up
------------------------------------




void `__bang_float2uchar_up`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `float` to `unsigned char` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uchar\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.111. \_\_bang\_float2uint16\_dn
-------------------------------------




void `__bang_float2uint16_dn`(uint16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint16\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(uint16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ uint16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uint16\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(uint16\_t), NRAM2GDRAM);
}

```













3.30.112. \_\_bang\_float2uint16\_oz
-------------------------------------




void `__bang_float2uint16_oz`(uint16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint16\_dn for more details.













3.30.113. \_\_bang\_float2uint16\_rd
-------------------------------------




void `__bang_float2uint16_rd`(uint16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint16\_dn for more details.













3.30.114. \_\_bang\_float2uint16\_rm
-------------------------------------




void `__bang_float2uint16_rm`(uint16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint16\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint16\_dn for more details.













3.30.115. \_\_bang\_float2uint16\_rn
-------------------------------------




void `__bang_float2uint16_rn`(uint16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint16\_dn for more details.













3.30.116. \_\_bang\_float2uint16\_tz
-------------------------------------




void `__bang_float2uint16_tz`(uint16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint16\_dn for more details.













3.30.117. \_\_bang\_float2uint16\_up
-------------------------------------




void `__bang_float2uint16_up`(uint16\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint16\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint16\_dn for more details.













3.30.118. \_\_bang\_float2uint32\_dn
-------------------------------------




void `__bang_float2uint32_dn`(uint32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint32\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(uint32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ uint32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uint32\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(uint32\_t), NRAM2GDRAM);
}

```













3.30.119. \_\_bang\_float2uint32\_oz
-------------------------------------




void `__bang_float2uint32_oz`(uint32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint32\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint32\_dn for more details.













3.30.120. \_\_bang\_float2uint32\_rd
-------------------------------------




void `__bang_float2uint32_rd`(uint32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint32\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint32\_dn for more details.













3.30.121. \_\_bang\_float2uint32\_rm
-------------------------------------




void `__bang_float2uint32_rm`(uint32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint32\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint32\_dn for more details.













3.30.122. \_\_bang\_float2uint32\_rn
-------------------------------------




void `__bang_float2uint32_rn`(uint32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint32\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint32\_dn for more details.













3.30.123. \_\_bang\_float2uint32\_tz
-------------------------------------




void `__bang_float2uint32_tz`(uint32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint32\_dn for more details.













3.30.124. \_\_bang\_float2uint32\_up
-------------------------------------




void `__bang_float2uint32_up`(uint32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint32\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint32\_dn for more details.













3.30.125. \_\_bang\_float2uint8\_dn
------------------------------------




void `__bang_float2uint8_dn`(uint8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint8\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(uint8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ uint8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2uint8\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(uint8\_t), NRAM2GDRAM);
}

```













3.30.126. \_\_bang\_float2uint8\_oz
------------------------------------




void `__bang_float2uint8_oz`(uint8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint8\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint8\_dn for more details.













3.30.127. \_\_bang\_float2uint8\_rd
------------------------------------




void `__bang_float2uint8_rd`(uint8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint8\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint8\_dn for more details.













3.30.128. \_\_bang\_float2uint8\_rm
------------------------------------




void `__bang_float2uint8_rm`(uint8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint8\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint8\_dn for more details.













3.30.129. \_\_bang\_float2uint8\_rn
------------------------------------




void `__bang_float2uint8_rn`(uint8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint8\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint8\_dn for more details.













3.30.130. \_\_bang\_float2uint8\_tz
------------------------------------




void `__bang_float2uint8_tz`(uint8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 300`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint8\_dn for more details.













3.30.131. \_\_bang\_float2uint8\_up
------------------------------------




void `__bang_float2uint8_up`(uint8\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `uint8\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2uint8\_dn for more details.













3.30.132. \_\_bang\_half2bfloat16
----------------------------------




void `__bang_half2bfloat16`(bfloat16\_t \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float16\_t \*dst, half \*src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2bfloat16(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.133. \_\_bang\_half2bfloat16\_dn
--------------------------------------




void `__bang_half2bfloat16_dn`(bfloat16\_t \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `bfloat16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, half \*src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2bfloat16\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.134. \_\_bang\_half2bfloat16\_oz
--------------------------------------




void `__bang_half2bfloat16_oz`(bfloat16\_t \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `bfloat16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, half \*src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2bfloat16\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.135. \_\_bang\_half2bfloat16\_rd
--------------------------------------




void `__bang_half2bfloat16_rd`(bfloat16\_t \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `bfloat16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, half \*src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2bfloat16\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.136. \_\_bang\_half2bfloat16\_rm
--------------------------------------




void `__bang_half2bfloat16_rm`(bfloat16\_t \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `bfloat16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, half \*src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2bfloat16\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.137. \_\_bang\_half2bfloat16\_rn
--------------------------------------




void `__bang_half2bfloat16_rn`(bfloat16\_t \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `bfloat16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, half \*src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2bfloat16\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.138. \_\_bang\_half2bfloat16\_tz
--------------------------------------




void `__bang_half2bfloat16_tz`(bfloat16\_t \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, half \*src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2bfloat16\_tz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.139. \_\_bang\_half2bfloat16\_up
--------------------------------------




void `__bang_half2bfloat16_up`(bfloat16\_t \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `bfloat16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, half \*src) {
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2bfloat16\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.140. \_\_bang\_half2float
-------------------------------




void `__bang_half2float`(float \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2float`(float \**dst*, *const* half \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-to-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(float)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(float) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` cannot be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SRC\_STRIDE 160
#define DST\_STRIDE 512
#define LEN 128
#define SEG\_NUM 20

\_\_mlu\_entry\_\_ void kernel(float \*dst, half \*src, int size) {
  \_\_nram\_\_ half src\_tmp[SRC\_STRIDE \* SEG\_NUM + LEN];
  \_\_nram\_\_ float dst\_tmp[DST\_STRIDE / sizeof(float) \* SEG\_NUM + LEN];
  \_\_memcpy(src\_tmp, src, size \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2float(dst\_tmp, src\_tmp, LEN, DST\_STRIDE, SRC\_STRIDE, SEG\_NUM);
  \_\_memcpy(dst, dst\_tmp, (DST\_STRIDE \* SEG\_NUM + LEN \* sizeof(float)), NRAM2GDRAM);
}

```













3.30.141. \_\_bang\_half2int16\_dn
-----------------------------------




void `__bang_half2int16_dn`(int16\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int16\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int16\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.142. \_\_bang\_half2int16\_oz
-----------------------------------




void `__bang_half2int16_oz`(int16\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2int16\_dn for more details.













3.30.143. \_\_bang\_half2int16\_rd
-----------------------------------




void `__bang_half2int16_rd`(int16\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2int16\_dn for more details.













3.30.144. \_\_bang\_half2int16\_rm
-----------------------------------




void `__bang_half2int16_rm`(int16\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int16\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_half2int16\_dn for more details.













3.30.145. \_\_bang\_half2int16\_rn
-----------------------------------




void `__bang_half2int16_rn`(int16\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_half2int16\_dn for more details.













3.30.146. \_\_bang\_half2int16\_tz
-----------------------------------




void `__bang_half2int16_tz`(int16\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2int16\_dn for more details.













3.30.147. \_\_bang\_half2int16\_up
-----------------------------------




void `__bang_half2int16_up`(int16\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int16\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2int16\_dn for more details.













3.30.148. \_\_bang\_half2int32
-------------------------------




void `__bang_half2int32`(int32\_t \**dst*, *const* half \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int32(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.149. \_\_bang\_half2int32\_dn
-----------------------------------




void `__bang_half2int32_dn`(int32\_t \**dst*, *const* half \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int32\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int32\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.150. \_\_bang\_half2int32\_oz
-----------------------------------




void `__bang_half2int32_oz`(int32\_t \**dst*, *const* half \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int32\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int32\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.151. \_\_bang\_half2int32\_rd
-----------------------------------




void `__bang_half2int32_rd`(int32\_t \**dst*, *const* half \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int32\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int32\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.152. \_\_bang\_half2int32\_rm
-----------------------------------




void `__bang_half2int32_rm`(int32\_t \**dst*, *const* half \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int32\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int32\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.153. \_\_bang\_half2int32\_rn
-----------------------------------




void `__bang_half2int32_rn`(int32\_t \**dst*, *const* half \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int32\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int32\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.154. \_\_bang\_half2int32\_tz
-----------------------------------




void `__bang_half2int32_tz`(int32\_t \**dst*, *const* half \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.155. \_\_bang\_half2int32\_up
-----------------------------------




void `__bang_half2int32_up`(int32\_t \**dst*, *const* half \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `half` to `int32\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int32\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.156. \_\_bang\_half2int4\_dn
----------------------------------




void `__bang_half2int4_dn`(int4x2\_t \**dst*, *const* half \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `half` to `int4` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int4\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.157. \_\_bang\_half2int4\_oz
----------------------------------




void `__bang_half2int4_oz`(int4x2\_t \**dst*, *const* half \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `half` to `int4` element-wisely in in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int4\_oz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.158. \_\_bang\_half2int4\_rd
----------------------------------




void `__bang_half2int4_rd`(int4x2\_t \**dst*, *const* half \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `half` to `int4` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int4\_tz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.159. \_\_bang\_half2int4\_rm
----------------------------------




void `__bang_half2int4_rm`(int4x2\_t \**dst*, *const* half \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `half` to `int4` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int4\_rm(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.160. \_\_bang\_half2int4\_rn
----------------------------------




void `__bang_half2int4_rn`(int4x2\_t \**dst*, *const* half \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `half` to `int4` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int4\_rn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.161. \_\_bang\_half2int4\_tz
----------------------------------




void `__bang_half2int4_tz`(int4x2\_t \**dst*, *const* half \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `half` to `int4` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int4\_tz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.162. \_\_bang\_half2int4\_up
----------------------------------




void `__bang_half2int4_up`(int4x2\_t \**dst*, *const* half \**src*, unsigned int *size*, int *dst\_position*)  

This function converts type of `<src>` from `half` to `int4` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2int4\_up(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.163. \_\_bang\_half2int8\_dn
----------------------------------




void `__bang_half2int8_dn`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_half2int8_dn`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `int8\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-down mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.





Fig. 3.20 The Process of Conversion with Stride












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(int8\_t)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(int8\_t) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SRC\_STRIDE 160
#define DST\_STRIDE 320
#define LEN 128
#define SEG\_NUM 20
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, half \*src, int size) {
  \_\_nram\_\_ half src\_tmp[SRC\_STRIDE \* SEG\_NUM + LEN];
  \_\_nram\_\_ int8\_t dst\_tmp[DST\_STRIDE / sizeof(int8\_t) \* SEG\_NUM + LEN];
  \_\_memcpy(src\_tmp, src, size, GDRAM2NRAM);
  \_\_bang\_half2int8\_dn(dst\_tmp, src\_tmp, LEN, POS, DST\_STRIDE, SRC\_STRIDE, SEG\_NUM);
  \_\_memcpy(dst, dst\_tmp, (DST\_STRIDE \* SEG\_NUM + LEN \* sizeof(half)), NRAM2GDRAM);
}

```













3.30.164. \_\_bang\_half2int8\_oz
----------------------------------




void `__bang_half2int8_oz`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_half2int8_oz`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `int8\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-off-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(int8\_t)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(int8\_t) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2int8\_dn for more details.













3.30.165. \_\_bang\_half2int8\_rd
----------------------------------




void `__bang_half2int8_rd`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_half2int8_rd`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `int8\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-nearest-off-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(int8\_t)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(int8\_t) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2int8\_dn for more details.













3.30.166. \_\_bang\_half2int8\_rm
----------------------------------




void `__bang_half2int8_rm`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_half2int8_rm`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `int8\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-math mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src\_count>` must be greater than zero;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(int8\_t)`, and divisible by sizeof(int8\_t) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_half2int8\_dn for more details.













3.30.167. \_\_bang\_half2int8\_rn
----------------------------------




void `__bang_half2int8_rn`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_half2int8_rn`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `int8\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-nearest-even mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src\_count>` must be greater than zero;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(int8\_t)`, and divisible by sizeof(int8\_t) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_half2int8\_dn for more details.













3.30.168. \_\_bang\_half2int8\_tz
----------------------------------




void `__bang_half2int8_tz`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_half2int8_tz`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-to-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(int8\_t)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(int8\_t) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2int8\_dn for more details.













3.30.169. \_\_bang\_half2int8\_up
----------------------------------




void `__bang_half2int8_up`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_half2int8_up`(int8\_t \**dst*, *const* half \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `int8\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-up mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(int8\_t)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(int8\_t) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2int8\_dn for more details.













3.30.170. \_\_bang\_half2short\_dn
-----------------------------------




void `__bang_half2short_dn`(short \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2short_dn`(short \**dst*, *const* half \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `short` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-down mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(short)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(short) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SRC\_STRIDE 160
#define DST\_STRIDE 320
#define LEN 128
#define SEG\_NUM 20

\_\_mlu\_entry\_\_ void kernel(short \*dst, half \*src, int size) {
  \_\_nram\_\_ half src\_tmp[SRC\_STRIDE \* SEG\_NUM + LEN];
  \_\_nram\_\_ short dst\_tmp[DST\_STRIDE / sizeof(short) \* SEG\_NUM + LEN];
  \_\_memcpy(src\_tmp, src, size \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2short\_dn(dst\_tmp, src\_tmp, LEN, DST\_STRIDE, SRC\_STRIDE, SEG\_NUM);
  \_\_memcpy(dst, dst\_tmp, (DST\_STRIDE \* SEG\_NUM + LEN \* sizeof(short)), NRAM2GDRAM);
}

```













3.30.171. \_\_bang\_half2short\_oz
-----------------------------------




void `__bang_half2short_oz`(short \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2short_oz`(short \**dst*, *const* half \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `short` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-off-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(short)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(short) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2short\_dn for more details.













3.30.172. \_\_bang\_half2short\_rd
-----------------------------------




void `__bang_half2short_rd`(short \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2short_rd`(short \**dst*, *const* half \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `short` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-nearest-off-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(short)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(short) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2short\_dn for more details.













3.30.173. \_\_bang\_half2short\_rm
-----------------------------------




void `__bang_half2short_rm`(short \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2short_rm`(short \**dst*, *const* half \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `short` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-math mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(short)`, and divisible by sizeof(short) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(short \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ short dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2short\_rm(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(short), NRAM2GDRAM);
}

```













3.30.174. \_\_bang\_half2short\_rn
-----------------------------------




void `__bang_half2short_rn`(short \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2short_rn`(short \**dst*, *const* half \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `short` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-nearest-even mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(short)`, and divisible by sizeof(short) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_half2short\_rm for more details.













3.30.175. \_\_bang\_half2short\_tz
-----------------------------------




void `__bang_half2short_tz`(short \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2short_tz`(short \**dst*, *const* half \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `short` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-to-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(short)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(short) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2short\_dn for more details.













3.30.176. \_\_bang\_half2short\_up
-----------------------------------




void `__bang_half2short_up`(short \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2short_up`(short \**dst*, *const* half \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `half` to `short` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-up mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(short)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(short) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(half);
* \(<src\\_stride> \div sizeof(half) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_half2short\_dn for more details.













3.30.177. \_\_bang\_half2tf32
------------------------------




void `__bang_half2tf32`(float \**dst*, *const* half \**src*, unsigned int *count*)  

This function converts type of `<src>` from `half` to `tf32` element-wisely and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, half \*src) {
  \_\_nram\_\_ half src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2tf32(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.178. \_\_bang\_half2uchar\_dn
-----------------------------------




void `__bang_half2uchar_dn`(unsigned char \**dst*, *const* half \**src*, unsigned int *src\_count*)  




void `__bang_half2uchar_dn`(unsigned char \**dst*, *const* half \**src*, half \**src\_addition*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_addition`: The address of additional vector for source.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` , `<dst>` and `<src\_addition>` must point to `\_\_nram\_\_` address space;
* The size of `<src\_addition>` vector is identical to the size of `<src>` and `<dst>`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* The difference between two version is that the version without `<src\_addition>` can convert data in the range of `[0,127]`, the version with `<src\_addition>` can convert data in the range of `[0,255]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ unsigned char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2uchar\_dn(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.179. \_\_bang\_half2uchar\_oz
-----------------------------------




void `__bang_half2uchar_oz`(unsigned char \**dst*, *const* half \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `unsigned char` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ unsigned char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2uchar\_oz(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.180. \_\_bang\_half2uchar\_rd
-----------------------------------




void `__bang_half2uchar_rd`(unsigned char \**dst*, *const* half \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `unsigned char` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ unsigned char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2uchar\_rd(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.181. \_\_bang\_half2uchar\_rm
-----------------------------------




void `__bang_half2uchar_rm`(unsigned char \**dst*, *const* half \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `unsigned char` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ unsigned char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2uchar\_rm(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.182. \_\_bang\_half2uchar\_rn
-----------------------------------




void `__bang_half2uchar_rn`(unsigned char \**dst*, *const* half \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `unsigned char` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ unsigned char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2uchar\_rn(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.183. \_\_bang\_half2uchar\_tz
-----------------------------------




void `__bang_half2uchar_tz`(unsigned char \**dst*, *const* half \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ unsigned char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2uchar\_tz(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.184. \_\_bang\_half2uchar\_up
-----------------------------------




void `__bang_half2uchar_up`(unsigned char \**dst*, *const* half \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `unsigned char` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.2.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ unsigned char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2uchar\_up(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.185. \_\_bang\_int162bfloat16
-----------------------------------




void `__bang_int162bfloat16`(bfloat16\_t \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162bfloat16(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.186. \_\_bang\_int162bfloat16\_dn
---------------------------------------




void `__bang_int162bfloat16_dn`(bfloat16\_t \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `bfloat16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162bfloat16\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.187. \_\_bang\_int162bfloat16\_oz
---------------------------------------




void `__bang_int162bfloat16_oz`(bfloat16\_t \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `bfloat16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162bfloat16\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.188. \_\_bang\_int162bfloat16\_rd
---------------------------------------




void `__bang_int162bfloat16_rd`(bfloat16\_t \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `bfloat16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162bfloat16\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.189. \_\_bang\_int162bfloat16\_rm
---------------------------------------




void `__bang_int162bfloat16_rm`(bfloat16\_t \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `bfloat16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162bfloat16\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.190. \_\_bang\_int162bfloat16\_rn
---------------------------------------




void `__bang_int162bfloat16_rn`(bfloat16\_t \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `bfloat16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162bfloat16\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.191. \_\_bang\_int162bfloat16\_tz
---------------------------------------




void `__bang_int162bfloat16_tz`(bfloat16\_t \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162bfloat16\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.192. \_\_bang\_int162bfloat16\_up
---------------------------------------




void `__bang_int162bfloat16_up`(bfloat16\_t \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `bfloat16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162bfloat16\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.193. \_\_bang\_int162float
--------------------------------




void `__bang_int162float`(float \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_int162float(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.194. \_\_bang\_int162half
-------------------------------




void `__bang_int162half`(half \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero;
* `<src\_count>` must be divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162half(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.195. \_\_bang\_int162half\_dn
-----------------------------------




void `__bang_int162half_dn`(half \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `half` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero;
* `<src\_count>` must be divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162half\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.196. \_\_bang\_int162half\_oz
-----------------------------------




void `__bang_int162half_oz`(half \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `half` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero;
* `<src\_count>` must be divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162half\_oz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.197. \_\_bang\_int162half\_rd
-----------------------------------




void `__bang_int162half_rd`(half \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `half` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero;
* `<src\_count>` must be divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162half\_rd(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.198. \_\_bang\_int162half\_rm
-----------------------------------




void `__bang_int162half_rm`(half \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `half` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162half\_rm(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.199. \_\_bang\_int162half\_rn
-----------------------------------




void `__bang_int162half_rn`(half \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `half` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162half\_rn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.200. \_\_bang\_int162half\_tz
-----------------------------------




void `__bang_int162half_tz`(half \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero;
* `<src\_count>` must be divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162half\_tz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.201. \_\_bang\_int162half\_up
-----------------------------------




void `__bang_int162half_up`(half \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `half` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero;
* `<src\_count>` must be divisible by 64 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 4.1.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162half\_up(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.202. \_\_bang\_int162int32
--------------------------------




void `__bang_int162int32`(int32\_t \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc -bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int32(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.203. \_\_bang\_int162int4\_dn
-----------------------------------




void `__bang_int162int4_dn`(int4x2\_t \**dst*, *const* int16\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int4` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int4\_dn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.204. \_\_bang\_int162int4\_oz
-----------------------------------




void `__bang_int162int4_oz`(int4x2\_t \**dst*, *const* int16\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int4` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_tt src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int4\_oz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.205. \_\_bang\_int162int4\_rd
-----------------------------------




void `__bang_int162int4_rd`(int4x2\_t \**dst*, *const* int16\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int4` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int4\_rd(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.206. \_\_bang\_int162int4\_rm
-----------------------------------




void `__bang_int162int4_rm`(int4x2\_t \**dst*, *const* int16\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int4` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int4\_rm(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.207. \_\_bang\_int162int4\_rn
-----------------------------------




void `__bang_int162int4_rn`(int4x2\_t \**dst*, *const* int16\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int4` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int4\_rn(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.208. \_\_bang\_int162int4\_tz
-----------------------------------




void `__bang_int162int4_tz`(int4x2\_t \**dst*, *const* int16\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int4` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int4\_tz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.209. \_\_bang\_int162int4\_up
-----------------------------------




void `__bang_int162int4_up`(int4x2\_t \**dst*, *const* int16\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int4` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int4\_up(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.210. \_\_bang\_int162int8
-------------------------------




void `__bang_int162int8`(int8\_t \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162int8(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.211. \_\_bang\_int162tf32
-------------------------------




void `__bang_int162tf32`(float \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162tf32(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.212. \_\_bang\_int162tf32\_dn
-----------------------------------




void `__bang_int162tf32_dn`(float \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `tf32` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162tf32\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.213. \_\_bang\_int162tf32\_oz
-----------------------------------




void `__bang_int162tf32_oz`(float \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `tf32` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162tf32\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.214. \_\_bang\_int162tf32\_rd
-----------------------------------




void `__bang_int162tf32_rd`(float \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `tf32` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162tf32\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.215. \_\_bang\_int162tf32\_rm
-----------------------------------




void `__bang_int162tf32_rm`(float \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `tf32` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162tf32\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.216. \_\_bang\_int162tf32\_rn
-----------------------------------




void `__bang_int162tf32_rn`(float \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `tf32` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162tf32\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.217. \_\_bang\_int162tf32\_tz
-----------------------------------




void `__bang_int162tf32_tz`(float \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162tf32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.218. \_\_bang\_int162tf32\_up
-----------------------------------




void `__bang_int162tf32_up`(float \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `tf32` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162tf32\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.219. \_\_bang\_int162uchar
--------------------------------




void `__bang_int162uchar`(unsigned char \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162uchar(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.220. \_\_bang\_int162uchar\_dn
------------------------------------




void `__bang_int162uchar_dn`(unsigned char \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162uchar\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.221. \_\_bang\_int162uchar\_oz
------------------------------------




void `__bang_int162uchar_oz`(unsigned char \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `unsigned char` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162uchar\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.222. \_\_bang\_int162uchar\_rd
------------------------------------




void `__bang_int162uchar_rd`(unsigned char \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `unsigned char` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162uchar\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.223. \_\_bang\_int162uchar\_rm
------------------------------------




void `__bang_int162uchar_rm`(unsigned char \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `unsigned char` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162uchar\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.224. \_\_bang\_int162uchar\_rn
------------------------------------




void `__bang_int162uchar_rn`(unsigned char \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `unsigned char` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162uchar\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.225. \_\_bang\_int162uchar\_tz
------------------------------------




void `__bang_int162uchar_tz`(unsigned char \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162uchar\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.226. \_\_bang\_int162uchar\_up
------------------------------------




void `__bang_int162uchar_up`(unsigned char \**dst*, *const* int16\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int16\_t` to `unsigned char` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int162uchar\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.227. \_\_bang\_int322bfloat16
-----------------------------------




void `__bang_int322bfloat16`(bfloat16\_t \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322bfloat16(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.228. \_\_bang\_int322bfloat16\_dn
---------------------------------------




void `__bang_int322bfloat16_dn`(bfloat16\_t \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `bfloat16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322bfloat16\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.229. \_\_bang\_int322bfloat16\_oz
---------------------------------------




void `__bang_int322bfloat16_oz`(bfloat16\_t \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `bfloat16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322bfloat16\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.230. \_\_bang\_int322bfloat16\_rd
---------------------------------------




void `__bang_int322bfloat16_rd`(bfloat16\_t \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `bfloat16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322bfloat16\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.231. \_\_bang\_int322bfloat16\_rm
---------------------------------------




void `__bang_int322bfloat16_rm`(bfloat16\_t \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `bfloat16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322bfloat16\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.232. \_\_bang\_int322bfloat16\_rn
---------------------------------------




void `__bang_int322bfloat16_rn`(bfloat16\_t \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `bfloat16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322bfloat16\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.233. \_\_bang\_int322bfloat16\_tz
---------------------------------------




void `__bang_int322bfloat16_tz`(bfloat16\_t \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_int322bfloat16\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.234. \_\_bang\_int322bfloat16\_up
---------------------------------------




void `__bang_int322bfloat16_up`(bfloat16\_t \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `bfloat16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322bfloat16\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.235. \_\_bang\_int322float
--------------------------------




void `__bang_int322float`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322float(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.236. \_\_bang\_int322float\_dn
------------------------------------




void `__bang_int322float_dn`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322float\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.237. \_\_bang\_int322float\_oz
------------------------------------




void `__bang_int322float_oz`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322float\_oz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.238. \_\_bang\_int322float\_rd
------------------------------------




void `__bang_int322float_rd`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322float\_rd(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.239. \_\_bang\_int322float\_rm
------------------------------------




void `__bang_int322float_rm`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322float\_rm(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.240. \_\_bang\_int322float\_rn
------------------------------------




void `__bang_int322float_rn`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322float\_rn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.241. \_\_bang\_int322float\_tz
------------------------------------




void `__bang_int322float_tz`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322float\_tz(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.242. \_\_bang\_int322float\_up
------------------------------------




void `__bang_int322float_up`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 4.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322float\_up(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.243. \_\_bang\_int322half
-------------------------------




void `__bang_int322half`(half \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(half \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322half(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.244. \_\_bang\_int322half\_dn
-----------------------------------




void `__bang_int322half_dn`(half \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `half` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(half \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322half\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.245. \_\_bang\_int322half\_oz
-----------------------------------




void `__bang_int322half_oz`(half \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `half` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(half \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322half\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.246. \_\_bang\_int322half\_rd
-----------------------------------




void `__bang_int322half_rd`(half \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `half` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(half \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322half\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.247. \_\_bang\_int322half\_rm
-----------------------------------




void `__bang_int322half_rm`(half \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `half` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(half \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322half\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.248. \_\_bang\_int322half\_rn
-----------------------------------




void `__bang_int322half_rn`(half \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `half` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(half \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322half\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.249. \_\_bang\_int322half\_tz
-----------------------------------




void `__bang_int322half_tz`(half \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(half \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322half\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.250. \_\_bang\_int322half\_up
-----------------------------------




void `__bang_int322half_up`(half \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `half` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(half \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322half\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.251. \_\_bang\_int322int16
--------------------------------




void `__bang_int322int16`(int16\_t \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int16(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.252. \_\_bang\_int322int4\_dn
-----------------------------------




void `__bang_int322int4_dn`(int4x2\_t \**dst*, *const* int32\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int4` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int4\_dn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.253. \_\_bang\_int322int4\_oz
-----------------------------------




void `__bang_int322int4_oz`(int4x2\_t \**dst*, *const* int32\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int4` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int4\_oz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.254. \_\_bang\_int322int4\_rd
-----------------------------------




void `__bang_int322int4_rd`(int4x2\_t \**dst*, *const* int32\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int4` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int4\_rd(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.255. \_\_bang\_int322int4\_rm
-----------------------------------




void `__bang_int322int4_rm`(int4x2\_t \**dst*, *const* int32\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int4` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int4\_rm(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.256. \_\_bang\_int322int4\_rn
-----------------------------------




void `__bang_int322int4_rn`(int4x2\_t \**dst*, *const* int32\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int4` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int4\_rn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.257. \_\_bang\_int322int4\_tz
-----------------------------------




void `__bang_int322int4_tz`(int4x2\_t \**dst*, *const* int32\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int4` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int4\_tz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.258. \_\_bang\_int322int4\_up
-----------------------------------




void `__bang_int322int4_up`(int4x2\_t \**dst*, *const* int32\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int4` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int4\_up(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.259. \_\_bang\_int322int8
-------------------------------




void `__bang_int322int8`(int8\_t \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int8\_t` element-wisely round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322int8(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.260. \_\_bang\_int322tf32
-------------------------------




void `__bang_int322tf32`(float \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322tf32(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.261. \_\_bang\_int322tf32\_dn
-----------------------------------




void `__bang_int322tf32_dn`(float \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `tf32` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322tf32\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.262. \_\_bang\_int322tf32\_oz
-----------------------------------




void `__bang_int322tf32_oz`(float \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `tf32` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322tf32\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.263. \_\_bang\_int322tf32\_rd
-----------------------------------




void `__bang_int322tf32_rd`(float \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `tf32` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322tf32\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.264. \_\_bang\_int322tf32\_rm
-----------------------------------




void `__bang_int322tf32_rm`(float \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `tf32` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322tf32\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.265. \_\_bang\_int322tf32\_rn
-----------------------------------




void `__bang_int322tf32_rn`(float \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `tf32` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322tf32\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.266. \_\_bang\_int322tf32\_tz
-----------------------------------




void `__bang_int322tf32_tz`(float \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322tf32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.267. \_\_bang\_int322tf32\_up
-----------------------------------




void `__bang_int322tf32_up`(float \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `tf32` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322tf32\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.268. \_\_bang\_int322uchar
--------------------------------




void `__bang_int322uchar`(unsigned char \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322uchar(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.269. \_\_bang\_int322uchar\_dn
------------------------------------




void `__bang_int322uchar_dn`(unsigned char \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322uchar\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.270. \_\_bang\_int322uchar\_oz
------------------------------------




void `__bang_int322uchar_oz`(unsigned char \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `unsigned char` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322uchar\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.271. \_\_bang\_int322uchar\_rd
------------------------------------




void `__bang_int322uchar_rd`(unsigned char \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `unsigned char` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322uchar\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.272. \_\_bang\_int322uchar\_rm
------------------------------------




void `__bang_int322uchar_rm`(unsigned char \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `unsigned char` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322uchar\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.273. \_\_bang\_int322uchar\_rn
------------------------------------




void `__bang_int322uchar_rn`(unsigned char \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `unsigned char` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322uchar\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.274. \_\_bang\_int322uchar\_tz
------------------------------------




void `__bang_int322uchar_tz`(unsigned char \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322uchar\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.275. \_\_bang\_int322uchar\_up
------------------------------------




void `__bang_int322uchar_up`(unsigned char \**dst*, *const* int32\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `unsigned char` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int322uchar\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.276. \_\_bang\_int42bfloat16\_dn
--------------------------------------




void `__bang_int42bfloat16_dn`(bfloat16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `bfloat16\_t` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ bfloat16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42bfloat16\_dn(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.277. \_\_bang\_int42bfloat16\_oz
--------------------------------------




void `__bang_int42bfloat16_oz`(bfloat16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `bfloat16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ bfloat16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42bfloat16\_oz(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.278. \_\_bang\_int42bfloat16\_rd
--------------------------------------




void `__bang_int42bfloat16_rd`(bfloat16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `bfloat16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ bfloat16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42bfloat16\_rd(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.279. \_\_bang\_int42bfloat16\_rm
--------------------------------------




void `__bang_int42bfloat16_rm`(bfloat16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `bfloat16\_t` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ bfloat16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42bfloat16\_rm(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.280. \_\_bang\_int42bfloat16\_rn
--------------------------------------




void `__bang_int42bfloat16_rn`(bfloat16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `bfloat16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ bfloat16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42bfloat16\_rn(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.281. \_\_bang\_int42bfloat16\_tz
--------------------------------------




void `__bang_int42bfloat16_tz`(bfloat16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ bfloat16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42bfloat16\_tz(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.282. \_\_bang\_int42bfloat16\_up
--------------------------------------




void `__bang_int42bfloat16_up`(bfloat16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `bfloat16\_t` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ bfloat16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42bfloat16\_up(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.283. \_\_bang\_int42float\_dn
-----------------------------------




void `__bang_int42float_dn`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `float` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42float\_dn(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.284. \_\_bang\_int42float\_oz
-----------------------------------




void `__bang_int42float_oz`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `float` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42float\_oz(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.285. \_\_bang\_int42float\_rd
-----------------------------------




void `__bang_int42float_rd`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `float` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42float\_rd(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.286. \_\_bang\_int42float\_rm
-----------------------------------




void `__bang_int42float_rm`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `float` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42float\_rm(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.287. \_\_bang\_int42float\_rn
-----------------------------------




void `__bang_int42float_rn`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `float` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42float\_rn(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.288. \_\_bang\_int42float\_tz
-----------------------------------




void `__bang_int42float_tz`(float \**dst*, int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42float\_tz(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.289. \_\_bang\_int42float\_up
-----------------------------------




void `__bang_int42float_up`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `float` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42float\_up(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.290. \_\_bang\_int42half\_dn
----------------------------------




void `__bang_int42half_dn`(half \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `half` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42half\_dn(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.291. \_\_bang\_int42half\_oz
----------------------------------




void `__bang_int42half_oz`(half \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `half` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42half\_oz(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.292. \_\_bang\_int42half\_rd
----------------------------------




void `__bang_int42half_rd`(half \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `half` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42half\_rd(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.293. \_\_bang\_int42half\_rm
----------------------------------




void `__bang_int42half_rm`(half \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `half` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42half\_rm(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.294. \_\_bang\_int42half\_rn
----------------------------------




void `__bang_int42half_rn`(half \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `half` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42half\_rn(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.295. \_\_bang\_int42half\_tz
----------------------------------




void `__bang_int42half_tz`(half \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42half\_tz(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.296. \_\_bang\_int42half\_up
----------------------------------




void `__bang_int42half_up`(half \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `half` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* `<size>` must be greater than zero and divisible by 2;
* `<src\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ half dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42half\_up(dst\_tmp, src\_tmp, SIZE, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(half), NRAM2GDRAM);
}

```













3.30.297. \_\_bang\_int42int16\_dn
-----------------------------------




void `__bang_int42int16_dn`(int16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int16\_t` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int16\_dn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.298. \_\_bang\_int42int16\_oz
-----------------------------------




void `__bang_int42int16_oz`(int16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int16\_oz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.299. \_\_bang\_int42int16\_rd
-----------------------------------




void `__bang_int42int16_rd`(int16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int16\_rd(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.300. \_\_bang\_int42int16\_rm
-----------------------------------




void `__bang_int42int16_rm`(int16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int16\_t` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int16\_rm(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.301. \_\_bang\_int42int16\_rn
-----------------------------------




void `__bang_int42int16_rn`(int16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int16\_rn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.302. \_\_bang\_int42int16\_tz
-----------------------------------




void `__bang_int42int16_tz`(int16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int16\_tz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.303. \_\_bang\_int42int16\_up
-----------------------------------




void `__bang_int42int16_up`(int16\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int16\_t` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int16\_up(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.304. \_\_bang\_int42int32\_dn
-----------------------------------




void `__bang_int42int32_dn`(int32\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int32\_t` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int32\_dn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.305. \_\_bang\_int42int32\_oz
-----------------------------------




void `__bang_int42int32_oz`(int32\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int32\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int32\_oz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.306. \_\_bang\_int42int32\_rd
-----------------------------------




void `__bang_int42int32_rd`(int32\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int32\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int32\_rd(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.307. \_\_bang\_int42int32\_rm
-----------------------------------




void `__bang_int42int32_rm`(int32\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int32\_t` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int32\_rm(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.308. \_\_bang\_int42int32\_rn
-----------------------------------




void `__bang_int42int32_rn`(int32\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int32\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int32\_rn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.309. \_\_bang\_int42int32\_tz
-----------------------------------




void `__bang_int42int32_tz`(int32\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int32\_tz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.310. \_\_bang\_int42int32\_up
-----------------------------------




void `__bang_int42int32_up`(int32\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int32\_t` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int32\_up(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.311. \_\_bang\_int42int8\_dn
----------------------------------




void `__bang_int42int8_dn`(int8\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int8\_t` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int8\_oz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.312. \_\_bang\_int42int8\_oz
----------------------------------




void `__bang_int42int8_oz`(int8\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int8\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int8\_oz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.313. \_\_bang\_int42int8\_rd
----------------------------------




void `__bang_int42int8_rd`(int8\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int8\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int8\_rd(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.314. \_\_bang\_int42int8\_rm
----------------------------------




void `__bang_int42int8_rm`(int8\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int8\_t` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int8\_rm(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.315. \_\_bang\_int42int8\_rn
----------------------------------




void `__bang_int42int8_rn`(int8\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int8\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int8\_rm(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.316. \_\_bang\_int42int8\_tz
----------------------------------




void `__bang_int42int8_tz`(int8\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int8\_tz(dst\_tmp, src\_tmp, SIZE, DSRPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.317. \_\_bang\_int42int8\_up
----------------------------------




void `__bang_int42int8_up`(int8\_t \**dst*, *const* int4x2\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int4` to `int8\_t` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_tmp[SIZE/2];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int4x2\_t) / 2, GDRAM2NRAM);
  \_\_bang\_int42int8\_oz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.318. \_\_bang\_int42tf32
------------------------------




void `__bang_int42tf32`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42tf32(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.319. \_\_bang\_int42tf32\_dn
----------------------------------




void `__bang_int42tf32_dn`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `tf32` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42tf32\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.320. \_\_bang\_int42tf32\_oz
----------------------------------




void `__bang_int42tf32_oz`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `tf32` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42tf32\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.321. \_\_bang\_int42tf32\_rd
----------------------------------




void `__bang_int42tf32_rd`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `tf32` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42tf32\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.322. \_\_bang\_int42tf32\_rm
----------------------------------




void `__bang_int42tf32_rm`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `tf32` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42tf32\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.323. \_\_bang\_int42tf32\_rn
----------------------------------




void `__bang_int42tf32_rn`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `tf32` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, char \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42tf32\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.324. \_\_bang\_int42tf32\_tz
----------------------------------




void `__bang_int42tf32_tz`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42tf32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.325. \_\_bang\_int42tf32\_up
----------------------------------




void `__bang_int42tf32_up`(float \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `tf32` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42tf32\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.326. \_\_bang\_int42uchar
-------------------------------




void `__bang_int42uchar`(unsigned char \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42uchar(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.327. \_\_bang\_int42uchar\_dn
-----------------------------------




void `__bang_int42uchar_dn`(unsigned char \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42uchar\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.328. \_\_bang\_int42uchar\_oz
-----------------------------------




void `__bang_int42uchar_oz`(unsigned char \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `unsigned char` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42uchar\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.329. \_\_bang\_int42uchar\_rd
-----------------------------------




void `__bang_int42uchar_rd`(unsigned char \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `unsigned char` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42uchar\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.330. \_\_bang\_int42uchar\_rm
-----------------------------------




void `__bang_int42uchar_rm`(unsigned char \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `unsigned char` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42uchar\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.331. \_\_bang\_int42uchar\_rn
-----------------------------------




void `__bang_int42uchar_rn`(unsigned char \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `unsigned char` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42uchar\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.332. \_\_bang\_int42uchar\_tz
-----------------------------------




void `__bang_int42uchar_tz`(unsigned char \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42uchar\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.333. \_\_bang\_int42uchar\_up
-----------------------------------




void `__bang_int42uchar_up`(unsigned char \**dst*, *const* int4x2\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int4x2\_t` to `unsigned char` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int4x2\_t \*src) {
  \_\_nram\_\_ int4x2\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int4x2\_t), GDRAM2NRAM);
  \_\_bang\_int42uchar\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.334. \_\_bang\_int82bfloat16
----------------------------------




void `__bang_int82bfloat16`(bfloat16\_t \**dst*, *const* int8\_t \**src*, int *fix\_position*, unsigned int *count*)  

This function converts type of `<src>` from `int8\_t` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8 src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82bfloat16(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.335. \_\_bang\_int82bfloat16\_dn
--------------------------------------




void `__bang_int82bfloat16_dn`(bfloat16\_t \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `bfloat16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82bfloat16\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.336. \_\_bang\_int82bfloat16\_oz
--------------------------------------




void `__bang_int82bfloat16_oz`(bfloat16\_t \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `bfloat16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82bfloat16\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.337. \_\_bang\_int82bfloat16\_rd
--------------------------------------




void `__bang_int82bfloat16_rd`(bfloat16\_t \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `bfloat16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82bfloat16\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.338. \_\_bang\_int82bfloat16\_rm
--------------------------------------




void `__bang_int82bfloat16_rm`(bfloat16\_t \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `bfloat16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82bfloat16\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.339. \_\_bang\_int82bfloat16\_rn
--------------------------------------




void `__bang_int82bfloat16_rn`(bfloat16\_t \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `bfloat16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82bfloat16\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.340. \_\_bang\_int82bfloat16\_tz
--------------------------------------




void `__bang_int82bfloat16_tz`(bfloat16\_t \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82bfloat16\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.341. \_\_bang\_int82bfloat16\_up
--------------------------------------




void `__bang_int82bfloat16_up`(bfloat16\_t \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `bfloat16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82bfloat16\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.342. \_\_bang\_int82float
-------------------------------




void `__bang_int82float`(float \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82float(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













3.30.343. \_\_bang\_int82half
------------------------------




void `__bang_int82half`(half \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_int82half`(half \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `int8\_t` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-to-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(int8\_t);
* \(<src\\_stride> \div ``sizeof(int8\_t)`` \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` cannot be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SRC\_STRIDE 160
#define DST\_STRIDE 320
#define LEN 128
#define SEG\_NUM 20
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int8\_t \*src, int size) {
  \_\_nram\_\_ int8\_t src\_tmp[SRC\_STRIDE \* SEG\_NUM + LEN];
  \_\_nram\_\_ half dst\_tmp[DST\_STRIDE / sizeof(half) \* SEG\_NUM + LEN];
  \_\_memcpy(src\_tmp, src, size, GDRAM2NRAM);
  \_\_bang\_int82half(dst\_tmp, src\_tmp, LEN, POS, DST\_STRIDE, SRC\_STRIDE, SEG\_NUM);
  \_\_memcpy(dst, dst\_tmp, (DST\_STRIDE \* SEG\_NUM + LEN \* sizeof(half)), NRAM2GDRAM);
}

```













3.30.344. \_\_bang\_int82int16
-------------------------------




void `__bang_int82int16`(int16\_t \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int16(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.345. \_\_bang\_int82int32
-------------------------------




void `__bang_int82int32`(int32\_t \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int32(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.346. \_\_bang\_int82int4\_dn
----------------------------------




void `__bang_int82int4_dn`(int4x2\_t \**dst*, *const* int8\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int4` element-wisely in round-down mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int4\_dn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.347. \_\_bang\_int82int4\_oz
----------------------------------




void `__bang_int82int4_oz`(int4x2\_t \**dst*, *const* int8\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int4` element-wisely in round-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int4\_oz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.348. \_\_bang\_int82int4\_rd
----------------------------------




void `__bang_int82int4_rd`(int4x2\_t \**dst*, *const* int8\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int4` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int4\_rd(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.349. \_\_bang\_int82int4\_rm
----------------------------------




void `__bang_int82int4_rm`(int4x2\_t \**dst*, *const* int8\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int4` element-wisely in round-math mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int4\_rm(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.350. \_\_bang\_int82int4\_rn
----------------------------------




void `__bang_int82int4_rn`(int4x2\_t \**dst*, *const* int8\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int4` element-wisely in round-nearest-even mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int4\_rn(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.351. \_\_bang\_int82int4\_tz
----------------------------------




void `__bang_int82int4_tz`(int4x2\_t \**dst*, *const* int8\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int4` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int4\_tz(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.352. \_\_bang\_int82int4\_up
----------------------------------




void `__bang_int82int4_up`(int4x2\_t \**dst*, *const* int8\_t \**src*, unsigned int *size*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int4` element-wisely in round-up mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] size`: The elements number of conversion.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<size>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.7.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int4x2\_t dst\_tmp[SIZE/2];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82int4\_up(dst\_tmp, src\_tmp, SIZE, DSTPOS, SRCPOS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int4x2\_t) / 2, NRAM2GDRAM);
}

```













3.30.353. \_\_bang\_int82tf32
------------------------------




void `__bang_int82tf32`(float \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82tf32(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.354. \_\_bang\_int82tf32\_dn
----------------------------------




void `__bang_int82tf32_dn`(float \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `tf32` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82tf32\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.355. \_\_bang\_int82tf32\_oz
----------------------------------




void `__bang_int82tf32_oz`(float \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `tf32` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82tf32\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.356. \_\_bang\_int82tf32\_rd
----------------------------------




void `__bang_int82tf32_rd`(float \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `tf32` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82tf32\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.357. \_\_bang\_int82tf32\_rm
----------------------------------




void `__bang_int82tf32_rm`(float \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `tf32` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82tf32\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.358. \_\_bang\_int82tf32\_rn
----------------------------------




void `__bang_int82tf32_rn`(float \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `tf32` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82tf32\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.359. \_\_bang\_int82tf32\_tz
----------------------------------




void `__bang_int82tf32_tz`(float \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `tf32` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82tf32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.360. \_\_bang\_int82tf32\_up
----------------------------------




void `__bang_int82tf32_up`(float \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `tf32` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(float \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82tf32\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.361. \_\_bang\_int82uchar
-------------------------------




void `__bang_int82uchar`(unsigned char \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82uchar(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.362. \_\_bang\_int82uchar\_dn
-----------------------------------




void `__bang_int82uchar_dn`(unsigned char \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82uchar\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.363. \_\_bang\_int82uchar\_oz
-----------------------------------




void `__bang_int82uchar_oz`(unsigned char \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `unsigned char` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82uchar\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.364. \_\_bang\_int82uchar\_rd
-----------------------------------




void `__bang_int82uchar_rd`(unsigned char \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `unsigned char` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82uchar\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.365. \_\_bang\_int82uchar\_rm
-----------------------------------




void `__bang_int82uchar_rm`(unsigned char \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `unsigned char` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82uchar\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.366. \_\_bang\_int82uchar\_rn
-----------------------------------




void `__bang_int82uchar_rn`(unsigned char \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `unsigned char` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82uchar\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.367. \_\_bang\_int82uchar\_tz
-----------------------------------




void `__bang_int82uchar_tz`(unsigned char \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82uchar\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.368. \_\_bang\_int82uchar\_up
-----------------------------------




void `__bang_int82uchar_up`(unsigned char \**dst*, *const* int8\_t \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `int8\_t` to `unsigned char` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_nram[LEN];
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_int82uchar\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(unsigned char), NRAM2GDRAM);
}

```













3.30.369. \_\_bang\_short2half
-------------------------------




void `__bang_short2half`(half \**dst*, *const* short \**src*, unsigned int *src\_count*)  




void `__bang_short2half`(half \**dst*, *const* short \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `short` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-to-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 64 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(short);
* \(<src\\_stride> \div sizeof(short) \ge <src\\_count>\) if `<src\_stride>` is greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SRC\_STRIDE 160
#define DST\_STRIDE 320
#define LEN 128
#define SEG\_NUM 20

\_\_mlu\_entry\_\_ void kernel(half \*dst, short \*src, int size) {
  \_\_nram\_\_ short src\_tmp[SRC\_STRIDE \* SEG\_NUM + LEN];
  \_\_nram\_\_ half dst\_tmp[DST\_STRIDE / sizeof(half) \* SEG\_NUM + LEN];
  \_\_memcpy(src\_tmp, src, size \* sizeof(short), GDRAM2NRAM);
  \_\_bang\_short2half(dst\_tmp, src\_tmp, LEN, DST\_STRIDE, SRC\_STRIDE, SEG\_NUM);
  \_\_memcpy(dst, dst\_tmp, (DST\_STRIDE \* SEG\_NUM + LEN \* sizeof(half)), NRAM2GDRAM);
}

```













3.30.370. \_\_bang\_tf322bfloat16
----------------------------------




void `__bang_tf322bfloat16`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322bfloat16(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.371. \_\_bang\_tf322bfloat16\_dn
--------------------------------------




void `__bang_tf322bfloat16_dn`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `bfloat16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322bfloat16\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.372. \_\_bang\_tf322bfloat16\_oz
--------------------------------------




void `__bang_tf322bfloat16_oz`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `bfloat16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322bfloat16\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.373. \_\_bang\_tf322bfloat16\_rd
--------------------------------------




void `__bang_tf322bfloat16_rd`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `bfloat16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322bfloat16\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_), NRAM2GDRAM);
}

```













3.30.374. \_\_bang\_tf322bfloat16\_rm
--------------------------------------




void `__bang_tf322bfloat16_rm`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `bfloat16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322bfloat16\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.375. \_\_bang\_tf322bfloat16\_rn
--------------------------------------




void `__bang_tf322bfloat16_rn`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `bfloat16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322bfloat16\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.376. \_\_bang\_tf322bfloat16\_tz
--------------------------------------




void `__bang_tf322bfloat16_tz`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `bfloat16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322bfloat16\_tz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.377. \_\_bang\_tf322bfloat16\_up
--------------------------------------




void `__bang_tf322bfloat16_up`(bfloat16\_t \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `bfloat16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322bfloat16\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.378. \_\_bang\_tf322float
-------------------------------




void `__bang_tf322float`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322float(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.379. \_\_bang\_tf322float\_dn
-----------------------------------




void `__bang_tf322float_dn`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `float` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322float\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.380. \_\_bang\_tf322float\_oz
-----------------------------------




void `__bang_tf322float_oz`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `float` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322float\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.381. \_\_bang\_tf322float\_rd
-----------------------------------




void `__bang_tf322float_rd`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `float` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322float\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.382. \_\_bang\_tf322float\_rm
-----------------------------------




void `__bang_tf322float_rm`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `float` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322float\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.383. \_\_bang\_tf322float\_rn
-----------------------------------




void `__bang_tf322float_rn`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `float` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322float\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.384. \_\_bang\_tf322float\_tz
-----------------------------------




void `__bang_tf322float_tz`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322float\_tz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.385. \_\_bang\_tf322float\_up
-----------------------------------




void `__bang_tf322float_up`(float \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `float` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322float\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.386. \_\_bang\_tf322half
------------------------------




void `__bang_tf322half`(half \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322half(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.387. \_\_bang\_tf322half\_dn
----------------------------------




void `__bang_tf322half_dn`(half \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `half` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322half\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.388. \_\_bang\_tf322half\_oz
----------------------------------




void `__bang_tf322half_oz`(half \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `half` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322half\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.389. \_\_bang\_tf322half\_rd
----------------------------------




void `__bang_tf322half_rd`(half \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `half` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322half\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.390. \_\_bang\_tf322half\_rm
----------------------------------




void `__bang_tf322half_rm`(half \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `half` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322half\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.391. \_\_bang\_tf322half\_rn
----------------------------------




void `__bang_tf322half_rn`(half \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `half` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322half\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.392. \_\_bang\_tf322half\_tz
----------------------------------




void `__bang_tf322half_tz`(half \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322half\_tz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.393. \_\_bang\_tf322half\_up
----------------------------------




void `__bang_tf322half_up`(half \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `half` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(half \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ half dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322half\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(half), NRAM2GDRAM);
}

```













3.30.394. \_\_bang\_tf322int16
-------------------------------




void `__bang_tf322int16`(int16\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int16(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.395. \_\_bang\_tf322int16\_dn
-----------------------------------




void `__bang_tf322int16_dn`(int16\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int16\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.396. \_\_bang\_tf322int16\_oz
-----------------------------------




void `__bang_tf322int16_oz`(int16\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int16\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.397. \_\_bang\_tf322int16\_rd
-----------------------------------




void `__bang_tf322int16_rd`(int16\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int16\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.398. \_\_bang\_tf322int16\_rm
-----------------------------------




void `__bang_tf322int16_rm`(int16\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int16\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.399. \_\_bang\_tf322int16\_rn
-----------------------------------




void `__bang_tf322int16_rn`(int16\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int16\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.400. \_\_bang\_tf322int16\_tz
-----------------------------------




void `__bang_tf322int16_tz`(int16\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int16\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.401. \_\_bang\_tf322int16\_up
-----------------------------------




void `__bang_tf322int16_up`(int16\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int16\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.402. \_\_bang\_tf322int32
-------------------------------




void `__bang_tf322int32`(int32\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int32(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.403. \_\_bang\_tf322int32\_dn
-----------------------------------




void `__bang_tf322int32_dn`(int32\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int32\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int32\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.404. \_\_bang\_tf322int32\_oz
-----------------------------------




void `__bang_tf322int32_oz`(int32\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int32\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int32\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.405. \_\_bang\_tf322int32\_rd
-----------------------------------




void `__bang_tf322int32_rd`(int32\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int32\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int32\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.406. \_\_bang\_tf322int32\_rm
-----------------------------------




void `__bang_tf322int32_rm`(int32\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int32\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int32\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.407. \_\_bang\_tf322int32\_rn
-----------------------------------




void `__bang_tf322int32_rn`(int32\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int32\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int32\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.408. \_\_bang\_tf322int32\_tz
-----------------------------------




void `__bang_tf322int32_tz`(int32\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.409. \_\_bang\_tf322int32\_up
-----------------------------------




void `__bang_tf322int32_up`(int32\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int32\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int32\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.410. \_\_bang\_tf322int4
------------------------------




void `__bang_tf322int4`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int4x2\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int4(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int4x2\_t), NRAM2GDRAM);
}

```













3.30.411. \_\_bang\_tf322int4\_dn
----------------------------------




void `__bang_tf322int4_dn`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int4x2\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int4\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int4x2\_t), NRAM2GDRAM);
}

```













3.30.412. \_\_bang\_tf322int4\_oz
----------------------------------




void `__bang_tf322int4_oz`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int4x2\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int4\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int4x2\_t), NRAM2GDRAM);
}

```













3.30.413. \_\_bang\_tf322int4\_rd
----------------------------------




void `__bang_tf322int4_rd`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int4x2\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int4\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int4x2\_t), NRAM2GDRAM);
}

```













3.30.414. \_\_bang\_tf322int4\_rm
----------------------------------




void `__bang_tf322int4_rm`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int4x2\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int4\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int4x2\_t), NRAM2GDRAM);
}

```













3.30.415. \_\_bang\_tf322int4\_rn
----------------------------------




void `__bang_tf322int4_rn`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int4x2\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int4\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int4x2\_t), NRAM2GDRAM);
}

```













3.30.416. \_\_bang\_tf322int4\_tz
----------------------------------




void `__bang_tf322int4_tz`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int4x2\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int4\_tz(dst\_nram, src\_nram, LEN ,FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int4x2\_t), NRAM2GDRAM);
}

```













3.30.417. \_\_bang\_tf322int4\_up
----------------------------------




void `__bang_tf322int4_up`(int4x2\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int4x2\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int4\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int4x2\_t), NRAM2GDRAM);
}

```













3.30.418. \_\_bang\_tf322int8
------------------------------




void `__bang_tf322int8`(int8\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int8(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.419. \_\_bang\_tf322int8\_dn
----------------------------------




void `__bang_tf322int8_dn`(int8\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int8\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int8\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.420. \_\_bang\_tf322int8\_oz
----------------------------------




void `__bang_tf322int8_oz`(int8\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int8\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int8\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.421. \_\_bang\_tf322int8\_rd
----------------------------------




void `__bang_tf322int8_rd`(int8\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int8\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int8\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.422. \_\_bang\_tf322int8\_rm
----------------------------------




void `__bang_tf322int8_rm`(int8\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int8\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int8\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.423. \_\_bang\_tf322int8\_rn
----------------------------------




void `__bang_tf322int8_rn`(int8\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int8\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int8\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.424. \_\_bang\_tf322int8\_tz
----------------------------------




void `__bang_tf322int8_tz`(int8\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int8\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.425. \_\_bang\_tf322int8\_up
----------------------------------




void `__bang_tf322int8_up`(int8\_t \**dst*, *const* float \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `tf32` to `int8\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322int8\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.426. \_\_bang\_tf322uchar
-------------------------------




void `__bang_tf322uchar`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322uchar(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.427. \_\_bang\_tf322uchar\_dn
-----------------------------------




void `__bang_tf322uchar_dn`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322uchar\_dn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.428. \_\_bang\_tf322uchar\_oz
-----------------------------------




void `__bang_tf322uchar_oz`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `unsigned char` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_520`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322uchar\_oz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.429. \_\_bang\_tf322uchar\_rd
-----------------------------------




void `__bang_tf322uchar_rd`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `unsigned char` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322uchar\_rd(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.430. \_\_bang\_tf322uchar\_rm
-----------------------------------




void `__bang_tf322uchar_rm`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `unsigned char` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322uchar\_rm(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.431. \_\_bang\_tf322uchar\_rn
-----------------------------------




void `__bang_tf322uchar_rn`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `unsigned char` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322uchar\_rn(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.432. \_\_bang\_tf322uchar\_tz
-----------------------------------




void `__bang_tf322uchar_tz`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `unsigned char` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_520`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322uchar\_tz(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.433. \_\_bang\_tf322uchar\_up
-----------------------------------




void `__bang_tf322uchar_up`(unsigned char \**dst*, *const* float \**src*, unsigned int *count*)  

This function converts type of `<src>` from `tf32` to `unsigned char` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(unsigned char \*dst, float \*src) {
  \_\_nram\_\_ unsigned char dst\_nram[LEN];
  \_\_nram\_\_ float src\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_tf322uchar\_up(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.434. \_\_bang\_uchar2bfloat16
-----------------------------------




void `__bang_uchar2bfloat16`(bfloat16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*)  

This function converts type of `<src>` from `unsigned char` to `bfloat16\_t` element-wisely and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(bfloat16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ bfloat16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2bfloat16(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(bfloat16\_t), NRAM2GDRAM);
}

```













3.30.435. \_\_bang\_uchar2float
--------------------------------




void `__bang_uchar2float`(float \**dst*, *const* unsigned char \**src*, unsigned int *count*)  

This function converts type of `<src>` from `unsigned char` to `float` element-wisely and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(unsigned char), GDRAM2NRAM);
  \_\_bang\_uchar2float(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.436. \_\_bang\_uchar2half
-------------------------------




void `__bang_uchar2half`(half \**dst*, *const* unsigned char \**src*, unsigned int *src\_count*)  




void `__bang_uchar2half`(half \**dst*, *const* unsigned char \**src*, unsigned int *src\_count*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `unsigned char` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.
The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements in round-to-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(unsigned char);
* `<src>` cannot be overlapped with `<dst>`;
* \(<src\\_stride> \div sizeof(unsigned char) \ge <src\\_count>\) if `<src\_stride>` is greater than zero.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SRC\_STRIDE 160
#define DST\_STRIDE 320
#define LEN 128
#define SEG\_NUM 20

\_\_mlu\_entry\_\_ void kernel(half \*dst, unsigned char \*src, int size) {
  \_\_nram\_\_ unsigned char src\_tmp[SRC\_STRIDE \* SEG\_NUM + LEN];
  \_\_nram\_\_ half dst\_tmp[DST\_STRIDE / sizeof(half) \* SEG\_NUM + LEN];
  \_\_memcpy(src\_tmp, src, size, GDRAM2NRAM);
  \_\_bang\_uchar2half(dst\_tmp, src\_tmp, LEN, DST\_STRIDE, SRC\_STRIDE, SEG\_NUM);
  \_\_memcpy(dst, dst\_tmp, (DST\_STRIDE \* SEG\_NUM + LEN \* sizeof(half)), NRAM2GDRAM);
}

```













3.30.437. \_\_bang\_uchar2int16
--------------------------------




void `__bang_uchar2int16`(int16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int16(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.438. \_\_bang\_uchar2int16\_dn
------------------------------------




void `__bang_uchar2int16_dn`(int16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int16\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int16\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.439. \_\_bang\_uchar2int16\_oz
------------------------------------




void `__bang_uchar2int16_oz`(int16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int16\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int16\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.440. \_\_bang\_uchar2int16\_rd
------------------------------------




void `__bang_uchar2int16_rd`(int16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int16\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int16\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.441. \_\_bang\_uchar2int16\_rm
------------------------------------




void `__bang_uchar2int16_rm`(int16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int16\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int16\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.442. \_\_bang\_uchar2int16\_rn
------------------------------------




void `__bang_uchar2int16_rn`(int16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int16\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int16\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.443. \_\_bang\_uchar2int16\_tz
------------------------------------




void `__bang_uchar2int16_tz`(int16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(unsigned char), GDRAM2NRAM);
  \_\_bang\_uchar2int16\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.444. \_\_bang\_uchar2int16\_up
------------------------------------




void `__bang_uchar2int16_up`(int16\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int16\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int16\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int16\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int16\_t), NRAM2GDRAM);
}

```













3.30.445. \_\_bang\_uchar2int32
--------------------------------




void `__bang_uchar2int32`(int32\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int32(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.446. \_\_bang\_uchar2int32\_dn
------------------------------------




void `__bang_uchar2int32_dn`(int32\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int32\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int32\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.447. \_\_bang\_uchar2int32\_oz
------------------------------------




void `__bang_uchar2int32_oz`(int32\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int32\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int32\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.448. \_\_bang\_uchar2int32\_rd
------------------------------------




void `__bang_uchar2int32_rd`(int32\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int32\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int32\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.449. \_\_bang\_uchar2int32\_rm
------------------------------------




void `__bang_uchar2int32_rm`(int32\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int32\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int32\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.450. \_\_bang\_uchar2int32\_rn
------------------------------------




void `__bang_uchar2int32_rn`(int32\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int32\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int32\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.451. \_\_bang\_uchar2int32\_tz
------------------------------------




void `__bang_uchar2int32_tz`(int32\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int32\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.452. \_\_bang\_uchar2int32\_up
------------------------------------




void `__bang_uchar2int32_up`(int32\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int32\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int32\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int32\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int32\_t), NRAM2GDRAM);
}

```













3.30.453. \_\_bang\_uchar2int4
-------------------------------




void `__bang_uchar2int4`(int4x2\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int4x2\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int4(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.454. \_\_bang\_uchar2int4\_dn
-----------------------------------




void `__bang_uchar2int4_dn`(int4x2\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int4x2\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int4\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.455. \_\_bang\_uchar2int4\_oz
-----------------------------------




void `__bang_uchar2int4_oz`(int4x2\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int4x2\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int4\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.456. \_\_bang\_uchar2int4\_rd
-----------------------------------




void `__bang_uchar2int4_rd`(int4x2\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int4x2\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int4\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.457. \_\_bang\_uchar2int4\_rm
-----------------------------------




void `__bang_uchar2int4_rm`(int4x2\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int4x2\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int4\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.458. \_\_bang\_uchar2int4\_rn
-----------------------------------




void `__bang_uchar2int4_rn`(int4x2\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int4x2\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int4\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.459. \_\_bang\_uchar2int4\_tz
-----------------------------------




void `__bang_uchar2int4_tz`(int4x2\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int4x2\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(nt4x2\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int4\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.460. \_\_bang\_uchar2int4\_up
-----------------------------------




void `__bang_uchar2int4_up`(int4x2\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int4x2\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero and divisible by 2;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int4x2\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int4x2\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int4\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(char), NRAM2GDRAM);
}

```













3.30.461. \_\_bang\_uchar2int8
-------------------------------




void `__bang_uchar2int8`(int8\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \div 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int8(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.462. \_\_bang\_uchar2int8\_dn
-----------------------------------




void `__bang_uchar2int8_dn`(int8\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int8\_t` element-wisely in round-down mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \div 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int8\_dn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.463. \_\_bang\_uchar2int8\_oz
-----------------------------------




void `__bang_uchar2int8_oz`(int8\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int8\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \div 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int8\_oz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.464. \_\_bang\_uchar2int8\_rd
-----------------------------------




void `__bang_uchar2int8_rd`(int8\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int8\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \div 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int8\_rd(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.465. \_\_bang\_uchar2int8\_rm
-----------------------------------




void `__bang_uchar2int8_rm`(int8\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int8\_t` element-wisely in round-math mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \div 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int8\_rm(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.466. \_\_bang\_uchar2int8\_rn
-----------------------------------




void `__bang_uchar2int8_rn`(int8\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int8\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \div 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int8\_rn(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.467. \_\_bang\_uchar2int8\_tz
-----------------------------------




void `__bang_uchar2int8_tz`(int8\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \div 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(unsigned char), GDRAM2NRAM);
  \_\_bang\_uchar2int8\_tz(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.468. \_\_bang\_uchar2int8\_up
-----------------------------------




void `__bang_uchar2int8_up`(int8\_t \**dst*, *const* unsigned char \**src*, unsigned int *count*, int *fix\_position*)  

This function converts type of `<src>` from `unsigned char` to `int8\_t` element-wisely in round-up mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \div 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` can be overlapped with `<dst>`;
* `<fix\_position>` must be in the range `[-127,127]`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define LEN 128
#define FIX\_POSITION 2

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ int8\_t dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2int8\_up(dst\_nram, src\_nram, LEN, FIX\_POSITION);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(int8\_t), NRAM2GDRAM);
}

```













3.30.469. \_\_bang\_uchar2tf32
-------------------------------




void `__bang_uchar2tf32`(float \**dst*, *const* unsigned char \**src*, unsigned int *count*)  

This function converts type of `<src>` from `unsigned char` to `tf32` element-wisely and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<count>` must be greater than zero;
* `<src>` cannot be overlapped with `<dst>`.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 520`;
* CNCC Version: `cncc --version >= 4.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_50`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_5xx`.






**Example**
```
#include <bang.h>

#define LEN 128

\_\_mlu\_entry\_\_ void kernel(float \*dst, unsigned char \*src) {
  \_\_nram\_\_ unsigned char src\_nram[LEN];
  \_\_nram\_\_ float dst\_nram[LEN];
  \_\_memcpy(src\_nram, src, LEN \* sizeof(char), GDRAM2NRAM);
  \_\_bang\_uchar2tf32(dst\_nram, src\_nram, LEN);
  \_\_memcpy(dst, dst\_nram, LEN \* sizeof(float), NRAM2GDRAM);
}

```













3.30.470. \_\_bang\_uint162float
---------------------------------




void `__bang_uint162float`(float \**dst*, *const* uint16\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `uint16\_t` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, uint16\_t \*src) {
  \_\_nram\_\_ uint16\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_uint162float(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(uint16\_t), NRAM2GDRAM);
}

```













3.30.471. \_\_bang\_uint322float
---------------------------------




void `__bang_uint322float`(float \**dst*, *const* uint32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `uint32\_t` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` except 520;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx` except `tp\_520`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, uint32\_t \*src) {
  \_\_nram\_\_ uint32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_uint322float(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(uint32\_t), NRAM2GDRAM);
}

```













3.30.472. \_\_bang\_uint82float
--------------------------------




void `__bang_uint82float`(float \**dst*, *const* uint8\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `uint8\_t` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 4.6.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, uint8\_t \*src) {
  \_\_nram\_\_ uint8\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_uint82float(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(uint8\_t), NRAM2GDRAM);
}

```

















4. Deprecated Built-in Functions
=================================



4.1. \_\_bang\_add\_const
--------------------------




void `__bang_add_const`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_add_const`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function adds `<value>` to `<elem\_count>` elements of `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_add\_scalar instead.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_add\_const(c\_tmp, a\_tmp, b, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













4.2. \_\_bang\_avgpool
-----------------------




void `__bang_avgpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*)  




void `__bang_avgpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_avgpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  




void `__bang_avgpool`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_avgpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_avgpool`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, unsigned int *in\_dh*, unsigned int *in\_dw*, unsigned int *out\_dh*, unsigned int *out\_dw*)  




void `__bang_avgpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  

Performs avgpooling forward propagation operation on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and calculates the average value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The function with dilation is supported on `(m)tp\_3xx` or higher;
* `<dst>` cannot be overlapped with `<src>`;
* In the function without stride, `<stride\_width>` equals `<kernel\_width>` and `<stride\_height>` equals `<kernel\_height>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* `<stride\_height>` and `<stride\_width>` must be greater than 0 if specified;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.
* This function was deprecated from CNCC v4.5.0. Use \_\_bang\_sumpool and \_\_bang\_cycle\_mul instead on (m)tp\_2xx or use \_\_bang\_sumpool and \_\_bang\_mul\_scalar instead on (m)tp\_3xx or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define CHANNELS 64
#define HEIGHT 9
#define WIDTH 9
#define KERNEL\_HEIGHT 3
#define KERNEL\_WIDTH 3
#define BOTTOM\_DATA\_COUNT ((CHANNELS) \* (WIDTH) \* (HEIGHT))
#define TOP\_DATA\_COUNT \
  ((CHANNELS) \* (HEIGHT / KERNEL\_HEIGHT) \* (WIDTH / KERNEL\_WIDTH))

\_\_mlu\_entry\_\_ void avgPoolingKernel(half\* bottom\_data, half\* top\_data,
                                    int channels, int height, int width,
                                    int pooled\_height, int pooled\_width) {
  \_\_nram\_\_ half a\_tmp[BOTTOM\_DATA\_COUNT];
  \_\_nram\_\_ half b\_tmp[TOP\_DATA\_COUNT];
  \_\_memcpy(a\_tmp, bottom\_data, BOTTOM\_DATA\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_avgpool(b\_tmp, a\_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL\_HEIGHT, KERNEL\_WIDTH);
  \_\_memcpy(top\_data, b\_tmp, TOP\_DATA\_COUNT \* sizeof(half), NRAM2GDRAM);
}

```













4.3. \_\_bang\_avgpool\_bp
---------------------------




void `__bang_avgpool_bp`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  




void `__bang_avgpool_bp`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  




void `__bang_avgpool_bp`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*, mluPoolBPOverlap *overlap* = OVERLAP\_ACC)  

Performs avgpooling backward propagation operation on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor, with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and calculates the average value in each window. `<overlap>` indicates the type of overlap options. `<overlap>` is assigned to an enumerated type called `mluPoolBPOverlap` that contains 2 enumerators listed in the table below. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded.




Table 4.1 Semantics of `mluPoolBPOverlap`



| `mluPoolBPOverlap` Type | Semantic |
| --- | --- |
| `OVERLAP\_ACC` | Accumulates the overlap parts of the output. |
| `OVERLAP\_COVER` | Covers the overlap parts of the output. |








See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination tensor whose data layout is HWC.
* `[in] src`: The address of source tensor whose data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of output feature map.
* `[in] width`: The width of output feature map.
* `[in] kernel\_height`: The height of kernel.
* `[in] kernel\_width`: The width of kernel.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] overlap`: The type of overlap options.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* The default `mluPoolBPOverlap` option is `OVERLAP\_ACC`;
* `[input\_height]` and `[input\_width]` of `<src>` must be greater than 0;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<stride\_height>` and `<stride\_width>` must be greater than 0;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\).
* This function was deprecated from CNCC v4.5.0. Use \_\_bang\_sumpool\_bp and \_\_bang\_cycle\_mul instead on (m)tp\_2xx or use \_\_bang\_sumpool\_bp and \_\_bang\_mul\_scalar instead on (m)tp\_3xx or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
 #include <bang.h>

 \_\_mlu\_entry\_\_ void PoolAvgBpKernel(half\* output, half\* input,
                                    int channels, int out\_height,
                                    int out\_width, int kernel\_height,
                                    int kernel\_width, int stride\_width,
                                    int stride\_height) {
   \_\_nram\_\_ half a\_tmp[INPUT\_COUNT];
   \_\_nram\_\_ half b\_tmp[OUTPUT\_COUNT];
   \_\_memcpy(b\_tmp, output, OUTPUT\_COUNT \* sizeof(half), GDRAM2NRAM);
   \_\_memcpy(a\_tmp, input, INPUT\_COUNT \* sizeof(half), GDRAM2NRAM);
   \_\_bang\_avgpool\_bp(b\_tmp, a\_tmp, channels, out\_height, out\_width,
                     kernel\_height, kernel\_width, stride\_width,
                     stride\_height);
   \_\_memcpy(output, b\_tmp, OUTPUT\_COUNT \* sizeof(half), NRAM2GDRAM);
}

```













4.4. \_\_bang\_band
--------------------




void `__bang_band`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_band`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  

Applies bit-wise AND operation on two vectors.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src0>`;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int` and `short` are supported on `(m)tp\_3xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_band instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(int\* c, int\* a, int\* b) {
  \_\_nram\_\_ int a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ int c\_tmp[DATA\_SIZE];
  \_\_nram\_\_ int b\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(int), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(int), GDRAM2NRAM);
  \_\_bang\_band(c\_tmp, a\_tmp, b\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(int), NRAM2GDRAM);
}

```













4.5. \_\_bang\_bnot
--------------------




void `__bang_bnot`(int \**dst*, *const* int \**src*, unsigned int *elem\_count*)  




void `__bang_bnot`(short \**dst*, *const* short \**src*, unsigned int *elem\_count*)  

Applies bit-wise NOT operation on a vector.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* `int` and `short` are supported on `(m)tp\_3xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_bnot instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.6. \_\_bang\_bor
-------------------




void `__bang_bor`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_bor`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  

Applies bit-wise OR operation on two vectors.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src0>`;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int` and `short` are supported on `(m)tp\_3xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_bor instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.7. \_\_bang\_bxor
--------------------




void `__bang_bxor`(int \**dst*, *const* int \**src0*, *const* int \**src1*, unsigned int *elem\_count*)  




void `__bang_bxor`(short \**dst*, *const* short \**src0*, *const* short \**src1*, unsigned int *elem\_count*)  

Applies bit-wise XOR operation on two vectors.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of first source vector.
* `[in] src1`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src0>`;
* `<src0>`, `<src1>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int` and `short` are supported on `(m)tp\_3xx` or higher;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src0>`, `<src1>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_bxor instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.8. \_\_bang\_char2int
------------------------




void `__bang_char2int`(int32\_t \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_int82int32 instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_char2int(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













4.9. \_\_bang\_char2short
--------------------------




void `__bang_char2short`(int16\_t \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int8\_t` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_int82int16 instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int8\_t \*src) {
  \_\_nram\_\_ int8\_t src\_tmp[SIZE];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int8\_t), GDRAM2NRAM);
  \_\_bang\_char2short(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













4.10. \_\_bang\_collect
------------------------




void `__bang_collect`(half \**dst*, *const* half \**src*, *const* half \**mask*, unsigned int *elem\_count*)  




void `__bang_collect`(float \**dst*, *const* float \**src*, *const* float \**mask*, unsigned int *elem\_count*)  

Selects number in one vector according to the corresponding values in another vector. The elements in `<src>` will be selected and stored continuously if corresponding elements in `<mask>` are not equal to zero. The result is the selected elements. The selected elements will be stored continuously.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] mask`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* The `<src>`, `<mask>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be a multiple of 128 bytes on `(m)tp\_2xx`;
* The address of `<src>`, `<mask>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* On `(m)tp\_2xx`, if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;
* On `(m)tp\_2xx`, the size of `<dst>` cannot be smaller than the size of `<src>` and if the selected elements(including pad) does not fill the entire `<dst>` space, the remaining data in `<dst>` may also be changed;
* This function was deprecated from CNCC v4.1.0. Use \_\_bang\_filter instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.11. \_\_bang\_collect\_bitindex
----------------------------------




void `__bang_collect_bitindex`(half \**dst*, *const* half \**src*, *const* void \**bitmask*, unsigned int *elem\_count*)  




void `__bang_collect_bitindex`(float \**dst*, *const* float \**src*, *const* void \**bitmask*, unsigned int *elem\_count*)  

Selects the corresponding elements in `<src>` according to `<bitmask>`. The elements in `<src>` will be saved to `<dst>`, if corresponding bit in `<bitmask>` is 1. All selected elements will be stored continuously in `<dst>`. The selected elements will be stored continuously. The behavior is illustrated in the figure below, in this example, `<bitmask>` is 0x41100000.




Fig. 4.1 The Calculation Process of Floating-point Type `\_\_bang\_collect\_bitindex`












**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] bitmask`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* The `<src>`, `<bitmask>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<bitmask>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` must be divisible by 512 on `(m)tp\_2xx`, and divisible by 8 on `mtp\_372` and `tp\_322`;
* On `(m)tp\_2xx`, if the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;
* On `(m)tp\_2xx`, the size of `<dst>` cannot be smaller than the size of `<src>` and if the selected elements(including pad) does not fill the entire `<dst>` space, the remaining data in `<dst>` may also be changed;
* This function was deprecated from CNCC v4.1.0. Use \_\_bang\_filter\_bitindex instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.12. \_\_bang\_count
----------------------




void `__bang_count`(unsigned int \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_count`(unsigned int \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Counts the number of non-zero elements in the input vector.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The size of `<dst>` is at least 128 bytes on `(m)tp\_2xx`, and at least 4 bytes on `(m)tp\_3xx`;
* The number of non-zero elements is stored in the first 4 bytes of `<dst>`. The remaining 124 bytes of `<dst>` on `(m)tp\_2xx` will be set to 0. The remaining part of `<dst>` will not be changed on `(m)tp\_3xx`;
* `<dst>` can be overlapped with `<src>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_count instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(unsigned int\* dst, float\* src, unsigned int elem\_count) {
  \_\_bang\_count(dst, src, elem\_count);
  unsigned int counter = ((unsigned int\*)dst)[0];
}

```













4.13. \_\_bang\_count\_bitindex
--------------------------------




void `__bang_count_bitindex`(unsigned int \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_count_bitindex`(unsigned int \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Counts the number of non-zero bit in the input vector.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* The size of `<dst>` is at least 128 bytes on `(m)tp\_2xx`, and at least 4 bytes on `(m)tp\_3xx`;
* The number of non-zero bits is stored in the first 4 bytes of `<dst>`. The remaining 124 bytes of `<dst>` on `(m)tp\_2xx` will be set to 0. The remaining part of `<dst>` will not be changed on `(m)tp\_3xx`;
* `<dst>` can be overlapped with `<src>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_count\_bitindex instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(unsigned int\* dst, float\* src, unsigned int elem\_count) {
  \_\_bang\_count\_bitindex(dst, src, elem\_count);
  unsigned int counter = ((unsigned int\*)dst)[0];
}

```













4.14. \_\_bang\_cycle\_band
----------------------------




void `__bang_cycle_band`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_band`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies bit-wise AND operation with the corresponding element in `<seg>`. The result is assigned to `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int` and `short` are supported on `(m)tp\_3xx` or higher;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322`;
* This function was deprecated from CNCC v4.0.0. Use corresponding char function instead.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.15. \_\_bang\_cycle\_bor
---------------------------




void `__bang_cycle_bor`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_bor`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies bit-wise OR operation with the corresponding element in `<seg>`. The result is assigned to `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int` and `short` are supported on `(m)tp\_3xx` or higher;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322`;
* This function was deprecated from CNCC v4.0.0. Use corresponding char function instead.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.16. \_\_bang\_cycle\_bxor
----------------------------




void `__bang_cycle_bxor`(int \**dst*, *const* int \**src*, *const* int \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  




void `__bang_cycle_bxor`(short \**dst*, *const* short \**src*, *const* short \**seg*, unsigned int *src\_elem\_count*, unsigned int *seg\_elem\_count*)  

Divides `<src>` into `<src\_elem\_count>` / `<seg\_elem\_count>` parts. Each element in each part applies bit-wise XOR operation with the corresponding element in `<seg>`. The result is assigned to `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] seg`: The address of second source vector.
* `[in] src\_elem\_count`: The number of elements in `<src>` vector.
* `[in] seg\_elem\_count`: The number of elements in `<seg>` vector.



**Return*** `void`.






**Remark*** `<dst>` can be overlapped with `<src>`;
* `<src>`, `<seg>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `int` and `short` are supported on `(m)tp\_3xx` or higher;
* `<src\_elem\_count>` must be divisible by `<seg\_elem\_count>`;
* `<src\_elem\_count>` and `<seg\_elem\_count>` must be greater than zero;
* `<seg\_elem\_count> \* sizeof(type)` cannot be greater than 65536 on `tp\_322`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_cycle\_bxor instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.17. \_\_bang\_div
--------------------




void `__bang_div`(half \**dst*, *const* half \**src0*, *const* half \**src1*, half \**src\_addition*, unsigned int *elem\_count*)  




void `__bang_div`(float \**dst*, *const* float \**src0*, *const* float \**src1*, float \**src\_addition*, unsigned int *elem\_count*)  

This function performs division operation element-wisely on `<src0>` and `<src1>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Div Operation Function for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src0`: The address of the first source vector.
* `[in] src1`: The address of the second source vector.
* `[in] src\_addition`: The address of additional vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<src0>`, `<src1>`, `<dst>` and `<src\_addition>` must point to `\_\_nram\_\_` address space;
* `<src0>`, `<src1>`, `<dst>` and `<src\_addition>` cannot be overlapped;
* `<elem\_count> \* sizeof(type)` must be divisible by 128;
* The size of `<src\_addition>` vector is identical to the size of `<src0>`, `<src1>` and `<dst>`;
* `<elem\_count>` must be greater than zero;
* For higher precision, use surpass function \_\_bang\_div on `tp\_322` instead;
* For higher precision, use \_\_bang\_recip and \_\_bang\_mul on `mtp\_372` instead;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_div instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float\* b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float b\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float addition[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_memcpy(b\_tmp, b, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_div(c\_tmp, a\_tmp, b\_tmp, src\_addition, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













4.18. \_\_bang\_fabsmax
------------------------




void `__bang_fabsmax`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_fabsmax`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_fabsmax`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function performs calculation of the absolute value of `<src>` element-wisely, then finds the maximum absolute value and its position index, and saves the maximum absolute value and its index in `<dst>`. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* The size of `<dst>` for `half` and `bfloat16\_t` type is at least 10 bytes. The first 2 bytes of `<dst>` are used to record the maximum absolute value, and the next 4 bytes are used to record the index of maximum absolute value in `<src>`, the next 4 bytes are written to zero;
* The size of `<dst>` for `float` type is at least 12 bytes. The first 4 bytes of `<dst>` are used to record the maximum absolute value, the next 4 bytes are used to record the index of maximum absolute value in `<src>`, and the next 4 bytes are written to zero;
* When `<src>` vector has multiple same maximum absolute values, the first one and its index will be stored;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.5.0.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define RES\_ELEM\_NUM 16
#define ELEM\_NUM 128

\_\_mlu\_entry\_\_ void kernel\_fabs(float\* dst, float \*src) {
  \_\_nram\_\_ float dst\_nram[RES\_ELEM\_NUM];
  \_\_nram\_\_ float src\_nram[ELEM\_NUM];
  \_\_memcpy(src\_nram, src, ELEM\_NUM \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_fabsmax(dst\_nram, src\_nram, ELEM\_NUM);
  \_\_bang\_printf("value = %f, index = %d\n", dst\_nram[0], dst\_nram[1]);
  \_\_memcpy(dst, dst\_nram, RES\_ELEM\_NUM \* sizeof(float), NRAM2GDRAM);
}

```













4.19. \_\_bang\_fabsmin
------------------------




void `__bang_fabsmin`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_fabsmin`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *elem\_count*)  




void `__bang_fabsmin`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

This function performs calculation of the absolute value of `<src>` element-wisely, then finds the minimum absolute value and its position index, and saves the minimum absolute value and its index in `<dst>`. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<dst>` and `<src>` must point to `\_\_nram\_\_` address space;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* The size of `<dst>` for `half` and `bfloat16\_t` type is at least 10 bytes. The first 2 bytes of `<dst>` are used to record the minimum absolute value, the next 4 bytes are used to record the index of minimum absolute value in `<src>`, and the next 4 bytes are written to zero;
* The size of `<dst>` for `float` type is at least 12 bytes. The first 4 bytes of `<dst>` are used to record the minimum absolute value, the next 4 bytes are used to record the index of minimum absolute value in `<src>`, and the next 4 bytes are written to zero;
* When `<src>` vector has multiple same minimum absolute values, the first one and its index will be stored;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.5.0.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_fabsmax for more details.













4.20. \_\_bang\_findfirst1
---------------------------




void `__bang_findfirst1`(unsigned int \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_findfirst1`(unsigned int \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Finds the first non-zero data in the values of `<src>`, and stores the index of the first non-zero data in the first element of `<dst>`. If `<src>` is all zero, stores 0xffff-ffff.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof (type)` must be divisible by 128 on `(m)tp\_2xx`;
* The total number of bytes of `<dst>` is at least 128 on `(m)tp\_2xx`, and at least 4 on `(m)tp\_3xx`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_findfirst1 instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 64

\_\_mlu\_entry\_\_ void kernel(half\* c, half\* a) {
  \_\_nram\_\_ half a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ half c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_findfirst1((uint32\_t\*)c\_tmp, a\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(half), NRAM2GDRAM);
}

```













4.21. \_\_bang\_findlast1
--------------------------




void `__bang_findlast1`(unsigned int \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_findlast1`(unsigned int \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Finds the last non-zero data in the values of `<src>`, and stores the index of the last non-zero data in `<dst>`. If `<src>` is all zero, stores 0xffff-ffff.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<elem\_count> \* sizeof (type)` must be divisible by 128 on `(m)tp\_2xx`;
* The total number of bytes of `<dst>` is at least 128 on `(m)tp\_2xx`, and at least 4 on `(m)tp\_3xx`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_findlast1 instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.22. \_\_bang\_fix82half
--------------------------




void `__bang_fix82half`(half \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  




void `__bang_fix82half`(half \**dst*, *const* int8\_t \**src*, unsigned int *src\_count*, int *fix\_position*, unsigned int *dst\_stride*, unsigned int *src\_stride*, unsigned int *segnum*)  

This function converts type of `<src>` from `int8\_t` to `half` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.


The data type conversion process is illustrated by Figure The Process of Conversion with Stride. `<src>` includes `<segnum> + 1` blocks, and each block consists of `<src\_stride>` bytes. `<dst>` includes `<segnum> + 1` blocks, and each block consists of `<dst\_stride>` bytes. In each block of `<src>`, this function converts first `<src\_count>` elements according to `<fix\_position>` in round-to-zero mode, and saves the result in blocks in `<dst>` sequentially. If `<src\_stride>` is zero, this function only converts the first block `<segnum> + 1` times.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).
* `[in] dst\_stride`: The destination stride in bytes.
* `[in] src\_stride`: The source stride in bytes.
* `[in] segnum`: The number of segments minus one.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` cannot be overlapped with `<dst>`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<dst\_stride>` must be greater than or equal to `<src\_count> \* sizeof(half)`, and divisible by 64 on `(m)tp\_2xx`, and divisible by sizeof(half) on `(m)tp\_3xx` or higher;
* `<src\_stride>` must be divisible by sizeof(int8\_t);
* `<src\_stride>` \(\div\) `sizeof(int8\_t)` \(\ge\) `<src\_count>` if `<src\_stride>` is greater than zero;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_int82half instead.






**Instruction Pipeline*** Execute in Move instruction pipeline if the conversion function has `<src\_stride>` and `<dst\_stride>`;
* Execute in Compute instruction pipeline, otherwise.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SRC\_STRIDE 160
#define DST\_STRIDE 320
#define LEN 128
#define SEG\_NUM 20
#define POS 5

\_\_mlu\_entry\_\_ void kernel(half \*dst, int8\_t \*src, int size) {
  \_\_nram\_\_ int8\_t src\_tmp[SRC\_STRIDE \* SEG\_NUM + LEN];
  \_\_nram\_\_ half dst\_tmp[DST\_STRIDE / sizeof(half) \* SEG\_NUM + LEN];
  \_\_memcpy(src\_tmp, src, size, GDRAM2NRAM);
  \_\_bang\_fix82half(dst\_tmp, src\_tmp, LEN, POS, DST\_STRIDE, SRC\_STRIDE, SEG\_NUM);
  \_\_memcpy(dst, dst\_tmp, (DST\_STRIDE \* SEG\_NUM + LEN \* sizeof(half)), NRAM2GDRAM);
}

```













4.23. \_\_bang\_float2int\_dn
------------------------------




void `__bang_float2int_dn`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_float2int32\_dn instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, float \*src) {
  \_\_nram\_\_ float src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_float2int\_dn(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













4.24. \_\_bang\_float2int\_oz
------------------------------




void `__bang_float2int_oz`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_float2int32\_oz instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int\_dn for more details.













4.25. \_\_bang\_float2int\_rd
------------------------------




void `__bang_float2int_rd`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-nearest-off-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_float2int32\_rd instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int\_dn for more details.













4.26. \_\_bang\_float2int\_rm
------------------------------




void `__bang_float2int_rm`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-math mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_float2int32\_rm instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int\_dn for more details.













4.27. \_\_bang\_float2int\_rn
------------------------------




void `__bang_float2int_rn`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-nearest-even mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_float2int32\_rn instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int\_dn for more details.













4.28. \_\_bang\_float2int\_tz
------------------------------




void `__bang_float2int_tz`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_float2int32\_tz instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int\_dn for more details.













4.29. \_\_bang\_float2int\_up
------------------------------




void `__bang_float2int_up`(int32\_t \**dst*, *const* float \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `float` to `int32\_t` element-wisely in round-up mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_float2int32\_up instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example*** See the example of \_\_bang\_float2int\_dn for more details.













4.30. \_\_bang\_ge\_const
--------------------------




void `__bang_ge_const`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_ge_const`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function compares `<elem\_count>` elements in `<src>` with `<value>` to determine whether the elements are greater than or equal to `<value>` and saves the result in `<dst>`. If the element of `<src>` is greater than or equal to `<value>`, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of `<src>`. See the table Floating Point Calculation of Stream and Scalar Comparison Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_ge\_scalar instead.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float\* c, float\* a, float b) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_ge\_const(c\_tmp, a\_tmp, b, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













4.31. \_\_bang\_half2char\_dn
------------------------------




void `__bang_half2char_dn`(signed char \**dst*, *const* half \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `signed char` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_half2uchar\_dn instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(signed char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ signed char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2char\_dn(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(signed char), NRAM2GDRAM);
}

```













4.32. \_\_bang\_half2uchar\_dn
-------------------------------




void `__bang_half2uchar_dn`(signed char \**dst*, *const* half \**src*, unsigned int *src\_count*)  

This function converts type of `<src>` from `half` to `unsigned char` element-wisely in round-down mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<src\_count>` must be greater than zero and divisible by 128 on `(m)tp\_2xx`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_half2uchar\_dn instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define SIZE 128

\_\_mlu\_entry\_\_ void kernel(signed char \*dst, half \*src) {
  \_\_nram\_\_ half src\_tmp[SIZE];
  \_\_nram\_\_ signed char dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_half2uchar\_dn(dst\_tmp, src\_tmp, SIZE);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(unsigned char), NRAM2GDRAM);
}

```













4.33. \_\_bang\_int2char
-------------------------




void `__bang_int2char`(int8\_t \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int8\_t` element-wisely round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_int322int8 instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int2char(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













4.34. \_\_bang\_int2float
--------------------------




void `__bang_int2float`(float \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *fix\_position*)  

This function converts type of `<src>` from `int32\_t` to `float` element-wisely in round-to-zero mode and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The elements number of conversion.
* `[in] fix\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<fix\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_count>` must be greater than zero;
* `<fix\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_int322float instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322` ;
* CNCC Version: `cncc --version >= 3.0.0` ;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30` ;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define POS 5

\_\_mlu\_entry\_\_ void kernel(float \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ float dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int2float(dst\_tmp, src\_tmp, SIZE, POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(float), NRAM2GDRAM);
}

```













4.35. \_\_bang\_int2short
--------------------------




void `__bang_int2short`(int16\_t \**dst*, *const* int32\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int32\_t` to `int16\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_int322int16 instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int16\_t \*dst, int32\_t \*src) {
  \_\_nram\_\_ int32\_t src\_tmp[SIZE];
  \_\_nram\_\_ int16\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int32\_t), GDRAM2NRAM);
  \_\_bang\_int2short(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int16\_t), NRAM2GDRAM);
}

```













4.36. \_\_bang\_lock
---------------------




void `__bang_lock`(int *lock\_id\_0*, int *lock\_id\_1*)  

Applies and seize lock\_id.



**Parameters*** `[in] lock\_id\_0`: The first lock id.
* `[in] lock\_id\_1`: The second lock id.



**Return*** `void`.






**Remark*** This function was deprecated from CNCC v4.0.0;
* \_\_bang\_lock is always paired with \_\_bang\_unlock;
* For MLU Core, `lock\_id\_0` should be equal to `lock\_id\_1`;
* For MPU Core, `lock\_id\_0` should be not equal to `lock\_id\_1`;
* \_\_bang\_lock can be used before `\_\_memcpy` from to GDRAM, whose size is larger than 64KB.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx`.






**Example**

Example of \_\_bang\_lock usage in MLU Core is as follows:




```
#include <bang.h>

#define BUFFER\_SIZE 261632

\_\_mlu\_entry\_\_ void add\_kernel(half \*input, half \*output,
                              int copyin\_len, int copyout\_len,
                              int offseta, int offsetb,
                              int offsetc, int tid) {
  \_\_wram\_\_ half temp[BUFFER\_SIZE];
  if (coreId != 0x80) {
    \_\_bang\_lock(0, 0);
  }
  \_\_memcpy(temp, input, 510 \* 512 \* sizeof(half), GDRAM2WRAM);
  if (coreId != 0x80) {
    \_\_bang\_unlock(0, 0);
  }
}

```













4.37. \_\_bang\_maskmove
-------------------------




void `__bang_maskmove`(half \**dst*, *const* half \**src*, *const* half \**mask*, unsigned int *elem\_count*)  




void `__bang_maskmove`(float \**dst*, *const* float \**src*, *const* float \**mask*, unsigned int *elem\_count*)  

Selects bytes in `<src>`, whose element count is `<elem\_count>`, according to the bit value of the vector `<mask>`, and stores the result in `<dst>`. The bytes in `<src>` will be selected if corresponding bit values in `<mask>` are not equal to zero. If the bit value of mask is 1, stores the corresponding byte of `<src>` to `<dst>`; otherwise, keeps the corresponding byte in `<dst>` unchanged.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] mask`: The address of mask vector.
* `[in] elem\_count`: The length of source vector.



**Return*** `void`.






**Remark*** `<elem\_count> \* sizeof(type)` must be a multiple of 1024 bytes on `(m)tp\_2xx`;
* `<elem\_count> \* sizeof(type)` must be a multiple of 8 bytes on `(m)tp\_3xx`;
* `<src>`, `<mask>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>`, `<mask>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` can be overlapped with `<src>`;
* `<elem\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_maskmove instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.38. \_\_bang\_maskmove\_bitindex
-----------------------------------




void `__bang_maskmove_bitindex`(half \**dst*, *const* half \**src*, *const* void \**bitmask*, unsigned int *elem\_count*)  




void `__bang_maskmove_bitindex`(float \**dst*, *const* float \**src*, *const* void \**bitmask*, unsigned int *elem\_count*)  

Selects the corresponding elements in `<src>` according to `<bitmask>`. The elements in `<src>` will be saved to `<dst>`, if corresponding bit in `<bitmask>` is 1. All selected elements in `<dst>` will be stored continuously.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] bitmask`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* The `<src>`, `<bitmask>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The total number of bytes of `<dst>` is at least 128 on `(m)tp\_2xx`;
* The address of `<src>`, `<bitmask>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` must be divisible by 1024 on `(m)tp\_2xx`, and divisible by 8 on `mtp\_372` and `tp\_322`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_filter\_bitindex instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.39. \_\_bang\_max
--------------------




void `__bang_max`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_max`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Finds the maximum in a given vector. The result is composed of two parts. The first part is the maximum value of corresponding data type, the second part is the index of the maximum value in `<src>` vector, whose data type is `unsigned int`. The maximum value and index are stored continuously in `<dst>`. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The `\_\_nram\_\_` address space to which `<dst>` points must be at least 128 bytes on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* This function was deprecated from CNCC v4.1.0. Use \_\_bang\_argmax instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define DATA\_SIZE 128

\_\_mlu\_entry\_\_ void kernel(float \*c, float \*a) {
  \_\_nram\_\_ float a\_tmp[DATA\_SIZE];
  \_\_nram\_\_ float c\_tmp[DATA\_SIZE];
  \_\_memcpy(a\_tmp, a, DATA\_SIZE \* sizeof(float), GDRAM2NRAM);
  \_\_bang\_max(c\_tmp, a\_tmp, DATA\_SIZE);
  \_\_memcpy(c, c\_tmp, DATA\_SIZE \* sizeof(float), NRAM2GDRAM);
}

```













4.40. \_\_bang\_maximum
------------------------




void `__bang_maximum`(half \**dst*, *const* half \**src*, int *distance*, unsigned int *size*)  

Finds maximum value of each two corresponding elements in two vectors between which the distance is `<distance>`. See the table Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] distance`: The distance between the two source vector.
* `[in] size`: The elements number of destination vector.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` cannot be overlapped with `<src>`;
* `<size> \* sizeof (type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_maxequal instead.









**Instruction Pipeline*** Compute.






**Requirements*** None.






**Example**








4.41. \_\_bang\_maxpool
------------------------




void `__bang_maxpool`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *kernel\_height*, unsigned int *kernel\_width*, unsigned int *stride\_width*, unsigned int *stride\_height*)  

Applies maxpooling forward operation on `<src>` [`<height>`, `<width>`, `<channel>`], a three-dimensional tensor with sliding window [`<kernel\_height>`, `<kernel\_width>`] and stride [`<stride\_width>`, `<stride\_height>`], and selects the maximum value in each window. When window is slid in certain direction (H or W direction), if the left elements number doesnt match the window size, these elements will be discarded. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information. If there are multiple maximum values, the result is the first maximum value.









**Parameters*** `[out] dst`: The address of destination tensor. And the tensor data layout is HWC.
* `[in] src`: The address of source tensor. And the tensor data layout is HWC.
* `[in] channel`: Input channel.
* `[in] height`: The height of input feature map.
* `[in] width`: The width of input feature map.
* `[in] kernel\_height`: The height of sliding window.
* `[in] kernel\_width`: The width of sliding window.
* `[in] stride\_width`: Stride of sliding window in W direction.
* `[in] stride\_height`: Stride of sliding window in H direction.
* `[in] in\_dh`: Dilation in H direction of input.
* `[in] in\_dw`: Dilation in W direction of input.
* `[in] out\_dh`: Dilation in H direction of output.
* `[in] out\_dw`: Dilation in W direction of output.



**Return*** `void`.






**Remark*** `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel>` \* `sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The function with dilation is supported on `(m)tp\_3xx` or higher;
* `<dst>` cannot be overlapped with `<src>`;
* In the function without stride, `<stride\_width>` equals `<kernel\_width>` and `<stride\_height>` equals `<kernel\_height>`;
* `<channel>`, `<height>`, `<width>`, `<kernel\_height>`, `<kernel\_width>`, `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` must be greater than 0;
* `<stride\_height>` and `<stride\_width>` must be greater than 0 if specified;
* \((kernel\\_height \times kernel\\_width) \leq 2^{16}\);
* The default value for `<in\_dh>`, `<in\_dw>`, `<out\_dh>` and `<out\_dw>` is 1 which means no dilation.
* This function was deprecated from CNCC v4.5.0. Use \_\_bang\_sumpool and \_\_bang\_cycle\_mul instead on (m)tp\_2xx or use \_\_bang\_sumpool and \_\_bang\_mul\_scalar instead on (m)tp\_3xx or higher.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include <bang.h>

#define CHANNELS 64
#define HEIGHT 4
#define WIDTH 4
#define KERNEL\_HEIGHT 2
#define KERNEL\_WIDTH 2
#define BOTTOM\_DATA\_COUNT ((CHANNELS) \* (WIDTH) \* (HEIGHT))
#define TOP\_DATA\_COUNT \
  ((CHANNELS) \* (HEIGHT / KERNEL\_HEIGHT) \* (WIDTH / KERNEL\_WIDTH))

\_\_mlu\_entry\_\_ void maxPoolingKernel(half\* bottom\_data, half\* top\_data,
                                    int channels, int height, int width,
                                    int pooled\_height, int pooled\_width) {
  \_\_nram\_\_ half a\_tmp[BOTTOM\_DATA\_COUNT];
  \_\_nram\_\_ half b\_tmp[TOP\_DATA\_COUNT];
  \_\_memcpy(a\_tmp, bottom\_data, BOTTOM\_DATA\_COUNT \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_maxpool(b\_tmp, a\_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL\_HEIGHT, KERNEL\_WIDTH);
  \_\_memcpy(top\_data, b\_tmp, TOP\_DATA\_COUNT \* sizeof(half), NRAM2GDRAM);
}

```













4.42. \_\_bang\_min
--------------------




void `__bang_min`(half \**dst*, *const* half \**src*, unsigned int *elem\_count*)  




void `__bang_min`(float \**dst*, *const* float \**src*, unsigned int *elem\_count*)  

Finds the minimum value in `<src>` and stores the result in `<dst>`. The result consists of two parts, the first part is the minimum value of corresponding type, and the second part is the index of the minimum value, whose data type is `unsigned int`. The minimum value and index are stored continuously. See the table Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The `\_\_nram\_\_` address space to which `<dst>` points must be at least 128 bytes on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst>` cannot be overlapped with `<src>`;
* This function was deprecated from CNCC v4.1.0. Use \_\_bang\_argmin instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.43. \_\_bang\_mul\_const
---------------------------




void `__bang_mul_const`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_mul_const`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function multiplies `<elem\_count>` elements of `<src>` by `<value>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<dst>` can be overlapped with `<src>`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_mul\_scalar instead.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_add\_const for more details.













4.44. \_\_bang\_pad
--------------------




void `__bang_pad`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(short \**dst*, *const* short \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(unsigned short \**dst*, *const* unsigned short \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(int8\_t \**dst*, *const* int8\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(char \**dst*, *const* char \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(unsigned char \**dst*, *const* unsigned char \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(int \**dst*, *const* int \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(unsigned int \**dst*, *const* unsigned int \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*)  




void `__bang_pad`(half \**dst*, *const* half \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*, half *pad\_value*)  




void `__bang_pad`(short \**dst*, *const* short \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*, short *pad\_value*)  




void `__bang_pad`(char \**dst*, *const* char \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*, char *pad\_value*)  




void `__bang_pad`(float \**dst*, *const* float \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*, float *pad\_value*)  




void `__bang_pad`(int \**dst*, *const* int \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*, unsigned int *pad\_value*)  




void `__bang_pad`(bfloat16\_t \**dst*, *const* bfloat16\_t \**src*, unsigned int *channel*, unsigned int *height*, unsigned int *width*, unsigned int *pad\_height*, unsigned int *pad\_width*, bfloat16\_t *pad\_value*)  

Applies padding operation on `<src>`.



**Parameters*** `[out] dst`: The destination vector, whose data layout is HWC.
* `[in] src`: The source vector, whose data layout is HWC.
* `[in] channel`: Number of channels.
* `[in] height`: The height of `<src>`.
* `[in] width`: The width of `<src>`.
* `[in] pad\_width`: Number of columns whose elements is all zero or `<pad\_value>` on the horizontal of pad.
* `[in] pad\_height`: Number of columns whose elements is all zero or `<pad\_value>` on the vertical of pad.
* `[in] pad\_value`: The value of padding.



**Return*** `void`.






**Remark*** `<height>` and `<width>` must be greater than 0;
* `bfloat16\_t` is supported on `(m)tp\_5xx` or higher;
* `<dst>` cannot be overlapped with `<src>`;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<channel> \* <width> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* `<pad\_width> \* <channel> \* sizeof(type)` must be 128-byte aligned on `(m)tp\_2xx`;
* If `<height> == 1`, `<pad\_width>` must be equal to 0;
* `<pad\_value>` are only supported on `(m)tp\_5xx` or higher;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_pad instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example**
```
#include<bang.h>

#define PAD\_H 1
#define PAD\_W 2
#define INPUT\_H 4
#define INPUT\_W 4
#define CHANNEL 64

\_\_mlu\_entry\_\_ void kernel(half \*out, half \*in) {
  \_\_nram\_\_ half nx[CHANNEL \* INPUT\_H \* INPUT\_W];
  \_\_nram\_\_ half ny[CHANNEL \* (INPUT\_H + 2 \* PAD\_H) \* (INPUT\_W + 2 \* PAD\_W)];
  \_\_memcpy(nx, in, CHANNEL \* INPUT\_H \* INPUT\_W \* sizeof(half), GDRAM2NRAM);
  \_\_bang\_pad(ny, nx, CHANNEL, INPUT\_H, INPUT\_W, PAD\_H, PAD\_W);
  \_\_memcpy(out, ny, CHANNEL \* (INPUT\_H + 2 \* PAD\_H) \* (INPUT\_W + 2 \* PAD\_W) \* sizeof(half), NRAM2GDRAM);
}

```













4.45. \_\_bang\_select
-----------------------




void `__bang_select`(half \**dst*, *const* half \**src*, *const* half \**index*, unsigned int *elem\_count*)  




void `__bang_select`(float \**dst*, *const* float \**src*, *const* float \**index*, unsigned int *elem\_count*)  

Selects elements in one vector according to the corresponding values in another vector. The elements in `<src>` will be selected if corresponding elements in `<index>` are not equal to zero. The result is composed of three parts. The first 4-byte is the number of selected element, whose data type is `unsigned int`. The next 124-byte is zero. The rest bytes are the selected elements.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] index`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* The `<src>`, `<index>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count> \* sizeof(type)` must be a multiple of 128 bytes;
* The address of `<src>`, `<index>` and `<dst>` must be 64-byte aligned;
* If the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;
* The reserved space for selected data in `<dst>` cannot be smaller than the size of `<src>` and if the selected elements(including pad) does not fill the entire `<dst>` space, the remaining data in `<dst>` may also be changed;
* This function was deprecated from CNCC v4.1.0. Use \_\_bang\_filter instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.46. \_\_bang\_select\_bitindex
---------------------------------




void `__bang_select_bitindex`(half \**dst*, *const* half \**src*, *const* void \**bitindex*, unsigned int *elem\_count*)  




void `__bang_select_bitindex`(float \**dst*, *const* float \**src*, *const* void \**bitindex*, unsigned int *elem\_count*)  

Selects elements in `<src>` if the corresponding bit values in `<bitindex>` are not equal to zero. The result is saved to `<dst>`, which composes of three parts. The first 4-byte is the number of selected elements, whose data type is `unsigned int`. The next 124-byte is zero. The rest bytes are the selected elements.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of first source vector.
* `[in] bitindex`: The address of second source vector.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` can be overlapped with `<src>`;
* The `<src>`, `<bitindex>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be divisible by 512;
* The address of `<src>`, `<bitindex>` and `<dst>` must be 64-byte aligned;
* If the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the padding bytes will be set to zero;
* The reserved space for selected data in `<dst>` cannot be smaller than the size of `<src>` and if the selected elements(including pad) does not fill the entire `<dst>` space, the remaining data in `<dst>` may also be changed;
* This function was deprecated from CNCC v4.1.0. Use \_\_bang\_filter\_bitindex instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.47. \_\_bang\_short2char
---------------------------




void `__bang_short2char`(int8\_t \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int8\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` can be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_int162int8 instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int8\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int8\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_short2char(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int8\_t), NRAM2GDRAM);
}

```













4.48. \_\_bang\_short2int
--------------------------




void `__bang_short2int`(int32\_t \**dst*, *const* int16\_t \**src*, unsigned int *src\_count*, int *dst\_position*, int *src\_position*)  

This function converts type of `<src>` from `int16\_t` to `int32\_t` element-wisely in round-to-zero mode and saves the result in `<dst>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] src\_count`: The number of elements.
* `[in] dst\_position`: Scale factor of destination vector, i.e., \(<dst> \times 2^{<dst\\_position>}\).
* `[in] src\_position`: Scale factor of source vector, i.e., \(<src> \times 2^{<src\\_position>}\).



**Return*** `void`.






**Remark*** `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src\_position>` and `<dst\_position>` must be in the range `[-127,127]`;
* `<src>` cannot be overlapped with `<dst>`;
* `<src\_count>` must be greater than zero;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_int162int32 instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 322`;
* CNCC Version: `cncc --version >= 3.0.0`;
* Cambricon BANG Compute Arch Version: `cncc -bang-arch >= compute\_30`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_3xx`.






**Example**
```
#include <bang.h>

#define SIZE 128
#define DST\_POS 3
#define SRC\_POS 5

\_\_mlu\_entry\_\_ void kernel(int32\_t \*dst, int16\_t \*src) {
  \_\_nram\_\_ int16\_t src\_tmp[SIZE];
  \_\_nram\_\_ int32\_t dst\_tmp[SIZE];
  \_\_memcpy(src\_tmp, src, SIZE \* sizeof(int16\_t), GDRAM2NRAM);
  \_\_bang\_short2int(dst\_tmp, src\_tmp, SIZE, DST\_POS, SRC\_POS);
  \_\_memcpy(dst, dst\_tmp, SIZE \* sizeof(int32\_t), NRAM2GDRAM);
}

```













4.49. \_\_bang\_sub\_const
---------------------------




void `__bang_sub_const`(half \**dst*, *const* half \**src*, half *value*, unsigned int *elem\_count*)  




void `__bang_sub_const`(float \**dst*, *const* float \**src*, float *value*, unsigned int *elem\_count*)  

This function subtracts `<value>` from `<elem\_count>` elements of `<src>` and saves the result in `<dst>`. See the table Floating Point Calculation of Stream and Scalar Binary Operation Functions for accuracy information.









**Parameters*** `[out] dst`: The address of destination vector.
* `[in] src`: The address of source vector.
* `[in] value`: The source scalar.
* `[in] elem\_count`: The number of elements in source vector.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* `<src>` can be overlapped with `<dst>`;
* `<elem\_count> \* sizeof(type)` must be divisible by 128 on `(m)tp\_2xx`;
* The address of `<src>` and `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_sub\_scalar instead.






**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.8.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** See the example of \_\_bang\_add\_const for more details.













4.50. \_\_bang\_unlock
-----------------------




void `__bang_unlock`(int *lock\_id\_0*, int *lock\_id\_1*)  

Releases lock\_id.



**Parameters*** `[in] lock\_id\_0`: The first lock id.
* `[in] lock\_id\_1`: The second lock id.



**Return*** `void`.






**Remark*** This function was deprecated from CNCC v4.0.0;
* \_\_bang\_unlock is always paired with \_\_bang\_lock;
* For MLU Core, `lock\_id\_0` should be equal to `lock\_id\_1`;
* For MPU Core, `lock\_id\_0` should be not equal to `lock\_id\_1`;
* \_\_bang\_unlock can be used after `\_\_memcpy` from to GDRAM, whose size is larger than 64KB.






**Instruction Pipeline*** NA.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= mtp\_2xx`.






**Example*** See the example of \_\_bang\_unlock for more detail.













4.51. \_\_memcpy\_nram\_to\_nram
---------------------------------




void `__memcpy_nram_to_nram`(void \**dst*, *const* void \**src*, unsigned int *size*, int *dst\_stride*, int *src\_stride*, int *segnum*)  

Copies `<size>` bytes data from `<src>` source address to `<dst>` destination address. Both `<src>` and `<dst>` are in `\_\_nram\_\_` address space.


We recommended this function for memory copy within `\_\_nram\_\_` address space on `(m)tp\_2xx` series for better performance, but it has 128-bytes alignment constraint.



**Parameters*** `[out] dst`: The address of destination area.
* `[in] src`: The address of source area.
* `[in] size`: The number of bytes to be copied.
* `[in] dst\_stride`: Destination address stride.
* `[in] src\_stride`: Source address stride.
* `[in] segnum`: The number of data blocks to be copied.



**Return*** `void`.






**Remark*** `<size>` must be greater than zero and divisible by 128;
* `<segnum>` is in the range [1, 4096];
* `<src>` and `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<dst>` and `<src>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<dst\_stride>` and `<src\_stride>` must be greater than or equal to zero, and must be divisible by 64;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_move instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.52. \_\_nramset
------------------




void `__nramset`(void \**dst*, unsigned int *elem\_count*, char *value*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, short *value*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, float *value*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, half *value*)  




void `__nramset`(void \**dst*, unsigned int *elem\_count*, int *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 64 on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_write\_value instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.53. \_\_nramset\_float
-------------------------




void `__nramset_float`(float \**dst*, unsigned int *elem\_count*, float *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<elem\_count>` must be greater than zero;
* `<dst>` must point to `\_\_nram\_\_` address space;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 64 on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_write\_value instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.54. \_\_nramset\_half
------------------------




void `__nramset_half`(half \**dst*, unsigned int *elem\_count*, half *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 64 on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_write\_value instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.55. \_\_nramset\_int
-----------------------




void `__nramset_int`(int \**dst*, unsigned int *elem\_count*, int *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 64 on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_write\_value instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.56. \_\_nramset\_short
-------------------------




void `__nramset_short`(short \**dst*, unsigned int *elem\_count*, short *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 64 on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_write\_value instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 2.12.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.57. \_\_nramset\_unsigned\_int
---------------------------------




void `__nramset_unsigned_int`(unsigned int \**dst*, unsigned int *elem\_count*, unsigned int *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 64 on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_write\_value instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.













4.58. \_\_nramset\_unsigned\_short
-----------------------------------




void `__nramset_unsigned_short`(unsigned short \**dst*, unsigned int *elem\_count*, unsigned short *value*)  

Sets a vector in `\_\_nram\_\_` address space pointed by `<dst>` to the specified `<value>`.



**Parameters*** `[out] dst`: The address of destination vector.
* `[in] elem\_count`: The number of elements to be set.
* `[in] value`: Value to be set.



**Return*** `void`.






**Remark*** `<dst>` must point to `\_\_nram\_\_` address space;
* `<elem\_count>` must be greater than zero;
* The address of `<dst>` must be 64-byte aligned on `(m)tp\_2xx`;
* `<elem\_count>` \* `sizeof(type)` must be divisible by 64 on `(m)tp\_2xx`;
* This function was deprecated from CNCC v4.0.0. Use \_\_bang\_write\_value instead.









**Instruction Pipeline*** Compute.






**Requirements*** Cambricon BANG Version: `\_\_BANG\_ARCH\_\_ >= 200`;
* CNCC Version: `cncc --version >= 3.5.0`;
* Cambricon BANG Compute Arch Version: `cncc --bang-arch >= compute\_20`;
* MLU Compute Arch Version: `cncc --bang-mlu-arch >= (m)tp\_2xx`.






**Example*** None.

















5. Appendix
============



5.1. Rounding Mode
-------------------




Table 5.1 Rounding Mode





| Rounding Mode | Abbreviation | Description | Example of Float2Int |
| --- | --- | --- | --- |
| round-to-zero | `tz` | Round towards zero. | tz(1.564) = 1
tz(-1.564) = -1 |
| round-off-zero | `oz` | Round away from zero. | oz(1.364) = 2
oz(-1.364) = -2 |
| round-up | `up` | Round towards positive
infinity. | up(1.364) = 2
up(-1.564) = -1 |
| round-down | `dn` | Round towards negative
infinity. | dn(1.564) = 1
dn(-1.364) = -2 |
| round-nearest-off-zero | `rd` | Round away from zero
when fraction is not
less than 0.5.
Otherwise, round
towards zero. | rd(1.55) = 2
rd(1.35) = 1
rd(-2.5) = -3 |
| round-math | `rm` | Round towards negative
infinity after adding(
non-negative) or
subtracting(negative)
0.5. | rm(1.5) = 2
rm(-1.5) = -1 |
| round-nearest-even | `rn` | Round to nearest even
number when fraction
is 0.5.
Round away from
zero when fraction is
greater than 0.5.
Otherwise, round
towards zero. | rn(-2.5) = -2
rn(2.6) = 3
rn(1.1) = 1
rn(0.5) = 0 |
| round-stochastic | `sr` | Stochastic Rounding. | NA |



Note



Rounding modes `rm` and `rn` are only supported on `(m)tp\_3xx` and higher;
Rounding modes `sr` is only supported on `(m)tp\_5xx` and higher.




5.2. Floating Point Calculation
--------------------------------



### 5.2.1. Stream and Scalar Binary Operation Functions


The situation of stream and scalar binary operation functions processing `Number/Inf/NaN` is as follows:




Table 5.2 Floating Point Calculation of Stream and Scalar Binary Operation Functions







| src0 | src1 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- | --- |
| Number | Number | Number | Number/Inf | Number/Inf | Number/Inf |
| Number | Inf | Sat | Sat/Inf/NaN | Inf/NaN | Sat/Inf/Nan |
| Number | NaN | Sat | Sat/NaN | NaN | Sat/NaN |
| Inf | Number | Sat | Sat/Inf/NaN | Inf/NaN | Sat/Inf/NaN |
| Inf | Inf | Sat | Sat/Inf/NaN | Inf/NaN | Sat/Inf/NaN |
| Inf | NaN | Sat | Sat/NaN | NaN | Sat/NaN |
| NaN | Number | Sat | Sat/NaN | NaN | Sat/NaN |
| NaN | Inf | Sat | Sat/NaN | NaN | Sat/NaN |
| NaN | NaN | Sat | Sat/NaN | NaN | Sat/NaN |



Note


* `Number` means finite number.
* `Sat` means positive or negative saturation number, which belongs to finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `NaN` means `Not a Number`.





### 5.2.2. Stream and Scalar Unary Operation Functions


The situation of stream and scalar unary operation functions processing `Number/Inf/NaN` is as follows:




Table 5.3 Floating Point Calculation of Stream and Scalar Unary Operation Functions






| src | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- |
| Number | Number | Number/Inf/NaN | Number/Inf/NaN | Number/Inf/NaN |
| Inf | Number | Number/Inf/NaN | Number/Inf/NaN | Number/Inf/NaN |
| NaN | Sat | Sat/NaN | NaN | Sat/NaN |



Note


* `Number` means finite number.
* `Sat` means positive or negative saturation number, which belongs to finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `NaN` means `Not a Number`.





### 5.2.3. Stream and Scalar Comparison Functions


The situation of stream and scalar comparison functions processing `Number/Inf/NaN` is as follows:




Table 5.4 Floating Point Calculation of Stream and Scalar Comparison Functions







| src0 | src1 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- | --- |
| Number | Number | 0/1 | 0/1 | 0/1 | 0/1 |
| Number | Inf | 0/1 | 0/1 | 0/1 | 0/1 |
| Number | NaN | 0 | 0 | 0 | 0/1 |
| Inf | Number | 0/1 | 0/1 | 0/1 | 0/1 |
| Inf | Inf | 0/1 | 0/1 | 0/1 | 0/1 |
| Inf | NaN | 0 | 0 | 0 | 0/1 |
| NaN | Number | 0 | 0 | 0 | 0/1 |
| NaN | Inf | 0 | 0 | 0 | 0/1 |
| NaN | NaN | 0 | 0 | 0 | 0/1 |



Note


* `Number` means finite number.
* `Sat` means positive or negative saturation number, which belongs to finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `NaN` means `Not a Number`.





### 5.2.4. Element-wise Stream and Scalar Comparison Operation Functions


The situation of stream and scalar comparison functions processing `Number/Inf/NaN` is as follows:




Table 5.5 Element-wise Floating Point Calculation of Stream and Scalar Comparison Operation Functions







| src0 | src1 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- | --- |
| Number | Number | Number | Number | Number | Number |
| Number | Inf | Number/Inf | Number/Inf | Number/Inf | Number/Inf |
| Number | NaN | Sat | Number | Number | Number/Inf |
| Inf | Number | Number/Inf | Number/Inf | Number/Inf | Number/Inf |
| Inf | Inf | Inf | Inf | Inf | Inf |
| Inf | NaN | Sat | Sat/Inf | Inf | Sat/NaN/Inf |
| NaN | Number | Sat | Sat/NaN | NaN | Sat/NaN |
| NaN | Inf | Sat | Sat/NaN | NaN | Sat/NaN/Inf |
| NaN | NaN | Sat | Sat/NaN | NaN | Sat/NaN |



Note


* `Number` means finite number.
* `Sat` means positive or negative saturation number, which belongs to finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `NaN` means `Not a Number`.





### 5.2.5. Non-element-wise Stream Comparison Operation Functions


The situation of stream comparison functions processing `Number/Inf/NaN` is as follows:




Table 5.6 Non-element-wise Floating Point Calculation of Stream Comparison Operation Functions






| src | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- |
| Number | Number | Number | Number | Number |
| Inf | Inf | Inf | Inf | Inf |
| NaN | NaN | NaN | NaN | NaN |
| Number/Inf | Number/Inf | Number/Inf | Number/Inf | Number/Inf |
| Number/NaN | Number | Number | Number | Number/Inf |
| NaN/Number | NaN | NaN | NaN | Number/Inf |
| Inf/NaN | Inf | Inf | Inf | Inf/NaN |
| NaN/Inf | NaN | NaN | NaN | Inf/NaN |
| Number/Inf,NaN | Number/Inf | Number/Inf | Number/Inf | Number/Inf/NaN |
| NaN/Number,Inf | NaN | NaN | NaN | Number/Inf/NaN |



Note


* `Number` means finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `NaN` means `Not a Number`.
* `Number/Inf,NaN` means that the first operand is `Number`, and the other operands are `Inf` and `NaN`.
* `NaN/Number,Inf` means that the first operand is `NaN`, and the other operands are `Number` and `Inf`.





### 5.2.6. Stream and Scalar Binary Logic and Bit Operation Functions


The situation of stream and scalar binary logic and bit operation functions processing `Number/Inf/NaN` is as follows:




Table 5.7 Floating Point Calculation of Stream and Scalar Binary Logic and Bit Operation Functions







| src0 | src1 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- | --- |
| Number | Number | 0/1 | 0/1 | 0/1 | 0/1 |
| Number | Inf | 0/1 | 0/1 | 0/1 | 0/1 |
| Number | NaN | 0/1 | 0/1 | 0/1 | 0/1 |
| Inf | Number | 0/1 | 0/1 | 0/1 | 0/1 |
| Inf | Inf | 1 | 1 | 1 | 1 |
| Inf | NaN | 1 | 1 | 1 | 1 |
| NaN | Number | 0/1 | 0/1 | 0/1 | 0/1 |
| NaN | Inf | 1 | 1 | 1 | 1 |
| NaN | NaN | 1 | 1 | 1 | 1 |



Note


* `Number` means finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `NaN` means `Not a Number`.





### 5.2.7. Stream and Scalar Unary Logic and Bit Operation Functions


The situation of stream and scalar unary logic and bit operation functions processing `Number/Inf/NaN` is as follows:




Table 5.8 Floating Point Calculation of Stream and Scalar Unary Logic and Bit Operation Functions






| src0 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- |
| Number | 0/1 | 0/1 | 0/1 | 0/1 |
| Inf | 0 | 0 | 0 | 0 |
| NaN | 0 | 0 | 0 | 0 |



Note


* `Number` means finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `NaN` means `Not a Number`.





### 5.2.8. Stream and Scalar Type Conversion from Floating Point to Integer


The situation of stream and scalar type conversion from floating point to integer processing `Number/Inf/NaN` is as follows:




Table 5.9 Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Integer






| src0 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- |
| Number | Number | Number | Number | Number |
| +Inf | +Sat | +Sat | +Sat | +Sat |
| -Inf | -Sat | -Sat | -Sat | -Sat |
| NaN | Sat | Sat | Sat | Sat/0 |



Note


* `Number` means finite number.
* `Sat` means positive or negative saturation number, which belongs to finite number.
* `+Sat` means positive saturation number.
* `-Sat` means negative saturation number.
* `+Inf` means positive infinity number.
* `-Inf` means negative infinity number.
* `NaN` means `Not a Number`.





### 5.2.9. Stream and Scalar Type Conversion from Floating Point to Floating Point


The situation of stream and scalar type conversion from floating point to floating point processing `Number/Inf/NaN` is as follows:




Table 5.10 Floating Point Calculation of Stream and Scalar Type Conversion from Floating Point to Floating Point






| src0 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- |
| Number | Number | Number/Inf | Number/Inf | Number/Inf |
| +Inf | +Sat | +Sat/+Inf | +Inf | +Sat/+Inf |
| -Inf | -Sat | -Sat/-Inf | -Inf | -Sat/-Inf |
| NaN | Sat | Sat/NaN | NaN | Sat/NaN |



Note


* `Number` means finite number.
* `Sat` means positive or negative saturation number, which belongs to finite number.
* `+Sat` means positive saturation number.
* `-Sat` means negative saturation number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `+Inf` means positive infinity number.
* `-Inf` means negative infinity number.
* `NaN` means `Not a Number`.





### 5.2.10. Stream and Scalar Type Conversion from Integer to Floating Point


The situation of stream and scalar type conversion from integer to floating point processing `Number` is as follows:




Table 5.11 Floating Point Calculation of Stream and Scalar Type Conversion from Integer to Floating Point






| src0 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- |
| Number | Number | Number/Inf | Number/Inf | Number/Inf |



Note


* `Number` means finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.





### 5.2.11. Stream and Scalar Div Operation Function


The situation of stream and scalar div operation function processing `Number/Inf/NaN` is as follows:




Table 5.12 Floating Point Calculation of Stream and Scalar Div Operation Function







| src0 | src1 | (m)tp\_2xx | tp\_322 | mtp\_372 | mtp\_592 |
| --- | --- | --- | --- | --- | --- |
| Number | Number | Number | Number/Inf/NaN | Number/NaN | Number/Inf/NaN |
| Number | Inf | Number | Number | NaN | Number |
| Number | NaN | Sat | Sat/NaN | NaN | NaN |
| Inf | Number | Sat | Sat/Inf | Inf/NaN | Sat/Inf |
| Inf | Inf | Sat | Sat/NaN | NaN | NaN |
| Inf | NaN | Sat | Sat/NaN | NaN | NaN |
| NaN | Number | Sat | Sat/NaN | NaN | NaN |
| NaN | Inf | Sat | Sat/NaN | NaN | NaN |
| NaN | NaN | Sat | Sat/NaN | NaN | NaN |



Note


* `Number` means finite number.
* `Sat` means positive or negative saturation number, which belongs to finite number.
* `Inf` means infinity number, including positive infinity and negative infinity.
* `NaN` means `Not a Number`.






5.3. Mathematical Functions
----------------------------


This section specifies all the functions of the C/C++ standard library mathematical functions that are supported in device-side code.




Table 5.13 Mathematical Functions and Macros



| Function | Description |
| --- | --- |
| abs | Returns the absolute value of the integer argument. |
| fabsf | Returns the absolute value of the floating-point argument. |
| acosf | Returns the arc cosine of the floating-point argument. |
| cosf | Returns the cosine of the floating-point argument. |
| coshf | Returns the hyperbolic cosine of the floating-point argument. |
| acoshf | Returns the inverse hyperbolic cosine of the floating-point argument. |
| sinf | Returns the sine of the floating-point argument. |
| sinhf | Returns the hyperbolic sine of the floating-point argument. |
| asinf | Returns the arc sine of the floating-point argument. |
| asinhf | Returns the inverse hyperbolic sine of the floating-point argument. |
| tanf | Returns the tangent of the floating-point argument. |
| atanf | Returns the arc tangent of the floating-point argument. |
| atanhf | Returns the inverse hyperbolic tangent of the floating-point argument. |
| atan2f | Returns the arc tangent of two floating-point arguments. |
| ceilf | Returns the smallest integral that is greater than or equal to the floating-point argument. |
| floor | Returns the largest integral that is less than or equal to the argument. |
| copysignf | Returns a value whose magnitude is taken from first argument and whose sign is taken from second argument. |
| expf | Returns e raised to the power of the floating-point argument. |
| expm1f | Returns e raised to the power of the floating-point argument minus 1. |
| exp2f | Returns 2 raised to the power of the floating-point argument. |
| fmaxf | Returns the maximum of two floating-point arguments. |
| fminf | Returns the minimum of two floating-point arguments. |
| isnan | Returns a nonzero value if the argument is NaN. |
| isinf | Returns a nonzero value if the argument is INF. |
| log2f | Returns the base-2 logarithm of the floating-point argument. |
| log10f | Returns the base-10 logarithm of the floating-point argument. |
| log1pf | Returns the logarithm of 1 plus the floating-point argument. |
| logbf | Returns the exponent of the floating-point argument. |
| powf | Returns the power of the floating-point argument. |
| roundf | Returns the round to nearest integer away from zero of the floating-point argument. |
| sqrtf | Returns the square root of the floating-point argument. |
| scalbnf | Returns the multiplication of the first argument by 2 to the power of the second argument. |
| truncf | Returns the rounded integer value of argument in floating format. |




5.4. Activation Table Space for Activation Function
----------------------------------------------------


This section specifies all the activation table space for the activation function.




Table 5.14 Activation Table Space for the Activation Function






| Activation function | Activation table
number(fp16) | Activation table
size(fp16) | Activation table
number(fp32) | Activation table
size(fp32) |
| --- | --- | --- | --- | --- |
| \_\_bang\_active\_abs | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_exp | 10 | 2560 B | 10 | 5120 B |
| \_\_bang\_active\_exphp | 10 | 2560 B | 30 | 15360 B |
| \_\_bang\_active\_exp\_less\_0 | 8 | 2048 B | 8 | 4096 B |
| \_\_bang\_active\_gelu | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_gelup | 14 | 3584 B | 14 | 7168 B |
| \_\_bang\_active\_log | 17 | 4352 B | 17 | 8704 B |
| \_\_bang\_active\_loghp | 25 | 6400 B | 53 | 27136 B |
| \_\_bang\_active\_pow2 | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_recip\_greater\_1 | 20 | 5120 B | 20 | 10240 B |
| \_\_bang\_active\_reciphp | 26 | 6656 B | 71 | 36352 B |
| \_\_bang\_active\_relu | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_rsqrt | 25 | 6400 B | 25 | 12800 B |
| \_\_bang\_active\_rsqrthp | 30 | 7680 B | 79 | 40448 B |
| \_\_bang\_active\_sigmoid | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_sign | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_sqrthp | 18 | 4608 B | 32 | 16384 B |
| \_\_bang\_active\_tanh | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_cos | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_recip | 27 | 6912 B | 27 | 13824 B |
| \_\_bang\_active\_sin | 1 | 256 B | 1 | 512 B |
| \_\_bang\_active\_sqrt | 17 | 4352 B | 17 | 8704 B |
| \_\_bang\_taylor3\_sin | 5 | 1280 B | 5 | 2560 B |
| \_\_bang\_taylor4\_sin | 6 | 1536 B | 6 | 3072 B |
| \_\_bang\_taylor3\_cos | 5 | 1280 B | 5 | 2560 B |
| \_\_bang\_taylor4\_cos | 6 | 1536 B | 6 | 3072 B |
| \_\_bang\_taylor3\_tanh | 5 | 1280 B | 5 | 2560 B |
| \_\_bang\_taylor4\_tanh | 6 | 1536 B | 6 | 3072 B |
| \_\_bang\_taylor3\_sigmoid | 5 | 1280 B | 5 | 2560 B |
| \_\_bang\_taylor4\_sigmoid | 6 | 1536 B | 6 | 3072 B |
| \_\_bang\_taylor3\_softplus | 5 | 1280 B | 5 | 2560 B |
| \_\_bang\_taylor4\_softplus | 6 | 1536 B | 6 | 3072 B |





